
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Verification
 * 
 */
export type Verification = $Result.DefaultSelection<Prisma.$VerificationPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Provider
 * 
 */
export type Provider = $Result.DefaultSelection<Prisma.$ProviderPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model ServicePackage
 * 
 */
export type ServicePackage = $Result.DefaultSelection<Prisma.$ServicePackagePayload>
/**
 * Model InsuranceProvider
 * 
 */
export type InsuranceProvider = $Result.DefaultSelection<Prisma.$InsuranceProviderPayload>
/**
 * Model ServiceInsurance
 * 
 */
export type ServiceInsurance = $Result.DefaultSelection<Prisma.$ServiceInsurancePayload>
/**
 * Model OperatingHour
 * 
 */
export type OperatingHour = $Result.DefaultSelection<Prisma.$OperatingHourPayload>
/**
 * Model BreakTime
 * 
 */
export type BreakTime = $Result.DefaultSelection<Prisma.$BreakTimePayload>
/**
 * Model Appointment
 * 
 */
export type Appointment = $Result.DefaultSelection<Prisma.$AppointmentPayload>
/**
 * Model AppointmentService
 * 
 */
export type AppointmentService = $Result.DefaultSelection<Prisma.$AppointmentServicePayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Conversation
 * 
 */
export type Conversation = $Result.DefaultSelection<Prisma.$ConversationPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model ReviewLike
 * 
 */
export type ReviewLike = $Result.DefaultSelection<Prisma.$ReviewLikePayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model ProviderStatusHistory
 * 
 */
export type ProviderStatusHistory = $Result.DefaultSelection<Prisma.$ProviderStatusHistoryPayload>
/**
 * Model SystemFeedback
 * 
 */
export type SystemFeedback = $Result.DefaultSelection<Prisma.$SystemFeedbackPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  USER: 'USER',
  ADMIN: 'ADMIN',
  PROVIDER: 'PROVIDER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const UserStatus: {
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED',
  DELETED: 'DELETED'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const ProviderStatus: {
  PENDING: 'PENDING',
  VERIFIED: 'VERIFIED',
  SUSPENDED: 'SUSPENDED',
  REJECTED: 'REJECTED'
};

export type ProviderStatus = (typeof ProviderStatus)[keyof typeof ProviderStatus]


export const AppointmentStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  NO_SHOW: 'NO_SHOW'
};

export type AppointmentStatus = (typeof AppointmentStatus)[keyof typeof AppointmentStatus]


export const ServiceType: {
  SINGLE: 'SINGLE',
  PACKAGE: 'PACKAGE'
};

export type ServiceType = (typeof ServiceType)[keyof typeof ServiceType]


export const PricingModel: {
  FIXED: 'FIXED',
  RANGE: 'RANGE'
};

export type PricingModel = (typeof PricingModel)[keyof typeof PricingModel]


export const DocumentVerificationStatus: {
  PENDING: 'PENDING',
  VERIFIED: 'VERIFIED',
  REJECTED: 'REJECTED'
};

export type DocumentVerificationStatus = (typeof DocumentVerificationStatus)[keyof typeof DocumentVerificationStatus]


export const NotificationType: {
  APPOINTMENT_CREATED: 'APPOINTMENT_CREATED',
  APPOINTMENT_CONFIRMED: 'APPOINTMENT_CONFIRMED',
  APPOINTMENT_CANCELLED: 'APPOINTMENT_CANCELLED',
  APPOINTMENT_REMINDER: 'APPOINTMENT_REMINDER',
  PROVIDER_VERIFIED: 'PROVIDER_VERIFIED',
  PROVIDER_REJECTED: 'PROVIDER_REJECTED',
  PROVIDER_SUSPENDED: 'PROVIDER_SUSPENDED',
  PROVIDER_REACTIVATED: 'PROVIDER_REACTIVATED',
  ACCOUNT_SUSPENDED: 'ACCOUNT_SUSPENDED',
  ACCOUNT_REACTIVATED: 'ACCOUNT_REACTIVATED',
  REVIEW_RECEIVED: 'REVIEW_RECEIVED',
  REVIEW_RESPONSE: 'REVIEW_RESPONSE'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const MessageStatus: {
  SENT: 'SENT',
  DELIVERED: 'DELIVERED',
  READ: 'READ'
};

export type MessageStatus = (typeof MessageStatus)[keyof typeof MessageStatus]


export const FeedbackCategory: {
  FEATURE_REQUEST: 'FEATURE_REQUEST',
  BUG_REPORT: 'BUG_REPORT',
  IMPROVEMENT: 'IMPROVEMENT',
  USER_EXPERIENCE: 'USER_EXPERIENCE',
  OTHER: 'OTHER'
};

export type FeedbackCategory = (typeof FeedbackCategory)[keyof typeof FeedbackCategory]


export const FeedbackPriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH'
};

export type FeedbackPriority = (typeof FeedbackPriority)[keyof typeof FeedbackPriority]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type ProviderStatus = $Enums.ProviderStatus

export const ProviderStatus: typeof $Enums.ProviderStatus

export type AppointmentStatus = $Enums.AppointmentStatus

export const AppointmentStatus: typeof $Enums.AppointmentStatus

export type ServiceType = $Enums.ServiceType

export const ServiceType: typeof $Enums.ServiceType

export type PricingModel = $Enums.PricingModel

export const PricingModel: typeof $Enums.PricingModel

export type DocumentVerificationStatus = $Enums.DocumentVerificationStatus

export const DocumentVerificationStatus: typeof $Enums.DocumentVerificationStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type MessageStatus = $Enums.MessageStatus

export const MessageStatus: typeof $Enums.MessageStatus

export type FeedbackCategory = $Enums.FeedbackCategory

export const FeedbackCategory: typeof $Enums.FeedbackCategory

export type FeedbackPriority = $Enums.FeedbackPriority

export const FeedbackPriority: typeof $Enums.FeedbackPriority

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.provider`: Exposes CRUD operations for the **Provider** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Providers
    * const providers = await prisma.provider.findMany()
    * ```
    */
  get provider(): Prisma.ProviderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.servicePackage`: Exposes CRUD operations for the **ServicePackage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServicePackages
    * const servicePackages = await prisma.servicePackage.findMany()
    * ```
    */
  get servicePackage(): Prisma.ServicePackageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.insuranceProvider`: Exposes CRUD operations for the **InsuranceProvider** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InsuranceProviders
    * const insuranceProviders = await prisma.insuranceProvider.findMany()
    * ```
    */
  get insuranceProvider(): Prisma.InsuranceProviderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceInsurance`: Exposes CRUD operations for the **ServiceInsurance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceInsurances
    * const serviceInsurances = await prisma.serviceInsurance.findMany()
    * ```
    */
  get serviceInsurance(): Prisma.ServiceInsuranceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.operatingHour`: Exposes CRUD operations for the **OperatingHour** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OperatingHours
    * const operatingHours = await prisma.operatingHour.findMany()
    * ```
    */
  get operatingHour(): Prisma.OperatingHourDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.breakTime`: Exposes CRUD operations for the **BreakTime** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BreakTimes
    * const breakTimes = await prisma.breakTime.findMany()
    * ```
    */
  get breakTime(): Prisma.BreakTimeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appointment`: Exposes CRUD operations for the **Appointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointment.findMany()
    * ```
    */
  get appointment(): Prisma.AppointmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appointmentService`: Exposes CRUD operations for the **AppointmentService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AppointmentServices
    * const appointmentServices = await prisma.appointmentService.findMany()
    * ```
    */
  get appointmentService(): Prisma.AppointmentServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **Conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.ConversationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reviewLike`: Exposes CRUD operations for the **ReviewLike** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReviewLikes
    * const reviewLikes = await prisma.reviewLike.findMany()
    * ```
    */
  get reviewLike(): Prisma.ReviewLikeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.providerStatusHistory`: Exposes CRUD operations for the **ProviderStatusHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProviderStatusHistories
    * const providerStatusHistories = await prisma.providerStatusHistory.findMany()
    * ```
    */
  get providerStatusHistory(): Prisma.ProviderStatusHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemFeedback`: Exposes CRUD operations for the **SystemFeedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemFeedbacks
    * const systemFeedbacks = await prisma.systemFeedback.findMany()
    * ```
    */
  get systemFeedback(): Prisma.SystemFeedbackDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Session: 'Session',
    Account: 'Account',
    Verification: 'Verification',
    Category: 'Category',
    Provider: 'Provider',
    Service: 'Service',
    ServicePackage: 'ServicePackage',
    InsuranceProvider: 'InsuranceProvider',
    ServiceInsurance: 'ServiceInsurance',
    OperatingHour: 'OperatingHour',
    BreakTime: 'BreakTime',
    Appointment: 'Appointment',
    AppointmentService: 'AppointmentService',
    Document: 'Document',
    Notification: 'Notification',
    Conversation: 'Conversation',
    Message: 'Message',
    Review: 'Review',
    ReviewLike: 'ReviewLike',
    AuditLog: 'AuditLog',
    ProviderStatusHistory: 'ProviderStatusHistory',
    SystemFeedback: 'SystemFeedback'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "session" | "account" | "verification" | "category" | "provider" | "service" | "servicePackage" | "insuranceProvider" | "serviceInsurance" | "operatingHour" | "breakTime" | "appointment" | "appointmentService" | "document" | "notification" | "conversation" | "message" | "review" | "reviewLike" | "auditLog" | "providerStatusHistory" | "systemFeedback"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>
        fields: Prisma.VerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Provider: {
        payload: Prisma.$ProviderPayload<ExtArgs>
        fields: Prisma.ProviderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProviderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProviderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          findFirst: {
            args: Prisma.ProviderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProviderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          findMany: {
            args: Prisma.ProviderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>[]
          }
          create: {
            args: Prisma.ProviderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          createMany: {
            args: Prisma.ProviderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProviderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>[]
          }
          delete: {
            args: Prisma.ProviderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          update: {
            args: Prisma.ProviderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          deleteMany: {
            args: Prisma.ProviderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProviderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProviderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>[]
          }
          upsert: {
            args: Prisma.ProviderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          aggregate: {
            args: Prisma.ProviderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProvider>
          }
          groupBy: {
            args: Prisma.ProviderGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProviderGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProviderCountArgs<ExtArgs>
            result: $Utils.Optional<ProviderCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      ServicePackage: {
        payload: Prisma.$ServicePackagePayload<ExtArgs>
        fields: Prisma.ServicePackageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServicePackageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePackagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServicePackageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePackagePayload>
          }
          findFirst: {
            args: Prisma.ServicePackageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePackagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServicePackageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePackagePayload>
          }
          findMany: {
            args: Prisma.ServicePackageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePackagePayload>[]
          }
          create: {
            args: Prisma.ServicePackageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePackagePayload>
          }
          createMany: {
            args: Prisma.ServicePackageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServicePackageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePackagePayload>[]
          }
          delete: {
            args: Prisma.ServicePackageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePackagePayload>
          }
          update: {
            args: Prisma.ServicePackageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePackagePayload>
          }
          deleteMany: {
            args: Prisma.ServicePackageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServicePackageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServicePackageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePackagePayload>[]
          }
          upsert: {
            args: Prisma.ServicePackageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePackagePayload>
          }
          aggregate: {
            args: Prisma.ServicePackageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServicePackage>
          }
          groupBy: {
            args: Prisma.ServicePackageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServicePackageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServicePackageCountArgs<ExtArgs>
            result: $Utils.Optional<ServicePackageCountAggregateOutputType> | number
          }
        }
      }
      InsuranceProvider: {
        payload: Prisma.$InsuranceProviderPayload<ExtArgs>
        fields: Prisma.InsuranceProviderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InsuranceProviderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceProviderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InsuranceProviderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceProviderPayload>
          }
          findFirst: {
            args: Prisma.InsuranceProviderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceProviderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InsuranceProviderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceProviderPayload>
          }
          findMany: {
            args: Prisma.InsuranceProviderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceProviderPayload>[]
          }
          create: {
            args: Prisma.InsuranceProviderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceProviderPayload>
          }
          createMany: {
            args: Prisma.InsuranceProviderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InsuranceProviderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceProviderPayload>[]
          }
          delete: {
            args: Prisma.InsuranceProviderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceProviderPayload>
          }
          update: {
            args: Prisma.InsuranceProviderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceProviderPayload>
          }
          deleteMany: {
            args: Prisma.InsuranceProviderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InsuranceProviderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InsuranceProviderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceProviderPayload>[]
          }
          upsert: {
            args: Prisma.InsuranceProviderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceProviderPayload>
          }
          aggregate: {
            args: Prisma.InsuranceProviderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInsuranceProvider>
          }
          groupBy: {
            args: Prisma.InsuranceProviderGroupByArgs<ExtArgs>
            result: $Utils.Optional<InsuranceProviderGroupByOutputType>[]
          }
          count: {
            args: Prisma.InsuranceProviderCountArgs<ExtArgs>
            result: $Utils.Optional<InsuranceProviderCountAggregateOutputType> | number
          }
        }
      }
      ServiceInsurance: {
        payload: Prisma.$ServiceInsurancePayload<ExtArgs>
        fields: Prisma.ServiceInsuranceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceInsuranceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInsurancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceInsuranceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInsurancePayload>
          }
          findFirst: {
            args: Prisma.ServiceInsuranceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInsurancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceInsuranceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInsurancePayload>
          }
          findMany: {
            args: Prisma.ServiceInsuranceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInsurancePayload>[]
          }
          create: {
            args: Prisma.ServiceInsuranceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInsurancePayload>
          }
          createMany: {
            args: Prisma.ServiceInsuranceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceInsuranceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInsurancePayload>[]
          }
          delete: {
            args: Prisma.ServiceInsuranceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInsurancePayload>
          }
          update: {
            args: Prisma.ServiceInsuranceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInsurancePayload>
          }
          deleteMany: {
            args: Prisma.ServiceInsuranceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceInsuranceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceInsuranceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInsurancePayload>[]
          }
          upsert: {
            args: Prisma.ServiceInsuranceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceInsurancePayload>
          }
          aggregate: {
            args: Prisma.ServiceInsuranceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceInsurance>
          }
          groupBy: {
            args: Prisma.ServiceInsuranceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceInsuranceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceInsuranceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceInsuranceCountAggregateOutputType> | number
          }
        }
      }
      OperatingHour: {
        payload: Prisma.$OperatingHourPayload<ExtArgs>
        fields: Prisma.OperatingHourFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OperatingHourFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatingHourPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OperatingHourFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatingHourPayload>
          }
          findFirst: {
            args: Prisma.OperatingHourFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatingHourPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OperatingHourFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatingHourPayload>
          }
          findMany: {
            args: Prisma.OperatingHourFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatingHourPayload>[]
          }
          create: {
            args: Prisma.OperatingHourCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatingHourPayload>
          }
          createMany: {
            args: Prisma.OperatingHourCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OperatingHourCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatingHourPayload>[]
          }
          delete: {
            args: Prisma.OperatingHourDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatingHourPayload>
          }
          update: {
            args: Prisma.OperatingHourUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatingHourPayload>
          }
          deleteMany: {
            args: Prisma.OperatingHourDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OperatingHourUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OperatingHourUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatingHourPayload>[]
          }
          upsert: {
            args: Prisma.OperatingHourUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatingHourPayload>
          }
          aggregate: {
            args: Prisma.OperatingHourAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOperatingHour>
          }
          groupBy: {
            args: Prisma.OperatingHourGroupByArgs<ExtArgs>
            result: $Utils.Optional<OperatingHourGroupByOutputType>[]
          }
          count: {
            args: Prisma.OperatingHourCountArgs<ExtArgs>
            result: $Utils.Optional<OperatingHourCountAggregateOutputType> | number
          }
        }
      }
      BreakTime: {
        payload: Prisma.$BreakTimePayload<ExtArgs>
        fields: Prisma.BreakTimeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BreakTimeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakTimePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BreakTimeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakTimePayload>
          }
          findFirst: {
            args: Prisma.BreakTimeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakTimePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BreakTimeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakTimePayload>
          }
          findMany: {
            args: Prisma.BreakTimeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakTimePayload>[]
          }
          create: {
            args: Prisma.BreakTimeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakTimePayload>
          }
          createMany: {
            args: Prisma.BreakTimeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BreakTimeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakTimePayload>[]
          }
          delete: {
            args: Prisma.BreakTimeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakTimePayload>
          }
          update: {
            args: Prisma.BreakTimeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakTimePayload>
          }
          deleteMany: {
            args: Prisma.BreakTimeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BreakTimeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BreakTimeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakTimePayload>[]
          }
          upsert: {
            args: Prisma.BreakTimeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BreakTimePayload>
          }
          aggregate: {
            args: Prisma.BreakTimeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBreakTime>
          }
          groupBy: {
            args: Prisma.BreakTimeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BreakTimeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BreakTimeCountArgs<ExtArgs>
            result: $Utils.Optional<BreakTimeCountAggregateOutputType> | number
          }
        }
      }
      Appointment: {
        payload: Prisma.$AppointmentPayload<ExtArgs>
        fields: Prisma.AppointmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppointmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppointmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findFirst: {
            args: Prisma.AppointmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppointmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findMany: {
            args: Prisma.AppointmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          create: {
            args: Prisma.AppointmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          createMany: {
            args: Prisma.AppointmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppointmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          delete: {
            args: Prisma.AppointmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          update: {
            args: Prisma.AppointmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          deleteMany: {
            args: Prisma.AppointmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppointmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AppointmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          upsert: {
            args: Prisma.AppointmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          aggregate: {
            args: Prisma.AppointmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppointment>
          }
          groupBy: {
            args: Prisma.AppointmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppointmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppointmentCountArgs<ExtArgs>
            result: $Utils.Optional<AppointmentCountAggregateOutputType> | number
          }
        }
      }
      AppointmentService: {
        payload: Prisma.$AppointmentServicePayload<ExtArgs>
        fields: Prisma.AppointmentServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppointmentServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppointmentServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentServicePayload>
          }
          findFirst: {
            args: Prisma.AppointmentServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppointmentServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentServicePayload>
          }
          findMany: {
            args: Prisma.AppointmentServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentServicePayload>[]
          }
          create: {
            args: Prisma.AppointmentServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentServicePayload>
          }
          createMany: {
            args: Prisma.AppointmentServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppointmentServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentServicePayload>[]
          }
          delete: {
            args: Prisma.AppointmentServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentServicePayload>
          }
          update: {
            args: Prisma.AppointmentServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentServicePayload>
          }
          deleteMany: {
            args: Prisma.AppointmentServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppointmentServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AppointmentServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentServicePayload>[]
          }
          upsert: {
            args: Prisma.AppointmentServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentServicePayload>
          }
          aggregate: {
            args: Prisma.AppointmentServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppointmentService>
          }
          groupBy: {
            args: Prisma.AppointmentServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppointmentServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppointmentServiceCountArgs<ExtArgs>
            result: $Utils.Optional<AppointmentServiceCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Conversation: {
        payload: Prisma.$ConversationPayload<ExtArgs>
        fields: Prisma.ConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findFirst: {
            args: Prisma.ConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findMany: {
            args: Prisma.ConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          create: {
            args: Prisma.ConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          createMany: {
            args: Prisma.ConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          delete: {
            args: Prisma.ConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          update: {
            args: Prisma.ConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          deleteMany: {
            args: Prisma.ConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConversationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          upsert: {
            args: Prisma.ConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          aggregate: {
            args: Prisma.ConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversation>
          }
          groupBy: {
            args: Prisma.ConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      ReviewLike: {
        payload: Prisma.$ReviewLikePayload<ExtArgs>
        fields: Prisma.ReviewLikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewLikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewLikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewLikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewLikePayload>
          }
          findFirst: {
            args: Prisma.ReviewLikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewLikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewLikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewLikePayload>
          }
          findMany: {
            args: Prisma.ReviewLikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewLikePayload>[]
          }
          create: {
            args: Prisma.ReviewLikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewLikePayload>
          }
          createMany: {
            args: Prisma.ReviewLikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewLikeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewLikePayload>[]
          }
          delete: {
            args: Prisma.ReviewLikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewLikePayload>
          }
          update: {
            args: Prisma.ReviewLikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewLikePayload>
          }
          deleteMany: {
            args: Prisma.ReviewLikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewLikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewLikeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewLikePayload>[]
          }
          upsert: {
            args: Prisma.ReviewLikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewLikePayload>
          }
          aggregate: {
            args: Prisma.ReviewLikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReviewLike>
          }
          groupBy: {
            args: Prisma.ReviewLikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewLikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewLikeCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewLikeCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      ProviderStatusHistory: {
        payload: Prisma.$ProviderStatusHistoryPayload<ExtArgs>
        fields: Prisma.ProviderStatusHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProviderStatusHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderStatusHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProviderStatusHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderStatusHistoryPayload>
          }
          findFirst: {
            args: Prisma.ProviderStatusHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderStatusHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProviderStatusHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderStatusHistoryPayload>
          }
          findMany: {
            args: Prisma.ProviderStatusHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderStatusHistoryPayload>[]
          }
          create: {
            args: Prisma.ProviderStatusHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderStatusHistoryPayload>
          }
          createMany: {
            args: Prisma.ProviderStatusHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProviderStatusHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderStatusHistoryPayload>[]
          }
          delete: {
            args: Prisma.ProviderStatusHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderStatusHistoryPayload>
          }
          update: {
            args: Prisma.ProviderStatusHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderStatusHistoryPayload>
          }
          deleteMany: {
            args: Prisma.ProviderStatusHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProviderStatusHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProviderStatusHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderStatusHistoryPayload>[]
          }
          upsert: {
            args: Prisma.ProviderStatusHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderStatusHistoryPayload>
          }
          aggregate: {
            args: Prisma.ProviderStatusHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProviderStatusHistory>
          }
          groupBy: {
            args: Prisma.ProviderStatusHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProviderStatusHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProviderStatusHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<ProviderStatusHistoryCountAggregateOutputType> | number
          }
        }
      }
      SystemFeedback: {
        payload: Prisma.$SystemFeedbackPayload<ExtArgs>
        fields: Prisma.SystemFeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemFeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemFeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemFeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemFeedbackPayload>
          }
          findFirst: {
            args: Prisma.SystemFeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemFeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemFeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemFeedbackPayload>
          }
          findMany: {
            args: Prisma.SystemFeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemFeedbackPayload>[]
          }
          create: {
            args: Prisma.SystemFeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemFeedbackPayload>
          }
          createMany: {
            args: Prisma.SystemFeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemFeedbackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemFeedbackPayload>[]
          }
          delete: {
            args: Prisma.SystemFeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemFeedbackPayload>
          }
          update: {
            args: Prisma.SystemFeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemFeedbackPayload>
          }
          deleteMany: {
            args: Prisma.SystemFeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemFeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemFeedbackUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemFeedbackPayload>[]
          }
          upsert: {
            args: Prisma.SystemFeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemFeedbackPayload>
          }
          aggregate: {
            args: Prisma.SystemFeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemFeedback>
          }
          groupBy: {
            args: Prisma.SystemFeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemFeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemFeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<SystemFeedbackCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    session?: SessionOmit
    account?: AccountOmit
    verification?: VerificationOmit
    category?: CategoryOmit
    provider?: ProviderOmit
    service?: ServiceOmit
    servicePackage?: ServicePackageOmit
    insuranceProvider?: InsuranceProviderOmit
    serviceInsurance?: ServiceInsuranceOmit
    operatingHour?: OperatingHourOmit
    breakTime?: BreakTimeOmit
    appointment?: AppointmentOmit
    appointmentService?: AppointmentServiceOmit
    document?: DocumentOmit
    notification?: NotificationOmit
    conversation?: ConversationOmit
    message?: MessageOmit
    review?: ReviewOmit
    reviewLike?: ReviewLikeOmit
    auditLog?: AuditLogOmit
    providerStatusHistory?: ProviderStatusHistoryOmit
    systemFeedback?: SystemFeedbackOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    accounts: number
    suspendedUsers: number
    verifiedProviders: number
    appointments: number
    cancelledAppointments: number
    notifications: number
    conversationsAsUser1: number
    conversationsAsUser2: number
    sentMessages: number
    reviews: number
    reviewLikes: number
    feedbackSubmitted: number
    feedbackResponses: number
    auditLogs: number
    providerStatusChanges: number
    verifiedDocuments: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    suspendedUsers?: boolean | UserCountOutputTypeCountSuspendedUsersArgs
    verifiedProviders?: boolean | UserCountOutputTypeCountVerifiedProvidersArgs
    appointments?: boolean | UserCountOutputTypeCountAppointmentsArgs
    cancelledAppointments?: boolean | UserCountOutputTypeCountCancelledAppointmentsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    conversationsAsUser1?: boolean | UserCountOutputTypeCountConversationsAsUser1Args
    conversationsAsUser2?: boolean | UserCountOutputTypeCountConversationsAsUser2Args
    sentMessages?: boolean | UserCountOutputTypeCountSentMessagesArgs
    reviews?: boolean | UserCountOutputTypeCountReviewsArgs
    reviewLikes?: boolean | UserCountOutputTypeCountReviewLikesArgs
    feedbackSubmitted?: boolean | UserCountOutputTypeCountFeedbackSubmittedArgs
    feedbackResponses?: boolean | UserCountOutputTypeCountFeedbackResponsesArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    providerStatusChanges?: boolean | UserCountOutputTypeCountProviderStatusChangesArgs
    verifiedDocuments?: boolean | UserCountOutputTypeCountVerifiedDocumentsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSuspendedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVerifiedProvidersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProviderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCancelledAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConversationsAsUser1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConversationsAsUser2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewLikeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFeedbackSubmittedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemFeedbackWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFeedbackResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemFeedbackWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProviderStatusChangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProviderStatusHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVerifiedDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    providers: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    providers?: boolean | CategoryCountOutputTypeCountProvidersArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProvidersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProviderWhereInput
  }


  /**
   * Count Type ProviderCountOutputType
   */

  export type ProviderCountOutputType = {
    services: number
    operatingHours: number
    appointments: number
    documents: number
    breakTimes: number
    notifications: number
    reviews: number
    statusHistory: number
  }

  export type ProviderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | ProviderCountOutputTypeCountServicesArgs
    operatingHours?: boolean | ProviderCountOutputTypeCountOperatingHoursArgs
    appointments?: boolean | ProviderCountOutputTypeCountAppointmentsArgs
    documents?: boolean | ProviderCountOutputTypeCountDocumentsArgs
    breakTimes?: boolean | ProviderCountOutputTypeCountBreakTimesArgs
    notifications?: boolean | ProviderCountOutputTypeCountNotificationsArgs
    reviews?: boolean | ProviderCountOutputTypeCountReviewsArgs
    statusHistory?: boolean | ProviderCountOutputTypeCountStatusHistoryArgs
  }

  // Custom InputTypes
  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderCountOutputType
     */
    select?: ProviderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }

  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeCountOperatingHoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperatingHourWhereInput
  }

  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeCountBreakTimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BreakTimeWhereInput
  }

  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeCountStatusHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProviderStatusHistoryWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    appointments: number
    includedServices: number
    partOfPackages: number
    acceptedInsurances: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | ServiceCountOutputTypeCountAppointmentsArgs
    includedServices?: boolean | ServiceCountOutputTypeCountIncludedServicesArgs
    partOfPackages?: boolean | ServiceCountOutputTypeCountPartOfPackagesArgs
    acceptedInsurances?: boolean | ServiceCountOutputTypeCountAcceptedInsurancesArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentServiceWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountIncludedServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicePackageWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountPartOfPackagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicePackageWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountAcceptedInsurancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceInsuranceWhereInput
  }


  /**
   * Count Type InsuranceProviderCountOutputType
   */

  export type InsuranceProviderCountOutputType = {
    services: number
  }

  export type InsuranceProviderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | InsuranceProviderCountOutputTypeCountServicesArgs
  }

  // Custom InputTypes
  /**
   * InsuranceProviderCountOutputType without action
   */
  export type InsuranceProviderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceProviderCountOutputType
     */
    select?: InsuranceProviderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InsuranceProviderCountOutputType without action
   */
  export type InsuranceProviderCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceInsuranceWhereInput
  }


  /**
   * Count Type AppointmentCountOutputType
   */

  export type AppointmentCountOutputType = {
    services: number
    notifications: number
  }

  export type AppointmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | AppointmentCountOutputTypeCountServicesArgs
    notifications?: boolean | AppointmentCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * AppointmentCountOutputType without action
   */
  export type AppointmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentCountOutputType
     */
    select?: AppointmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AppointmentCountOutputType without action
   */
  export type AppointmentCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentServiceWhereInput
  }

  /**
   * AppointmentCountOutputType without action
   */
  export type AppointmentCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type ConversationCountOutputType
   */

  export type ConversationCountOutputType = {
    messages: number
  }

  export type ConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ConversationCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     */
    select?: ConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type ReviewCountOutputType
   */

  export type ReviewCountOutputType = {
    likes: number
  }

  export type ReviewCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    likes?: boolean | ReviewCountOutputTypeCountLikesArgs
  }

  // Custom InputTypes
  /**
   * ReviewCountOutputType without action
   */
  export type ReviewCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewCountOutputType
     */
    select?: ReviewCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReviewCountOutputType without action
   */
  export type ReviewCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewLikeWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    role: $Enums.UserRole | null
    status: $Enums.UserStatus | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    suspendedAt: Date | null
    suspendReason: string | null
    suspendedById: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    role: $Enums.UserRole | null
    status: $Enums.UserStatus | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    suspendedAt: Date | null
    suspendReason: string | null
    suspendedById: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    role: number
    status: number
    emailVerified: number
    image: number
    createdAt: number
    updatedAt: number
    suspendedAt: number
    suspendReason: number
    suspendedById: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    role?: true
    status?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    suspendedAt?: true
    suspendReason?: true
    suspendedById?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    role?: true
    status?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    suspendedAt?: true
    suspendReason?: true
    suspendedById?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    role?: true
    status?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    suspendedAt?: true
    suspendReason?: true
    suspendedById?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    role: $Enums.UserRole
    status: $Enums.UserStatus
    emailVerified: boolean
    image: string | null
    createdAt: Date
    updatedAt: Date
    suspendedAt: Date | null
    suspendReason: string | null
    suspendedById: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
    status?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    suspendedAt?: boolean
    suspendReason?: boolean
    suspendedById?: boolean
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    suspendedBy?: boolean | User$suspendedByArgs<ExtArgs>
    suspendedUsers?: boolean | User$suspendedUsersArgs<ExtArgs>
    provider?: boolean | User$providerArgs<ExtArgs>
    verifiedProviders?: boolean | User$verifiedProvidersArgs<ExtArgs>
    appointments?: boolean | User$appointmentsArgs<ExtArgs>
    cancelledAppointments?: boolean | User$cancelledAppointmentsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    conversationsAsUser1?: boolean | User$conversationsAsUser1Args<ExtArgs>
    conversationsAsUser2?: boolean | User$conversationsAsUser2Args<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    reviewLikes?: boolean | User$reviewLikesArgs<ExtArgs>
    feedbackSubmitted?: boolean | User$feedbackSubmittedArgs<ExtArgs>
    feedbackResponses?: boolean | User$feedbackResponsesArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    providerStatusChanges?: boolean | User$providerStatusChangesArgs<ExtArgs>
    verifiedDocuments?: boolean | User$verifiedDocumentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
    status?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    suspendedAt?: boolean
    suspendReason?: boolean
    suspendedById?: boolean
    suspendedBy?: boolean | User$suspendedByArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
    status?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    suspendedAt?: boolean
    suspendReason?: boolean
    suspendedById?: boolean
    suspendedBy?: boolean | User$suspendedByArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
    status?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    suspendedAt?: boolean
    suspendReason?: boolean
    suspendedById?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "role" | "status" | "emailVerified" | "image" | "createdAt" | "updatedAt" | "suspendedAt" | "suspendReason" | "suspendedById", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    suspendedBy?: boolean | User$suspendedByArgs<ExtArgs>
    suspendedUsers?: boolean | User$suspendedUsersArgs<ExtArgs>
    provider?: boolean | User$providerArgs<ExtArgs>
    verifiedProviders?: boolean | User$verifiedProvidersArgs<ExtArgs>
    appointments?: boolean | User$appointmentsArgs<ExtArgs>
    cancelledAppointments?: boolean | User$cancelledAppointmentsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    conversationsAsUser1?: boolean | User$conversationsAsUser1Args<ExtArgs>
    conversationsAsUser2?: boolean | User$conversationsAsUser2Args<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    reviewLikes?: boolean | User$reviewLikesArgs<ExtArgs>
    feedbackSubmitted?: boolean | User$feedbackSubmittedArgs<ExtArgs>
    feedbackResponses?: boolean | User$feedbackResponsesArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    providerStatusChanges?: boolean | User$providerStatusChangesArgs<ExtArgs>
    verifiedDocuments?: boolean | User$verifiedDocumentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    suspendedBy?: boolean | User$suspendedByArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    suspendedBy?: boolean | User$suspendedByArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      suspendedBy: Prisma.$UserPayload<ExtArgs> | null
      suspendedUsers: Prisma.$UserPayload<ExtArgs>[]
      provider: Prisma.$ProviderPayload<ExtArgs> | null
      verifiedProviders: Prisma.$ProviderPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      cancelledAppointments: Prisma.$AppointmentPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      conversationsAsUser1: Prisma.$ConversationPayload<ExtArgs>[]
      conversationsAsUser2: Prisma.$ConversationPayload<ExtArgs>[]
      sentMessages: Prisma.$MessagePayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      reviewLikes: Prisma.$ReviewLikePayload<ExtArgs>[]
      feedbackSubmitted: Prisma.$SystemFeedbackPayload<ExtArgs>[]
      feedbackResponses: Prisma.$SystemFeedbackPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      providerStatusChanges: Prisma.$ProviderStatusHistoryPayload<ExtArgs>[]
      verifiedDocuments: Prisma.$DocumentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      role: $Enums.UserRole
      status: $Enums.UserStatus
      emailVerified: boolean
      image: string | null
      createdAt: Date
      updatedAt: Date
      suspendedAt: Date | null
      suspendReason: string | null
      suspendedById: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    suspendedBy<T extends User$suspendedByArgs<ExtArgs> = {}>(args?: Subset<T, User$suspendedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    suspendedUsers<T extends User$suspendedUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$suspendedUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    provider<T extends User$providerArgs<ExtArgs> = {}>(args?: Subset<T, User$providerArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    verifiedProviders<T extends User$verifiedProvidersArgs<ExtArgs> = {}>(args?: Subset<T, User$verifiedProvidersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appointments<T extends User$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cancelledAppointments<T extends User$cancelledAppointmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$cancelledAppointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversationsAsUser1<T extends User$conversationsAsUser1Args<ExtArgs> = {}>(args?: Subset<T, User$conversationsAsUser1Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversationsAsUser2<T extends User$conversationsAsUser2Args<ExtArgs> = {}>(args?: Subset<T, User$conversationsAsUser2Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentMessages<T extends User$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends User$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviewLikes<T extends User$reviewLikesArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewLikesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feedbackSubmitted<T extends User$feedbackSubmittedArgs<ExtArgs> = {}>(args?: Subset<T, User$feedbackSubmittedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feedbackResponses<T extends User$feedbackResponsesArgs<ExtArgs> = {}>(args?: Subset<T, User$feedbackResponsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    providerStatusChanges<T extends User$providerStatusChangesArgs<ExtArgs> = {}>(args?: Subset<T, User$providerStatusChangesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderStatusHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    verifiedDocuments<T extends User$verifiedDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, User$verifiedDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly image: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly suspendedAt: FieldRef<"User", 'DateTime'>
    readonly suspendReason: FieldRef<"User", 'String'>
    readonly suspendedById: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.suspendedBy
   */
  export type User$suspendedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.suspendedUsers
   */
  export type User$suspendedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.provider
   */
  export type User$providerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    where?: ProviderWhereInput
  }

  /**
   * User.verifiedProviders
   */
  export type User$verifiedProvidersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    where?: ProviderWhereInput
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    cursor?: ProviderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProviderScalarFieldEnum | ProviderScalarFieldEnum[]
  }

  /**
   * User.appointments
   */
  export type User$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * User.cancelledAppointments
   */
  export type User$cancelledAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.conversationsAsUser1
   */
  export type User$conversationsAsUser1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * User.conversationsAsUser2
   */
  export type User$conversationsAsUser2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * User.sentMessages
   */
  export type User$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.reviews
   */
  export type User$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User.reviewLikes
   */
  export type User$reviewLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewLike
     */
    select?: ReviewLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewLike
     */
    omit?: ReviewLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewLikeInclude<ExtArgs> | null
    where?: ReviewLikeWhereInput
    orderBy?: ReviewLikeOrderByWithRelationInput | ReviewLikeOrderByWithRelationInput[]
    cursor?: ReviewLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewLikeScalarFieldEnum | ReviewLikeScalarFieldEnum[]
  }

  /**
   * User.feedbackSubmitted
   */
  export type User$feedbackSubmittedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemFeedback
     */
    select?: SystemFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemFeedback
     */
    omit?: SystemFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemFeedbackInclude<ExtArgs> | null
    where?: SystemFeedbackWhereInput
    orderBy?: SystemFeedbackOrderByWithRelationInput | SystemFeedbackOrderByWithRelationInput[]
    cursor?: SystemFeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SystemFeedbackScalarFieldEnum | SystemFeedbackScalarFieldEnum[]
  }

  /**
   * User.feedbackResponses
   */
  export type User$feedbackResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemFeedback
     */
    select?: SystemFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemFeedback
     */
    omit?: SystemFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemFeedbackInclude<ExtArgs> | null
    where?: SystemFeedbackWhereInput
    orderBy?: SystemFeedbackOrderByWithRelationInput | SystemFeedbackOrderByWithRelationInput[]
    cursor?: SystemFeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SystemFeedbackScalarFieldEnum | SystemFeedbackScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.providerStatusChanges
   */
  export type User$providerStatusChangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderStatusHistory
     */
    select?: ProviderStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderStatusHistory
     */
    omit?: ProviderStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderStatusHistoryInclude<ExtArgs> | null
    where?: ProviderStatusHistoryWhereInput
    orderBy?: ProviderStatusHistoryOrderByWithRelationInput | ProviderStatusHistoryOrderByWithRelationInput[]
    cursor?: ProviderStatusHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProviderStatusHistoryScalarFieldEnum | ProviderStatusHistoryScalarFieldEnum[]
  }

  /**
   * User.verifiedDocuments
   */
  export type User$verifiedDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    expiresAt: number
    token: number
    createdAt: number
    updatedAt: number
    ipAddress: number
    userAgent: number
    userId: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    expiresAt: Date
    token: string
    createdAt: Date
    updatedAt: Date
    ipAddress: string | null
    userAgent: string | null
    userId: string
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "expiresAt" | "token" | "createdAt" | "updatedAt" | "ipAddress" | "userAgent" | "userId", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expiresAt: Date
      token: string
      createdAt: Date
      updatedAt: Date
      ipAddress: string | null
      userAgent: string | null
      userId: string
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly token: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    accountId: number
    providerId: number
    userId: number
    accessToken: number
    refreshToken: number
    idToken: number
    accessTokenExpiresAt: number
    refreshTokenExpiresAt: number
    scope: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "providerId" | "userId" | "accessToken" | "refreshToken" | "idToken" | "accessTokenExpiresAt" | "refreshTokenExpiresAt" | "scope" | "password" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      providerId: string
      userId: string
      accessToken: string | null
      refreshToken: string | null
      idToken: string | null
      accessTokenExpiresAt: Date | null
      refreshTokenExpiresAt: Date | null
      scope: string | null
      password: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly accountId: FieldRef<"Account", 'String'>
    readonly providerId: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly idToken: FieldRef<"Account", 'String'>
    readonly accessTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly refreshTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly password: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithAggregationInput | VerificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "value" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["verification"]>

  export type $VerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type VerificationGetPayload<S extends boolean | null | undefined | VerificationDefaultArgs> = $Result.GetResult<Prisma.$VerificationPayload, S>

  type VerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface VerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verification'], meta: { name: 'Verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationFindManyArgs>(args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends VerificationCreateArgs>(args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCreateManyArgs>(args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verifications and returns the data saved in the database.
     * @param {VerificationCreateManyAndReturnArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends VerificationDeleteArgs>(args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationUpdateArgs>(args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationDeleteManyArgs>(args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationUpdateManyArgs>(args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications and returns the data updated in the database.
     * @param {VerificationUpdateManyAndReturnArgs} args - Arguments to update many Verifications.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verification model
   */
  readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verification model
   */
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", 'String'>
    readonly identifier: FieldRef<"Verification", 'String'>
    readonly value: FieldRef<"Verification", 'String'>
    readonly expiresAt: FieldRef<"Verification", 'DateTime'>
    readonly createdAt: FieldRef<"Verification", 'DateTime'>
    readonly updatedAt: FieldRef<"Verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification create
   */
  export type VerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
  }

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification createManyAndReturn
   */
  export type VerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification updateManyAndReturn
   */
  export type VerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
  }

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to delete.
     */
    limit?: number
  }

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type CategorySumAggregateOutputType = {
    sortOrder: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    icon: string | null
    color: string | null
    isActive: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    icon: string | null
    color: string | null
    isActive: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    icon: number
    color: number
    isActive: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    sortOrder?: true
  }

  export type CategorySumAggregateInputType = {
    sortOrder?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    icon?: true
    color?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    icon?: true
    color?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    icon?: true
    color?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    icon: string | null
    color: string
    isActive: boolean
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    providers?: boolean | Category$providersArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "icon" | "color" | "isActive" | "sortOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    providers?: boolean | Category$providersArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      providers: Prisma.$ProviderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      icon: string | null
      color: string
      isActive: boolean
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    providers<T extends Category$providersArgs<ExtArgs> = {}>(args?: Subset<T, Category$providersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly slug: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
    readonly icon: FieldRef<"Category", 'String'>
    readonly color: FieldRef<"Category", 'String'>
    readonly isActive: FieldRef<"Category", 'Boolean'>
    readonly sortOrder: FieldRef<"Category", 'Int'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.providers
   */
  export type Category$providersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    where?: ProviderWhereInput
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    cursor?: ProviderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProviderScalarFieldEnum | ProviderScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Provider
   */

  export type AggregateProvider = {
    _count: ProviderCountAggregateOutputType | null
    _avg: ProviderAvgAggregateOutputType | null
    _sum: ProviderSumAggregateOutputType | null
    _min: ProviderMinAggregateOutputType | null
    _max: ProviderMaxAggregateOutputType | null
  }

  export type ProviderAvgAggregateOutputType = {
    latitude: Decimal | null
    longitude: Decimal | null
    slotDuration: number | null
  }

  export type ProviderSumAggregateOutputType = {
    latitude: Decimal | null
    longitude: Decimal | null
    slotDuration: number | null
  }

  export type ProviderMinAggregateOutputType = {
    id: string | null
    userId: string | null
    categoryId: string | null
    verifiedBy: string | null
    healthcareName: string | null
    description: string | null
    phoneNumber: string | null
    email: string | null
    coverPhoto: string | null
    status: $Enums.ProviderStatus | null
    address: string | null
    city: string | null
    province: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    slotDuration: number | null
    verifiedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProviderMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    categoryId: string | null
    verifiedBy: string | null
    healthcareName: string | null
    description: string | null
    phoneNumber: string | null
    email: string | null
    coverPhoto: string | null
    status: $Enums.ProviderStatus | null
    address: string | null
    city: string | null
    province: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    slotDuration: number | null
    verifiedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProviderCountAggregateOutputType = {
    id: number
    userId: number
    categoryId: number
    verifiedBy: number
    healthcareName: number
    description: number
    phoneNumber: number
    email: number
    coverPhoto: number
    status: number
    address: number
    city: number
    province: number
    latitude: number
    longitude: number
    slotDuration: number
    verifiedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProviderAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    slotDuration?: true
  }

  export type ProviderSumAggregateInputType = {
    latitude?: true
    longitude?: true
    slotDuration?: true
  }

  export type ProviderMinAggregateInputType = {
    id?: true
    userId?: true
    categoryId?: true
    verifiedBy?: true
    healthcareName?: true
    description?: true
    phoneNumber?: true
    email?: true
    coverPhoto?: true
    status?: true
    address?: true
    city?: true
    province?: true
    latitude?: true
    longitude?: true
    slotDuration?: true
    verifiedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProviderMaxAggregateInputType = {
    id?: true
    userId?: true
    categoryId?: true
    verifiedBy?: true
    healthcareName?: true
    description?: true
    phoneNumber?: true
    email?: true
    coverPhoto?: true
    status?: true
    address?: true
    city?: true
    province?: true
    latitude?: true
    longitude?: true
    slotDuration?: true
    verifiedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProviderCountAggregateInputType = {
    id?: true
    userId?: true
    categoryId?: true
    verifiedBy?: true
    healthcareName?: true
    description?: true
    phoneNumber?: true
    email?: true
    coverPhoto?: true
    status?: true
    address?: true
    city?: true
    province?: true
    latitude?: true
    longitude?: true
    slotDuration?: true
    verifiedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProviderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Provider to aggregate.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Providers
    **/
    _count?: true | ProviderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProviderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProviderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProviderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProviderMaxAggregateInputType
  }

  export type GetProviderAggregateType<T extends ProviderAggregateArgs> = {
        [P in keyof T & keyof AggregateProvider]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProvider[P]>
      : GetScalarType<T[P], AggregateProvider[P]>
  }




  export type ProviderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProviderWhereInput
    orderBy?: ProviderOrderByWithAggregationInput | ProviderOrderByWithAggregationInput[]
    by: ProviderScalarFieldEnum[] | ProviderScalarFieldEnum
    having?: ProviderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProviderCountAggregateInputType | true
    _avg?: ProviderAvgAggregateInputType
    _sum?: ProviderSumAggregateInputType
    _min?: ProviderMinAggregateInputType
    _max?: ProviderMaxAggregateInputType
  }

  export type ProviderGroupByOutputType = {
    id: string
    userId: string
    categoryId: string | null
    verifiedBy: string | null
    healthcareName: string
    description: string | null
    phoneNumber: string | null
    email: string | null
    coverPhoto: string | null
    status: $Enums.ProviderStatus
    address: string
    city: string
    province: string
    latitude: Decimal | null
    longitude: Decimal | null
    slotDuration: number
    verifiedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ProviderCountAggregateOutputType | null
    _avg: ProviderAvgAggregateOutputType | null
    _sum: ProviderSumAggregateOutputType | null
    _min: ProviderMinAggregateOutputType | null
    _max: ProviderMaxAggregateOutputType | null
  }

  type GetProviderGroupByPayload<T extends ProviderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProviderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProviderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProviderGroupByOutputType[P]>
            : GetScalarType<T[P], ProviderGroupByOutputType[P]>
        }
      >
    >


  export type ProviderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    categoryId?: boolean
    verifiedBy?: boolean
    healthcareName?: boolean
    description?: boolean
    phoneNumber?: boolean
    email?: boolean
    coverPhoto?: boolean
    status?: boolean
    address?: boolean
    city?: boolean
    province?: boolean
    latitude?: boolean
    longitude?: boolean
    slotDuration?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    category?: boolean | Provider$categoryArgs<ExtArgs>
    verifier?: boolean | Provider$verifierArgs<ExtArgs>
    services?: boolean | Provider$servicesArgs<ExtArgs>
    operatingHours?: boolean | Provider$operatingHoursArgs<ExtArgs>
    appointments?: boolean | Provider$appointmentsArgs<ExtArgs>
    documents?: boolean | Provider$documentsArgs<ExtArgs>
    breakTimes?: boolean | Provider$breakTimesArgs<ExtArgs>
    notifications?: boolean | Provider$notificationsArgs<ExtArgs>
    reviews?: boolean | Provider$reviewsArgs<ExtArgs>
    statusHistory?: boolean | Provider$statusHistoryArgs<ExtArgs>
    _count?: boolean | ProviderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["provider"]>

  export type ProviderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    categoryId?: boolean
    verifiedBy?: boolean
    healthcareName?: boolean
    description?: boolean
    phoneNumber?: boolean
    email?: boolean
    coverPhoto?: boolean
    status?: boolean
    address?: boolean
    city?: boolean
    province?: boolean
    latitude?: boolean
    longitude?: boolean
    slotDuration?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    category?: boolean | Provider$categoryArgs<ExtArgs>
    verifier?: boolean | Provider$verifierArgs<ExtArgs>
  }, ExtArgs["result"]["provider"]>

  export type ProviderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    categoryId?: boolean
    verifiedBy?: boolean
    healthcareName?: boolean
    description?: boolean
    phoneNumber?: boolean
    email?: boolean
    coverPhoto?: boolean
    status?: boolean
    address?: boolean
    city?: boolean
    province?: boolean
    latitude?: boolean
    longitude?: boolean
    slotDuration?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    category?: boolean | Provider$categoryArgs<ExtArgs>
    verifier?: boolean | Provider$verifierArgs<ExtArgs>
  }, ExtArgs["result"]["provider"]>

  export type ProviderSelectScalar = {
    id?: boolean
    userId?: boolean
    categoryId?: boolean
    verifiedBy?: boolean
    healthcareName?: boolean
    description?: boolean
    phoneNumber?: boolean
    email?: boolean
    coverPhoto?: boolean
    status?: boolean
    address?: boolean
    city?: boolean
    province?: boolean
    latitude?: boolean
    longitude?: boolean
    slotDuration?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProviderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "categoryId" | "verifiedBy" | "healthcareName" | "description" | "phoneNumber" | "email" | "coverPhoto" | "status" | "address" | "city" | "province" | "latitude" | "longitude" | "slotDuration" | "verifiedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["provider"]>
  export type ProviderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    category?: boolean | Provider$categoryArgs<ExtArgs>
    verifier?: boolean | Provider$verifierArgs<ExtArgs>
    services?: boolean | Provider$servicesArgs<ExtArgs>
    operatingHours?: boolean | Provider$operatingHoursArgs<ExtArgs>
    appointments?: boolean | Provider$appointmentsArgs<ExtArgs>
    documents?: boolean | Provider$documentsArgs<ExtArgs>
    breakTimes?: boolean | Provider$breakTimesArgs<ExtArgs>
    notifications?: boolean | Provider$notificationsArgs<ExtArgs>
    reviews?: boolean | Provider$reviewsArgs<ExtArgs>
    statusHistory?: boolean | Provider$statusHistoryArgs<ExtArgs>
    _count?: boolean | ProviderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProviderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    category?: boolean | Provider$categoryArgs<ExtArgs>
    verifier?: boolean | Provider$verifierArgs<ExtArgs>
  }
  export type ProviderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    category?: boolean | Provider$categoryArgs<ExtArgs>
    verifier?: boolean | Provider$verifierArgs<ExtArgs>
  }

  export type $ProviderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Provider"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      category: Prisma.$CategoryPayload<ExtArgs> | null
      verifier: Prisma.$UserPayload<ExtArgs> | null
      services: Prisma.$ServicePayload<ExtArgs>[]
      operatingHours: Prisma.$OperatingHourPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      breakTimes: Prisma.$BreakTimePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      statusHistory: Prisma.$ProviderStatusHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      categoryId: string | null
      verifiedBy: string | null
      healthcareName: string
      description: string | null
      phoneNumber: string | null
      email: string | null
      coverPhoto: string | null
      status: $Enums.ProviderStatus
      address: string
      city: string
      province: string
      latitude: Prisma.Decimal | null
      longitude: Prisma.Decimal | null
      slotDuration: number
      verifiedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["provider"]>
    composites: {}
  }

  type ProviderGetPayload<S extends boolean | null | undefined | ProviderDefaultArgs> = $Result.GetResult<Prisma.$ProviderPayload, S>

  type ProviderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProviderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProviderCountAggregateInputType | true
    }

  export interface ProviderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Provider'], meta: { name: 'Provider' } }
    /**
     * Find zero or one Provider that matches the filter.
     * @param {ProviderFindUniqueArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProviderFindUniqueArgs>(args: SelectSubset<T, ProviderFindUniqueArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Provider that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProviderFindUniqueOrThrowArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProviderFindUniqueOrThrowArgs>(args: SelectSubset<T, ProviderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Provider that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderFindFirstArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProviderFindFirstArgs>(args?: SelectSubset<T, ProviderFindFirstArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Provider that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderFindFirstOrThrowArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProviderFindFirstOrThrowArgs>(args?: SelectSubset<T, ProviderFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Providers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Providers
     * const providers = await prisma.provider.findMany()
     * 
     * // Get first 10 Providers
     * const providers = await prisma.provider.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const providerWithIdOnly = await prisma.provider.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProviderFindManyArgs>(args?: SelectSubset<T, ProviderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Provider.
     * @param {ProviderCreateArgs} args - Arguments to create a Provider.
     * @example
     * // Create one Provider
     * const Provider = await prisma.provider.create({
     *   data: {
     *     // ... data to create a Provider
     *   }
     * })
     * 
     */
    create<T extends ProviderCreateArgs>(args: SelectSubset<T, ProviderCreateArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Providers.
     * @param {ProviderCreateManyArgs} args - Arguments to create many Providers.
     * @example
     * // Create many Providers
     * const provider = await prisma.provider.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProviderCreateManyArgs>(args?: SelectSubset<T, ProviderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Providers and returns the data saved in the database.
     * @param {ProviderCreateManyAndReturnArgs} args - Arguments to create many Providers.
     * @example
     * // Create many Providers
     * const provider = await prisma.provider.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Providers and only return the `id`
     * const providerWithIdOnly = await prisma.provider.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProviderCreateManyAndReturnArgs>(args?: SelectSubset<T, ProviderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Provider.
     * @param {ProviderDeleteArgs} args - Arguments to delete one Provider.
     * @example
     * // Delete one Provider
     * const Provider = await prisma.provider.delete({
     *   where: {
     *     // ... filter to delete one Provider
     *   }
     * })
     * 
     */
    delete<T extends ProviderDeleteArgs>(args: SelectSubset<T, ProviderDeleteArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Provider.
     * @param {ProviderUpdateArgs} args - Arguments to update one Provider.
     * @example
     * // Update one Provider
     * const provider = await prisma.provider.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProviderUpdateArgs>(args: SelectSubset<T, ProviderUpdateArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Providers.
     * @param {ProviderDeleteManyArgs} args - Arguments to filter Providers to delete.
     * @example
     * // Delete a few Providers
     * const { count } = await prisma.provider.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProviderDeleteManyArgs>(args?: SelectSubset<T, ProviderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Providers
     * const provider = await prisma.provider.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProviderUpdateManyArgs>(args: SelectSubset<T, ProviderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Providers and returns the data updated in the database.
     * @param {ProviderUpdateManyAndReturnArgs} args - Arguments to update many Providers.
     * @example
     * // Update many Providers
     * const provider = await prisma.provider.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Providers and only return the `id`
     * const providerWithIdOnly = await prisma.provider.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProviderUpdateManyAndReturnArgs>(args: SelectSubset<T, ProviderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Provider.
     * @param {ProviderUpsertArgs} args - Arguments to update or create a Provider.
     * @example
     * // Update or create a Provider
     * const provider = await prisma.provider.upsert({
     *   create: {
     *     // ... data to create a Provider
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Provider we want to update
     *   }
     * })
     */
    upsert<T extends ProviderUpsertArgs>(args: SelectSubset<T, ProviderUpsertArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderCountArgs} args - Arguments to filter Providers to count.
     * @example
     * // Count the number of Providers
     * const count = await prisma.provider.count({
     *   where: {
     *     // ... the filter for the Providers we want to count
     *   }
     * })
    **/
    count<T extends ProviderCountArgs>(
      args?: Subset<T, ProviderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProviderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Provider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProviderAggregateArgs>(args: Subset<T, ProviderAggregateArgs>): Prisma.PrismaPromise<GetProviderAggregateType<T>>

    /**
     * Group by Provider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProviderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProviderGroupByArgs['orderBy'] }
        : { orderBy?: ProviderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProviderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProviderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Provider model
   */
  readonly fields: ProviderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Provider.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProviderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends Provider$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Provider$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    verifier<T extends Provider$verifierArgs<ExtArgs> = {}>(args?: Subset<T, Provider$verifierArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    services<T extends Provider$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Provider$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    operatingHours<T extends Provider$operatingHoursArgs<ExtArgs> = {}>(args?: Subset<T, Provider$operatingHoursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperatingHourPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appointments<T extends Provider$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Provider$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends Provider$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Provider$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    breakTimes<T extends Provider$breakTimesArgs<ExtArgs> = {}>(args?: Subset<T, Provider$breakTimesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreakTimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Provider$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Provider$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Provider$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Provider$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    statusHistory<T extends Provider$statusHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Provider$statusHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderStatusHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Provider model
   */
  interface ProviderFieldRefs {
    readonly id: FieldRef<"Provider", 'String'>
    readonly userId: FieldRef<"Provider", 'String'>
    readonly categoryId: FieldRef<"Provider", 'String'>
    readonly verifiedBy: FieldRef<"Provider", 'String'>
    readonly healthcareName: FieldRef<"Provider", 'String'>
    readonly description: FieldRef<"Provider", 'String'>
    readonly phoneNumber: FieldRef<"Provider", 'String'>
    readonly email: FieldRef<"Provider", 'String'>
    readonly coverPhoto: FieldRef<"Provider", 'String'>
    readonly status: FieldRef<"Provider", 'ProviderStatus'>
    readonly address: FieldRef<"Provider", 'String'>
    readonly city: FieldRef<"Provider", 'String'>
    readonly province: FieldRef<"Provider", 'String'>
    readonly latitude: FieldRef<"Provider", 'Decimal'>
    readonly longitude: FieldRef<"Provider", 'Decimal'>
    readonly slotDuration: FieldRef<"Provider", 'Int'>
    readonly verifiedAt: FieldRef<"Provider", 'DateTime'>
    readonly createdAt: FieldRef<"Provider", 'DateTime'>
    readonly updatedAt: FieldRef<"Provider", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Provider findUnique
   */
  export type ProviderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where: ProviderWhereUniqueInput
  }

  /**
   * Provider findUniqueOrThrow
   */
  export type ProviderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where: ProviderWhereUniqueInput
  }

  /**
   * Provider findFirst
   */
  export type ProviderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Providers.
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Providers.
     */
    distinct?: ProviderScalarFieldEnum | ProviderScalarFieldEnum[]
  }

  /**
   * Provider findFirstOrThrow
   */
  export type ProviderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Providers.
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Providers.
     */
    distinct?: ProviderScalarFieldEnum | ProviderScalarFieldEnum[]
  }

  /**
   * Provider findMany
   */
  export type ProviderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Providers to fetch.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Providers.
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    distinct?: ProviderScalarFieldEnum | ProviderScalarFieldEnum[]
  }

  /**
   * Provider create
   */
  export type ProviderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * The data needed to create a Provider.
     */
    data: XOR<ProviderCreateInput, ProviderUncheckedCreateInput>
  }

  /**
   * Provider createMany
   */
  export type ProviderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Providers.
     */
    data: ProviderCreateManyInput | ProviderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Provider createManyAndReturn
   */
  export type ProviderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * The data used to create many Providers.
     */
    data: ProviderCreateManyInput | ProviderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Provider update
   */
  export type ProviderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * The data needed to update a Provider.
     */
    data: XOR<ProviderUpdateInput, ProviderUncheckedUpdateInput>
    /**
     * Choose, which Provider to update.
     */
    where: ProviderWhereUniqueInput
  }

  /**
   * Provider updateMany
   */
  export type ProviderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Providers.
     */
    data: XOR<ProviderUpdateManyMutationInput, ProviderUncheckedUpdateManyInput>
    /**
     * Filter which Providers to update
     */
    where?: ProviderWhereInput
    /**
     * Limit how many Providers to update.
     */
    limit?: number
  }

  /**
   * Provider updateManyAndReturn
   */
  export type ProviderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * The data used to update Providers.
     */
    data: XOR<ProviderUpdateManyMutationInput, ProviderUncheckedUpdateManyInput>
    /**
     * Filter which Providers to update
     */
    where?: ProviderWhereInput
    /**
     * Limit how many Providers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Provider upsert
   */
  export type ProviderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * The filter to search for the Provider to update in case it exists.
     */
    where: ProviderWhereUniqueInput
    /**
     * In case the Provider found by the `where` argument doesn't exist, create a new Provider with this data.
     */
    create: XOR<ProviderCreateInput, ProviderUncheckedCreateInput>
    /**
     * In case the Provider was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProviderUpdateInput, ProviderUncheckedUpdateInput>
  }

  /**
   * Provider delete
   */
  export type ProviderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter which Provider to delete.
     */
    where: ProviderWhereUniqueInput
  }

  /**
   * Provider deleteMany
   */
  export type ProviderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Providers to delete
     */
    where?: ProviderWhereInput
    /**
     * Limit how many Providers to delete.
     */
    limit?: number
  }

  /**
   * Provider.category
   */
  export type Provider$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Provider.verifier
   */
  export type Provider$verifierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Provider.services
   */
  export type Provider$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Provider.operatingHours
   */
  export type Provider$operatingHoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatingHour
     */
    select?: OperatingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperatingHour
     */
    omit?: OperatingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatingHourInclude<ExtArgs> | null
    where?: OperatingHourWhereInput
    orderBy?: OperatingHourOrderByWithRelationInput | OperatingHourOrderByWithRelationInput[]
    cursor?: OperatingHourWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OperatingHourScalarFieldEnum | OperatingHourScalarFieldEnum[]
  }

  /**
   * Provider.appointments
   */
  export type Provider$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Provider.documents
   */
  export type Provider$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Provider.breakTimes
   */
  export type Provider$breakTimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakTime
     */
    select?: BreakTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreakTime
     */
    omit?: BreakTimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakTimeInclude<ExtArgs> | null
    where?: BreakTimeWhereInput
    orderBy?: BreakTimeOrderByWithRelationInput | BreakTimeOrderByWithRelationInput[]
    cursor?: BreakTimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BreakTimeScalarFieldEnum | BreakTimeScalarFieldEnum[]
  }

  /**
   * Provider.notifications
   */
  export type Provider$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Provider.reviews
   */
  export type Provider$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Provider.statusHistory
   */
  export type Provider$statusHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderStatusHistory
     */
    select?: ProviderStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderStatusHistory
     */
    omit?: ProviderStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderStatusHistoryInclude<ExtArgs> | null
    where?: ProviderStatusHistoryWhereInput
    orderBy?: ProviderStatusHistoryOrderByWithRelationInput | ProviderStatusHistoryOrderByWithRelationInput[]
    cursor?: ProviderStatusHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProviderStatusHistoryScalarFieldEnum | ProviderStatusHistoryScalarFieldEnum[]
  }

  /**
   * Provider without action
   */
  export type ProviderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    fixedPrice: number | null
    priceMin: number | null
    priceMax: number | null
  }

  export type ServiceSumAggregateOutputType = {
    fixedPrice: number | null
    priceMin: number | null
    priceMax: number | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    providerId: string | null
    name: string | null
    description: string | null
    type: $Enums.ServiceType | null
    pricingModel: $Enums.PricingModel | null
    fixedPrice: number | null
    priceMin: number | null
    priceMax: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    providerId: string | null
    name: string | null
    description: string | null
    type: $Enums.ServiceType | null
    pricingModel: $Enums.PricingModel | null
    fixedPrice: number | null
    priceMin: number | null
    priceMax: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    providerId: number
    name: number
    description: number
    type: number
    pricingModel: number
    fixedPrice: number
    priceMin: number
    priceMax: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    fixedPrice?: true
    priceMin?: true
    priceMax?: true
  }

  export type ServiceSumAggregateInputType = {
    fixedPrice?: true
    priceMin?: true
    priceMax?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    providerId?: true
    name?: true
    description?: true
    type?: true
    pricingModel?: true
    fixedPrice?: true
    priceMin?: true
    priceMax?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    providerId?: true
    name?: true
    description?: true
    type?: true
    pricingModel?: true
    fixedPrice?: true
    priceMin?: true
    priceMax?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    providerId?: true
    name?: true
    description?: true
    type?: true
    pricingModel?: true
    fixedPrice?: true
    priceMin?: true
    priceMax?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    providerId: string
    name: string
    description: string | null
    type: $Enums.ServiceType
    pricingModel: $Enums.PricingModel
    fixedPrice: number
    priceMin: number
    priceMax: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    pricingModel?: boolean
    fixedPrice?: boolean
    priceMin?: boolean
    priceMax?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    appointments?: boolean | Service$appointmentsArgs<ExtArgs>
    includedServices?: boolean | Service$includedServicesArgs<ExtArgs>
    partOfPackages?: boolean | Service$partOfPackagesArgs<ExtArgs>
    acceptedInsurances?: boolean | Service$acceptedInsurancesArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    pricingModel?: boolean
    fixedPrice?: boolean
    priceMin?: boolean
    priceMax?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    pricingModel?: boolean
    fixedPrice?: boolean
    priceMin?: boolean
    priceMax?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    providerId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    pricingModel?: boolean
    fixedPrice?: boolean
    priceMin?: boolean
    priceMax?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "providerId" | "name" | "description" | "type" | "pricingModel" | "fixedPrice" | "priceMin" | "priceMax" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["service"]>
  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    appointments?: boolean | Service$appointmentsArgs<ExtArgs>
    includedServices?: boolean | Service$includedServicesArgs<ExtArgs>
    partOfPackages?: boolean | Service$partOfPackagesArgs<ExtArgs>
    acceptedInsurances?: boolean | Service$acceptedInsurancesArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      provider: Prisma.$ProviderPayload<ExtArgs>
      appointments: Prisma.$AppointmentServicePayload<ExtArgs>[]
      includedServices: Prisma.$ServicePackagePayload<ExtArgs>[]
      partOfPackages: Prisma.$ServicePackagePayload<ExtArgs>[]
      acceptedInsurances: Prisma.$ServiceInsurancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      providerId: string
      name: string
      description: string | null
      type: $Enums.ServiceType
      pricingModel: $Enums.PricingModel
      fixedPrice: number
      priceMin: number
      priceMax: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services and returns the data updated in the database.
     * @param {ServiceUpdateManyAndReturnArgs} args - Arguments to update many Services.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    provider<T extends ProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProviderDefaultArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    appointments<T extends Service$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Service$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    includedServices<T extends Service$includedServicesArgs<ExtArgs> = {}>(args?: Subset<T, Service$includedServicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePackagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    partOfPackages<T extends Service$partOfPackagesArgs<ExtArgs> = {}>(args?: Subset<T, Service$partOfPackagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePackagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    acceptedInsurances<T extends Service$acceptedInsurancesArgs<ExtArgs> = {}>(args?: Subset<T, Service$acceptedInsurancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceInsurancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly providerId: FieldRef<"Service", 'String'>
    readonly name: FieldRef<"Service", 'String'>
    readonly description: FieldRef<"Service", 'String'>
    readonly type: FieldRef<"Service", 'ServiceType'>
    readonly pricingModel: FieldRef<"Service", 'PricingModel'>
    readonly fixedPrice: FieldRef<"Service", 'Int'>
    readonly priceMin: FieldRef<"Service", 'Int'>
    readonly priceMax: FieldRef<"Service", 'Int'>
    readonly isActive: FieldRef<"Service", 'Boolean'>
    readonly createdAt: FieldRef<"Service", 'DateTime'>
    readonly updatedAt: FieldRef<"Service", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service updateManyAndReturn
   */
  export type ServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to delete.
     */
    limit?: number
  }

  /**
   * Service.appointments
   */
  export type Service$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentService
     */
    select?: AppointmentServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppointmentService
     */
    omit?: AppointmentServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentServiceInclude<ExtArgs> | null
    where?: AppointmentServiceWhereInput
    orderBy?: AppointmentServiceOrderByWithRelationInput | AppointmentServiceOrderByWithRelationInput[]
    cursor?: AppointmentServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentServiceScalarFieldEnum | AppointmentServiceScalarFieldEnum[]
  }

  /**
   * Service.includedServices
   */
  export type Service$includedServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePackage
     */
    select?: ServicePackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePackage
     */
    omit?: ServicePackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePackageInclude<ExtArgs> | null
    where?: ServicePackageWhereInput
    orderBy?: ServicePackageOrderByWithRelationInput | ServicePackageOrderByWithRelationInput[]
    cursor?: ServicePackageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicePackageScalarFieldEnum | ServicePackageScalarFieldEnum[]
  }

  /**
   * Service.partOfPackages
   */
  export type Service$partOfPackagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePackage
     */
    select?: ServicePackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePackage
     */
    omit?: ServicePackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePackageInclude<ExtArgs> | null
    where?: ServicePackageWhereInput
    orderBy?: ServicePackageOrderByWithRelationInput | ServicePackageOrderByWithRelationInput[]
    cursor?: ServicePackageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicePackageScalarFieldEnum | ServicePackageScalarFieldEnum[]
  }

  /**
   * Service.acceptedInsurances
   */
  export type Service$acceptedInsurancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInsurance
     */
    select?: ServiceInsuranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInsurance
     */
    omit?: ServiceInsuranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInsuranceInclude<ExtArgs> | null
    where?: ServiceInsuranceWhereInput
    orderBy?: ServiceInsuranceOrderByWithRelationInput | ServiceInsuranceOrderByWithRelationInput[]
    cursor?: ServiceInsuranceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceInsuranceScalarFieldEnum | ServiceInsuranceScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model ServicePackage
   */

  export type AggregateServicePackage = {
    _count: ServicePackageCountAggregateOutputType | null
    _min: ServicePackageMinAggregateOutputType | null
    _max: ServicePackageMaxAggregateOutputType | null
  }

  export type ServicePackageMinAggregateOutputType = {
    parentPackageId: string | null
    childServiceId: string | null
    createdAt: Date | null
  }

  export type ServicePackageMaxAggregateOutputType = {
    parentPackageId: string | null
    childServiceId: string | null
    createdAt: Date | null
  }

  export type ServicePackageCountAggregateOutputType = {
    parentPackageId: number
    childServiceId: number
    createdAt: number
    _all: number
  }


  export type ServicePackageMinAggregateInputType = {
    parentPackageId?: true
    childServiceId?: true
    createdAt?: true
  }

  export type ServicePackageMaxAggregateInputType = {
    parentPackageId?: true
    childServiceId?: true
    createdAt?: true
  }

  export type ServicePackageCountAggregateInputType = {
    parentPackageId?: true
    childServiceId?: true
    createdAt?: true
    _all?: true
  }

  export type ServicePackageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServicePackage to aggregate.
     */
    where?: ServicePackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicePackages to fetch.
     */
    orderBy?: ServicePackageOrderByWithRelationInput | ServicePackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServicePackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicePackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicePackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServicePackages
    **/
    _count?: true | ServicePackageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicePackageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicePackageMaxAggregateInputType
  }

  export type GetServicePackageAggregateType<T extends ServicePackageAggregateArgs> = {
        [P in keyof T & keyof AggregateServicePackage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicePackage[P]>
      : GetScalarType<T[P], AggregateServicePackage[P]>
  }




  export type ServicePackageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicePackageWhereInput
    orderBy?: ServicePackageOrderByWithAggregationInput | ServicePackageOrderByWithAggregationInput[]
    by: ServicePackageScalarFieldEnum[] | ServicePackageScalarFieldEnum
    having?: ServicePackageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicePackageCountAggregateInputType | true
    _min?: ServicePackageMinAggregateInputType
    _max?: ServicePackageMaxAggregateInputType
  }

  export type ServicePackageGroupByOutputType = {
    parentPackageId: string
    childServiceId: string
    createdAt: Date
    _count: ServicePackageCountAggregateOutputType | null
    _min: ServicePackageMinAggregateOutputType | null
    _max: ServicePackageMaxAggregateOutputType | null
  }

  type GetServicePackageGroupByPayload<T extends ServicePackageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServicePackageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicePackageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicePackageGroupByOutputType[P]>
            : GetScalarType<T[P], ServicePackageGroupByOutputType[P]>
        }
      >
    >


  export type ServicePackageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    parentPackageId?: boolean
    childServiceId?: boolean
    createdAt?: boolean
    parentPackage?: boolean | ServiceDefaultArgs<ExtArgs>
    childService?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicePackage"]>

  export type ServicePackageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    parentPackageId?: boolean
    childServiceId?: boolean
    createdAt?: boolean
    parentPackage?: boolean | ServiceDefaultArgs<ExtArgs>
    childService?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicePackage"]>

  export type ServicePackageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    parentPackageId?: boolean
    childServiceId?: boolean
    createdAt?: boolean
    parentPackage?: boolean | ServiceDefaultArgs<ExtArgs>
    childService?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicePackage"]>

  export type ServicePackageSelectScalar = {
    parentPackageId?: boolean
    childServiceId?: boolean
    createdAt?: boolean
  }

  export type ServicePackageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"parentPackageId" | "childServiceId" | "createdAt", ExtArgs["result"]["servicePackage"]>
  export type ServicePackageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parentPackage?: boolean | ServiceDefaultArgs<ExtArgs>
    childService?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type ServicePackageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parentPackage?: boolean | ServiceDefaultArgs<ExtArgs>
    childService?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type ServicePackageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parentPackage?: boolean | ServiceDefaultArgs<ExtArgs>
    childService?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $ServicePackagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServicePackage"
    objects: {
      parentPackage: Prisma.$ServicePayload<ExtArgs>
      childService: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      parentPackageId: string
      childServiceId: string
      createdAt: Date
    }, ExtArgs["result"]["servicePackage"]>
    composites: {}
  }

  type ServicePackageGetPayload<S extends boolean | null | undefined | ServicePackageDefaultArgs> = $Result.GetResult<Prisma.$ServicePackagePayload, S>

  type ServicePackageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServicePackageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServicePackageCountAggregateInputType | true
    }

  export interface ServicePackageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServicePackage'], meta: { name: 'ServicePackage' } }
    /**
     * Find zero or one ServicePackage that matches the filter.
     * @param {ServicePackageFindUniqueArgs} args - Arguments to find a ServicePackage
     * @example
     * // Get one ServicePackage
     * const servicePackage = await prisma.servicePackage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServicePackageFindUniqueArgs>(args: SelectSubset<T, ServicePackageFindUniqueArgs<ExtArgs>>): Prisma__ServicePackageClient<$Result.GetResult<Prisma.$ServicePackagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServicePackage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServicePackageFindUniqueOrThrowArgs} args - Arguments to find a ServicePackage
     * @example
     * // Get one ServicePackage
     * const servicePackage = await prisma.servicePackage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServicePackageFindUniqueOrThrowArgs>(args: SelectSubset<T, ServicePackageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServicePackageClient<$Result.GetResult<Prisma.$ServicePackagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServicePackage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePackageFindFirstArgs} args - Arguments to find a ServicePackage
     * @example
     * // Get one ServicePackage
     * const servicePackage = await prisma.servicePackage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServicePackageFindFirstArgs>(args?: SelectSubset<T, ServicePackageFindFirstArgs<ExtArgs>>): Prisma__ServicePackageClient<$Result.GetResult<Prisma.$ServicePackagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServicePackage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePackageFindFirstOrThrowArgs} args - Arguments to find a ServicePackage
     * @example
     * // Get one ServicePackage
     * const servicePackage = await prisma.servicePackage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServicePackageFindFirstOrThrowArgs>(args?: SelectSubset<T, ServicePackageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServicePackageClient<$Result.GetResult<Prisma.$ServicePackagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServicePackages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePackageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServicePackages
     * const servicePackages = await prisma.servicePackage.findMany()
     * 
     * // Get first 10 ServicePackages
     * const servicePackages = await prisma.servicePackage.findMany({ take: 10 })
     * 
     * // Only select the `parentPackageId`
     * const servicePackageWithParentPackageIdOnly = await prisma.servicePackage.findMany({ select: { parentPackageId: true } })
     * 
     */
    findMany<T extends ServicePackageFindManyArgs>(args?: SelectSubset<T, ServicePackageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePackagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServicePackage.
     * @param {ServicePackageCreateArgs} args - Arguments to create a ServicePackage.
     * @example
     * // Create one ServicePackage
     * const ServicePackage = await prisma.servicePackage.create({
     *   data: {
     *     // ... data to create a ServicePackage
     *   }
     * })
     * 
     */
    create<T extends ServicePackageCreateArgs>(args: SelectSubset<T, ServicePackageCreateArgs<ExtArgs>>): Prisma__ServicePackageClient<$Result.GetResult<Prisma.$ServicePackagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServicePackages.
     * @param {ServicePackageCreateManyArgs} args - Arguments to create many ServicePackages.
     * @example
     * // Create many ServicePackages
     * const servicePackage = await prisma.servicePackage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServicePackageCreateManyArgs>(args?: SelectSubset<T, ServicePackageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServicePackages and returns the data saved in the database.
     * @param {ServicePackageCreateManyAndReturnArgs} args - Arguments to create many ServicePackages.
     * @example
     * // Create many ServicePackages
     * const servicePackage = await prisma.servicePackage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServicePackages and only return the `parentPackageId`
     * const servicePackageWithParentPackageIdOnly = await prisma.servicePackage.createManyAndReturn({
     *   select: { parentPackageId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServicePackageCreateManyAndReturnArgs>(args?: SelectSubset<T, ServicePackageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePackagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServicePackage.
     * @param {ServicePackageDeleteArgs} args - Arguments to delete one ServicePackage.
     * @example
     * // Delete one ServicePackage
     * const ServicePackage = await prisma.servicePackage.delete({
     *   where: {
     *     // ... filter to delete one ServicePackage
     *   }
     * })
     * 
     */
    delete<T extends ServicePackageDeleteArgs>(args: SelectSubset<T, ServicePackageDeleteArgs<ExtArgs>>): Prisma__ServicePackageClient<$Result.GetResult<Prisma.$ServicePackagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServicePackage.
     * @param {ServicePackageUpdateArgs} args - Arguments to update one ServicePackage.
     * @example
     * // Update one ServicePackage
     * const servicePackage = await prisma.servicePackage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServicePackageUpdateArgs>(args: SelectSubset<T, ServicePackageUpdateArgs<ExtArgs>>): Prisma__ServicePackageClient<$Result.GetResult<Prisma.$ServicePackagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServicePackages.
     * @param {ServicePackageDeleteManyArgs} args - Arguments to filter ServicePackages to delete.
     * @example
     * // Delete a few ServicePackages
     * const { count } = await prisma.servicePackage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServicePackageDeleteManyArgs>(args?: SelectSubset<T, ServicePackageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServicePackages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePackageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServicePackages
     * const servicePackage = await prisma.servicePackage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServicePackageUpdateManyArgs>(args: SelectSubset<T, ServicePackageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServicePackages and returns the data updated in the database.
     * @param {ServicePackageUpdateManyAndReturnArgs} args - Arguments to update many ServicePackages.
     * @example
     * // Update many ServicePackages
     * const servicePackage = await prisma.servicePackage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServicePackages and only return the `parentPackageId`
     * const servicePackageWithParentPackageIdOnly = await prisma.servicePackage.updateManyAndReturn({
     *   select: { parentPackageId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServicePackageUpdateManyAndReturnArgs>(args: SelectSubset<T, ServicePackageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePackagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServicePackage.
     * @param {ServicePackageUpsertArgs} args - Arguments to update or create a ServicePackage.
     * @example
     * // Update or create a ServicePackage
     * const servicePackage = await prisma.servicePackage.upsert({
     *   create: {
     *     // ... data to create a ServicePackage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServicePackage we want to update
     *   }
     * })
     */
    upsert<T extends ServicePackageUpsertArgs>(args: SelectSubset<T, ServicePackageUpsertArgs<ExtArgs>>): Prisma__ServicePackageClient<$Result.GetResult<Prisma.$ServicePackagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServicePackages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePackageCountArgs} args - Arguments to filter ServicePackages to count.
     * @example
     * // Count the number of ServicePackages
     * const count = await prisma.servicePackage.count({
     *   where: {
     *     // ... the filter for the ServicePackages we want to count
     *   }
     * })
    **/
    count<T extends ServicePackageCountArgs>(
      args?: Subset<T, ServicePackageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicePackageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServicePackage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePackageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicePackageAggregateArgs>(args: Subset<T, ServicePackageAggregateArgs>): Prisma.PrismaPromise<GetServicePackageAggregateType<T>>

    /**
     * Group by ServicePackage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePackageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServicePackageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServicePackageGroupByArgs['orderBy'] }
        : { orderBy?: ServicePackageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServicePackageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicePackageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServicePackage model
   */
  readonly fields: ServicePackageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServicePackage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServicePackageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parentPackage<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    childService<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServicePackage model
   */
  interface ServicePackageFieldRefs {
    readonly parentPackageId: FieldRef<"ServicePackage", 'String'>
    readonly childServiceId: FieldRef<"ServicePackage", 'String'>
    readonly createdAt: FieldRef<"ServicePackage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServicePackage findUnique
   */
  export type ServicePackageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePackage
     */
    select?: ServicePackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePackage
     */
    omit?: ServicePackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePackageInclude<ExtArgs> | null
    /**
     * Filter, which ServicePackage to fetch.
     */
    where: ServicePackageWhereUniqueInput
  }

  /**
   * ServicePackage findUniqueOrThrow
   */
  export type ServicePackageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePackage
     */
    select?: ServicePackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePackage
     */
    omit?: ServicePackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePackageInclude<ExtArgs> | null
    /**
     * Filter, which ServicePackage to fetch.
     */
    where: ServicePackageWhereUniqueInput
  }

  /**
   * ServicePackage findFirst
   */
  export type ServicePackageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePackage
     */
    select?: ServicePackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePackage
     */
    omit?: ServicePackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePackageInclude<ExtArgs> | null
    /**
     * Filter, which ServicePackage to fetch.
     */
    where?: ServicePackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicePackages to fetch.
     */
    orderBy?: ServicePackageOrderByWithRelationInput | ServicePackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServicePackages.
     */
    cursor?: ServicePackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicePackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicePackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServicePackages.
     */
    distinct?: ServicePackageScalarFieldEnum | ServicePackageScalarFieldEnum[]
  }

  /**
   * ServicePackage findFirstOrThrow
   */
  export type ServicePackageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePackage
     */
    select?: ServicePackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePackage
     */
    omit?: ServicePackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePackageInclude<ExtArgs> | null
    /**
     * Filter, which ServicePackage to fetch.
     */
    where?: ServicePackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicePackages to fetch.
     */
    orderBy?: ServicePackageOrderByWithRelationInput | ServicePackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServicePackages.
     */
    cursor?: ServicePackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicePackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicePackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServicePackages.
     */
    distinct?: ServicePackageScalarFieldEnum | ServicePackageScalarFieldEnum[]
  }

  /**
   * ServicePackage findMany
   */
  export type ServicePackageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePackage
     */
    select?: ServicePackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePackage
     */
    omit?: ServicePackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePackageInclude<ExtArgs> | null
    /**
     * Filter, which ServicePackages to fetch.
     */
    where?: ServicePackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicePackages to fetch.
     */
    orderBy?: ServicePackageOrderByWithRelationInput | ServicePackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServicePackages.
     */
    cursor?: ServicePackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicePackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicePackages.
     */
    skip?: number
    distinct?: ServicePackageScalarFieldEnum | ServicePackageScalarFieldEnum[]
  }

  /**
   * ServicePackage create
   */
  export type ServicePackageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePackage
     */
    select?: ServicePackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePackage
     */
    omit?: ServicePackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePackageInclude<ExtArgs> | null
    /**
     * The data needed to create a ServicePackage.
     */
    data: XOR<ServicePackageCreateInput, ServicePackageUncheckedCreateInput>
  }

  /**
   * ServicePackage createMany
   */
  export type ServicePackageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServicePackages.
     */
    data: ServicePackageCreateManyInput | ServicePackageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServicePackage createManyAndReturn
   */
  export type ServicePackageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePackage
     */
    select?: ServicePackageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePackage
     */
    omit?: ServicePackageOmit<ExtArgs> | null
    /**
     * The data used to create many ServicePackages.
     */
    data: ServicePackageCreateManyInput | ServicePackageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePackageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServicePackage update
   */
  export type ServicePackageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePackage
     */
    select?: ServicePackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePackage
     */
    omit?: ServicePackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePackageInclude<ExtArgs> | null
    /**
     * The data needed to update a ServicePackage.
     */
    data: XOR<ServicePackageUpdateInput, ServicePackageUncheckedUpdateInput>
    /**
     * Choose, which ServicePackage to update.
     */
    where: ServicePackageWhereUniqueInput
  }

  /**
   * ServicePackage updateMany
   */
  export type ServicePackageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServicePackages.
     */
    data: XOR<ServicePackageUpdateManyMutationInput, ServicePackageUncheckedUpdateManyInput>
    /**
     * Filter which ServicePackages to update
     */
    where?: ServicePackageWhereInput
    /**
     * Limit how many ServicePackages to update.
     */
    limit?: number
  }

  /**
   * ServicePackage updateManyAndReturn
   */
  export type ServicePackageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePackage
     */
    select?: ServicePackageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePackage
     */
    omit?: ServicePackageOmit<ExtArgs> | null
    /**
     * The data used to update ServicePackages.
     */
    data: XOR<ServicePackageUpdateManyMutationInput, ServicePackageUncheckedUpdateManyInput>
    /**
     * Filter which ServicePackages to update
     */
    where?: ServicePackageWhereInput
    /**
     * Limit how many ServicePackages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePackageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServicePackage upsert
   */
  export type ServicePackageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePackage
     */
    select?: ServicePackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePackage
     */
    omit?: ServicePackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePackageInclude<ExtArgs> | null
    /**
     * The filter to search for the ServicePackage to update in case it exists.
     */
    where: ServicePackageWhereUniqueInput
    /**
     * In case the ServicePackage found by the `where` argument doesn't exist, create a new ServicePackage with this data.
     */
    create: XOR<ServicePackageCreateInput, ServicePackageUncheckedCreateInput>
    /**
     * In case the ServicePackage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServicePackageUpdateInput, ServicePackageUncheckedUpdateInput>
  }

  /**
   * ServicePackage delete
   */
  export type ServicePackageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePackage
     */
    select?: ServicePackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePackage
     */
    omit?: ServicePackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePackageInclude<ExtArgs> | null
    /**
     * Filter which ServicePackage to delete.
     */
    where: ServicePackageWhereUniqueInput
  }

  /**
   * ServicePackage deleteMany
   */
  export type ServicePackageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServicePackages to delete
     */
    where?: ServicePackageWhereInput
    /**
     * Limit how many ServicePackages to delete.
     */
    limit?: number
  }

  /**
   * ServicePackage without action
   */
  export type ServicePackageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePackage
     */
    select?: ServicePackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePackage
     */
    omit?: ServicePackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePackageInclude<ExtArgs> | null
  }


  /**
   * Model InsuranceProvider
   */

  export type AggregateInsuranceProvider = {
    _count: InsuranceProviderCountAggregateOutputType | null
    _min: InsuranceProviderMinAggregateOutputType | null
    _max: InsuranceProviderMaxAggregateOutputType | null
  }

  export type InsuranceProviderMinAggregateOutputType = {
    id: string | null
    name: string | null
    isActive: boolean | null
  }

  export type InsuranceProviderMaxAggregateOutputType = {
    id: string | null
    name: string | null
    isActive: boolean | null
  }

  export type InsuranceProviderCountAggregateOutputType = {
    id: number
    name: number
    isActive: number
    _all: number
  }


  export type InsuranceProviderMinAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
  }

  export type InsuranceProviderMaxAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
  }

  export type InsuranceProviderCountAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
    _all?: true
  }

  export type InsuranceProviderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InsuranceProvider to aggregate.
     */
    where?: InsuranceProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsuranceProviders to fetch.
     */
    orderBy?: InsuranceProviderOrderByWithRelationInput | InsuranceProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InsuranceProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsuranceProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsuranceProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InsuranceProviders
    **/
    _count?: true | InsuranceProviderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InsuranceProviderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InsuranceProviderMaxAggregateInputType
  }

  export type GetInsuranceProviderAggregateType<T extends InsuranceProviderAggregateArgs> = {
        [P in keyof T & keyof AggregateInsuranceProvider]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInsuranceProvider[P]>
      : GetScalarType<T[P], AggregateInsuranceProvider[P]>
  }




  export type InsuranceProviderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsuranceProviderWhereInput
    orderBy?: InsuranceProviderOrderByWithAggregationInput | InsuranceProviderOrderByWithAggregationInput[]
    by: InsuranceProviderScalarFieldEnum[] | InsuranceProviderScalarFieldEnum
    having?: InsuranceProviderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InsuranceProviderCountAggregateInputType | true
    _min?: InsuranceProviderMinAggregateInputType
    _max?: InsuranceProviderMaxAggregateInputType
  }

  export type InsuranceProviderGroupByOutputType = {
    id: string
    name: string
    isActive: boolean
    _count: InsuranceProviderCountAggregateOutputType | null
    _min: InsuranceProviderMinAggregateOutputType | null
    _max: InsuranceProviderMaxAggregateOutputType | null
  }

  type GetInsuranceProviderGroupByPayload<T extends InsuranceProviderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InsuranceProviderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InsuranceProviderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InsuranceProviderGroupByOutputType[P]>
            : GetScalarType<T[P], InsuranceProviderGroupByOutputType[P]>
        }
      >
    >


  export type InsuranceProviderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isActive?: boolean
    services?: boolean | InsuranceProvider$servicesArgs<ExtArgs>
    _count?: boolean | InsuranceProviderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insuranceProvider"]>

  export type InsuranceProviderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["insuranceProvider"]>

  export type InsuranceProviderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["insuranceProvider"]>

  export type InsuranceProviderSelectScalar = {
    id?: boolean
    name?: boolean
    isActive?: boolean
  }

  export type InsuranceProviderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "isActive", ExtArgs["result"]["insuranceProvider"]>
  export type InsuranceProviderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | InsuranceProvider$servicesArgs<ExtArgs>
    _count?: boolean | InsuranceProviderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InsuranceProviderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type InsuranceProviderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $InsuranceProviderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InsuranceProvider"
    objects: {
      services: Prisma.$ServiceInsurancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      isActive: boolean
    }, ExtArgs["result"]["insuranceProvider"]>
    composites: {}
  }

  type InsuranceProviderGetPayload<S extends boolean | null | undefined | InsuranceProviderDefaultArgs> = $Result.GetResult<Prisma.$InsuranceProviderPayload, S>

  type InsuranceProviderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InsuranceProviderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InsuranceProviderCountAggregateInputType | true
    }

  export interface InsuranceProviderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InsuranceProvider'], meta: { name: 'InsuranceProvider' } }
    /**
     * Find zero or one InsuranceProvider that matches the filter.
     * @param {InsuranceProviderFindUniqueArgs} args - Arguments to find a InsuranceProvider
     * @example
     * // Get one InsuranceProvider
     * const insuranceProvider = await prisma.insuranceProvider.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InsuranceProviderFindUniqueArgs>(args: SelectSubset<T, InsuranceProviderFindUniqueArgs<ExtArgs>>): Prisma__InsuranceProviderClient<$Result.GetResult<Prisma.$InsuranceProviderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InsuranceProvider that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InsuranceProviderFindUniqueOrThrowArgs} args - Arguments to find a InsuranceProvider
     * @example
     * // Get one InsuranceProvider
     * const insuranceProvider = await prisma.insuranceProvider.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InsuranceProviderFindUniqueOrThrowArgs>(args: SelectSubset<T, InsuranceProviderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InsuranceProviderClient<$Result.GetResult<Prisma.$InsuranceProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InsuranceProvider that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceProviderFindFirstArgs} args - Arguments to find a InsuranceProvider
     * @example
     * // Get one InsuranceProvider
     * const insuranceProvider = await prisma.insuranceProvider.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InsuranceProviderFindFirstArgs>(args?: SelectSubset<T, InsuranceProviderFindFirstArgs<ExtArgs>>): Prisma__InsuranceProviderClient<$Result.GetResult<Prisma.$InsuranceProviderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InsuranceProvider that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceProviderFindFirstOrThrowArgs} args - Arguments to find a InsuranceProvider
     * @example
     * // Get one InsuranceProvider
     * const insuranceProvider = await prisma.insuranceProvider.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InsuranceProviderFindFirstOrThrowArgs>(args?: SelectSubset<T, InsuranceProviderFindFirstOrThrowArgs<ExtArgs>>): Prisma__InsuranceProviderClient<$Result.GetResult<Prisma.$InsuranceProviderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InsuranceProviders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceProviderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InsuranceProviders
     * const insuranceProviders = await prisma.insuranceProvider.findMany()
     * 
     * // Get first 10 InsuranceProviders
     * const insuranceProviders = await prisma.insuranceProvider.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const insuranceProviderWithIdOnly = await prisma.insuranceProvider.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InsuranceProviderFindManyArgs>(args?: SelectSubset<T, InsuranceProviderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsuranceProviderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InsuranceProvider.
     * @param {InsuranceProviderCreateArgs} args - Arguments to create a InsuranceProvider.
     * @example
     * // Create one InsuranceProvider
     * const InsuranceProvider = await prisma.insuranceProvider.create({
     *   data: {
     *     // ... data to create a InsuranceProvider
     *   }
     * })
     * 
     */
    create<T extends InsuranceProviderCreateArgs>(args: SelectSubset<T, InsuranceProviderCreateArgs<ExtArgs>>): Prisma__InsuranceProviderClient<$Result.GetResult<Prisma.$InsuranceProviderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InsuranceProviders.
     * @param {InsuranceProviderCreateManyArgs} args - Arguments to create many InsuranceProviders.
     * @example
     * // Create many InsuranceProviders
     * const insuranceProvider = await prisma.insuranceProvider.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InsuranceProviderCreateManyArgs>(args?: SelectSubset<T, InsuranceProviderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InsuranceProviders and returns the data saved in the database.
     * @param {InsuranceProviderCreateManyAndReturnArgs} args - Arguments to create many InsuranceProviders.
     * @example
     * // Create many InsuranceProviders
     * const insuranceProvider = await prisma.insuranceProvider.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InsuranceProviders and only return the `id`
     * const insuranceProviderWithIdOnly = await prisma.insuranceProvider.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InsuranceProviderCreateManyAndReturnArgs>(args?: SelectSubset<T, InsuranceProviderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsuranceProviderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InsuranceProvider.
     * @param {InsuranceProviderDeleteArgs} args - Arguments to delete one InsuranceProvider.
     * @example
     * // Delete one InsuranceProvider
     * const InsuranceProvider = await prisma.insuranceProvider.delete({
     *   where: {
     *     // ... filter to delete one InsuranceProvider
     *   }
     * })
     * 
     */
    delete<T extends InsuranceProviderDeleteArgs>(args: SelectSubset<T, InsuranceProviderDeleteArgs<ExtArgs>>): Prisma__InsuranceProviderClient<$Result.GetResult<Prisma.$InsuranceProviderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InsuranceProvider.
     * @param {InsuranceProviderUpdateArgs} args - Arguments to update one InsuranceProvider.
     * @example
     * // Update one InsuranceProvider
     * const insuranceProvider = await prisma.insuranceProvider.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InsuranceProviderUpdateArgs>(args: SelectSubset<T, InsuranceProviderUpdateArgs<ExtArgs>>): Prisma__InsuranceProviderClient<$Result.GetResult<Prisma.$InsuranceProviderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InsuranceProviders.
     * @param {InsuranceProviderDeleteManyArgs} args - Arguments to filter InsuranceProviders to delete.
     * @example
     * // Delete a few InsuranceProviders
     * const { count } = await prisma.insuranceProvider.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InsuranceProviderDeleteManyArgs>(args?: SelectSubset<T, InsuranceProviderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InsuranceProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceProviderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InsuranceProviders
     * const insuranceProvider = await prisma.insuranceProvider.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InsuranceProviderUpdateManyArgs>(args: SelectSubset<T, InsuranceProviderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InsuranceProviders and returns the data updated in the database.
     * @param {InsuranceProviderUpdateManyAndReturnArgs} args - Arguments to update many InsuranceProviders.
     * @example
     * // Update many InsuranceProviders
     * const insuranceProvider = await prisma.insuranceProvider.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InsuranceProviders and only return the `id`
     * const insuranceProviderWithIdOnly = await prisma.insuranceProvider.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InsuranceProviderUpdateManyAndReturnArgs>(args: SelectSubset<T, InsuranceProviderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsuranceProviderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InsuranceProvider.
     * @param {InsuranceProviderUpsertArgs} args - Arguments to update or create a InsuranceProvider.
     * @example
     * // Update or create a InsuranceProvider
     * const insuranceProvider = await prisma.insuranceProvider.upsert({
     *   create: {
     *     // ... data to create a InsuranceProvider
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InsuranceProvider we want to update
     *   }
     * })
     */
    upsert<T extends InsuranceProviderUpsertArgs>(args: SelectSubset<T, InsuranceProviderUpsertArgs<ExtArgs>>): Prisma__InsuranceProviderClient<$Result.GetResult<Prisma.$InsuranceProviderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InsuranceProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceProviderCountArgs} args - Arguments to filter InsuranceProviders to count.
     * @example
     * // Count the number of InsuranceProviders
     * const count = await prisma.insuranceProvider.count({
     *   where: {
     *     // ... the filter for the InsuranceProviders we want to count
     *   }
     * })
    **/
    count<T extends InsuranceProviderCountArgs>(
      args?: Subset<T, InsuranceProviderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InsuranceProviderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InsuranceProvider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceProviderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InsuranceProviderAggregateArgs>(args: Subset<T, InsuranceProviderAggregateArgs>): Prisma.PrismaPromise<GetInsuranceProviderAggregateType<T>>

    /**
     * Group by InsuranceProvider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceProviderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InsuranceProviderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InsuranceProviderGroupByArgs['orderBy'] }
        : { orderBy?: InsuranceProviderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InsuranceProviderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInsuranceProviderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InsuranceProvider model
   */
  readonly fields: InsuranceProviderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InsuranceProvider.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InsuranceProviderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    services<T extends InsuranceProvider$servicesArgs<ExtArgs> = {}>(args?: Subset<T, InsuranceProvider$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceInsurancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InsuranceProvider model
   */
  interface InsuranceProviderFieldRefs {
    readonly id: FieldRef<"InsuranceProvider", 'String'>
    readonly name: FieldRef<"InsuranceProvider", 'String'>
    readonly isActive: FieldRef<"InsuranceProvider", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * InsuranceProvider findUnique
   */
  export type InsuranceProviderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceProvider
     */
    select?: InsuranceProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceProvider
     */
    omit?: InsuranceProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceProviderInclude<ExtArgs> | null
    /**
     * Filter, which InsuranceProvider to fetch.
     */
    where: InsuranceProviderWhereUniqueInput
  }

  /**
   * InsuranceProvider findUniqueOrThrow
   */
  export type InsuranceProviderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceProvider
     */
    select?: InsuranceProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceProvider
     */
    omit?: InsuranceProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceProviderInclude<ExtArgs> | null
    /**
     * Filter, which InsuranceProvider to fetch.
     */
    where: InsuranceProviderWhereUniqueInput
  }

  /**
   * InsuranceProvider findFirst
   */
  export type InsuranceProviderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceProvider
     */
    select?: InsuranceProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceProvider
     */
    omit?: InsuranceProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceProviderInclude<ExtArgs> | null
    /**
     * Filter, which InsuranceProvider to fetch.
     */
    where?: InsuranceProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsuranceProviders to fetch.
     */
    orderBy?: InsuranceProviderOrderByWithRelationInput | InsuranceProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InsuranceProviders.
     */
    cursor?: InsuranceProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsuranceProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsuranceProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InsuranceProviders.
     */
    distinct?: InsuranceProviderScalarFieldEnum | InsuranceProviderScalarFieldEnum[]
  }

  /**
   * InsuranceProvider findFirstOrThrow
   */
  export type InsuranceProviderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceProvider
     */
    select?: InsuranceProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceProvider
     */
    omit?: InsuranceProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceProviderInclude<ExtArgs> | null
    /**
     * Filter, which InsuranceProvider to fetch.
     */
    where?: InsuranceProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsuranceProviders to fetch.
     */
    orderBy?: InsuranceProviderOrderByWithRelationInput | InsuranceProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InsuranceProviders.
     */
    cursor?: InsuranceProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsuranceProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsuranceProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InsuranceProviders.
     */
    distinct?: InsuranceProviderScalarFieldEnum | InsuranceProviderScalarFieldEnum[]
  }

  /**
   * InsuranceProvider findMany
   */
  export type InsuranceProviderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceProvider
     */
    select?: InsuranceProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceProvider
     */
    omit?: InsuranceProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceProviderInclude<ExtArgs> | null
    /**
     * Filter, which InsuranceProviders to fetch.
     */
    where?: InsuranceProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsuranceProviders to fetch.
     */
    orderBy?: InsuranceProviderOrderByWithRelationInput | InsuranceProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InsuranceProviders.
     */
    cursor?: InsuranceProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsuranceProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsuranceProviders.
     */
    skip?: number
    distinct?: InsuranceProviderScalarFieldEnum | InsuranceProviderScalarFieldEnum[]
  }

  /**
   * InsuranceProvider create
   */
  export type InsuranceProviderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceProvider
     */
    select?: InsuranceProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceProvider
     */
    omit?: InsuranceProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceProviderInclude<ExtArgs> | null
    /**
     * The data needed to create a InsuranceProvider.
     */
    data: XOR<InsuranceProviderCreateInput, InsuranceProviderUncheckedCreateInput>
  }

  /**
   * InsuranceProvider createMany
   */
  export type InsuranceProviderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InsuranceProviders.
     */
    data: InsuranceProviderCreateManyInput | InsuranceProviderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InsuranceProvider createManyAndReturn
   */
  export type InsuranceProviderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceProvider
     */
    select?: InsuranceProviderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceProvider
     */
    omit?: InsuranceProviderOmit<ExtArgs> | null
    /**
     * The data used to create many InsuranceProviders.
     */
    data: InsuranceProviderCreateManyInput | InsuranceProviderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InsuranceProvider update
   */
  export type InsuranceProviderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceProvider
     */
    select?: InsuranceProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceProvider
     */
    omit?: InsuranceProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceProviderInclude<ExtArgs> | null
    /**
     * The data needed to update a InsuranceProvider.
     */
    data: XOR<InsuranceProviderUpdateInput, InsuranceProviderUncheckedUpdateInput>
    /**
     * Choose, which InsuranceProvider to update.
     */
    where: InsuranceProviderWhereUniqueInput
  }

  /**
   * InsuranceProvider updateMany
   */
  export type InsuranceProviderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InsuranceProviders.
     */
    data: XOR<InsuranceProviderUpdateManyMutationInput, InsuranceProviderUncheckedUpdateManyInput>
    /**
     * Filter which InsuranceProviders to update
     */
    where?: InsuranceProviderWhereInput
    /**
     * Limit how many InsuranceProviders to update.
     */
    limit?: number
  }

  /**
   * InsuranceProvider updateManyAndReturn
   */
  export type InsuranceProviderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceProvider
     */
    select?: InsuranceProviderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceProvider
     */
    omit?: InsuranceProviderOmit<ExtArgs> | null
    /**
     * The data used to update InsuranceProviders.
     */
    data: XOR<InsuranceProviderUpdateManyMutationInput, InsuranceProviderUncheckedUpdateManyInput>
    /**
     * Filter which InsuranceProviders to update
     */
    where?: InsuranceProviderWhereInput
    /**
     * Limit how many InsuranceProviders to update.
     */
    limit?: number
  }

  /**
   * InsuranceProvider upsert
   */
  export type InsuranceProviderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceProvider
     */
    select?: InsuranceProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceProvider
     */
    omit?: InsuranceProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceProviderInclude<ExtArgs> | null
    /**
     * The filter to search for the InsuranceProvider to update in case it exists.
     */
    where: InsuranceProviderWhereUniqueInput
    /**
     * In case the InsuranceProvider found by the `where` argument doesn't exist, create a new InsuranceProvider with this data.
     */
    create: XOR<InsuranceProviderCreateInput, InsuranceProviderUncheckedCreateInput>
    /**
     * In case the InsuranceProvider was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InsuranceProviderUpdateInput, InsuranceProviderUncheckedUpdateInput>
  }

  /**
   * InsuranceProvider delete
   */
  export type InsuranceProviderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceProvider
     */
    select?: InsuranceProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceProvider
     */
    omit?: InsuranceProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceProviderInclude<ExtArgs> | null
    /**
     * Filter which InsuranceProvider to delete.
     */
    where: InsuranceProviderWhereUniqueInput
  }

  /**
   * InsuranceProvider deleteMany
   */
  export type InsuranceProviderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InsuranceProviders to delete
     */
    where?: InsuranceProviderWhereInput
    /**
     * Limit how many InsuranceProviders to delete.
     */
    limit?: number
  }

  /**
   * InsuranceProvider.services
   */
  export type InsuranceProvider$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInsurance
     */
    select?: ServiceInsuranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInsurance
     */
    omit?: ServiceInsuranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInsuranceInclude<ExtArgs> | null
    where?: ServiceInsuranceWhereInput
    orderBy?: ServiceInsuranceOrderByWithRelationInput | ServiceInsuranceOrderByWithRelationInput[]
    cursor?: ServiceInsuranceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceInsuranceScalarFieldEnum | ServiceInsuranceScalarFieldEnum[]
  }

  /**
   * InsuranceProvider without action
   */
  export type InsuranceProviderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceProvider
     */
    select?: InsuranceProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceProvider
     */
    omit?: InsuranceProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceProviderInclude<ExtArgs> | null
  }


  /**
   * Model ServiceInsurance
   */

  export type AggregateServiceInsurance = {
    _count: ServiceInsuranceCountAggregateOutputType | null
    _min: ServiceInsuranceMinAggregateOutputType | null
    _max: ServiceInsuranceMaxAggregateOutputType | null
  }

  export type ServiceInsuranceMinAggregateOutputType = {
    serviceId: string | null
    insuranceProviderId: string | null
  }

  export type ServiceInsuranceMaxAggregateOutputType = {
    serviceId: string | null
    insuranceProviderId: string | null
  }

  export type ServiceInsuranceCountAggregateOutputType = {
    serviceId: number
    insuranceProviderId: number
    _all: number
  }


  export type ServiceInsuranceMinAggregateInputType = {
    serviceId?: true
    insuranceProviderId?: true
  }

  export type ServiceInsuranceMaxAggregateInputType = {
    serviceId?: true
    insuranceProviderId?: true
  }

  export type ServiceInsuranceCountAggregateInputType = {
    serviceId?: true
    insuranceProviderId?: true
    _all?: true
  }

  export type ServiceInsuranceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceInsurance to aggregate.
     */
    where?: ServiceInsuranceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceInsurances to fetch.
     */
    orderBy?: ServiceInsuranceOrderByWithRelationInput | ServiceInsuranceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceInsuranceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceInsurances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceInsurances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceInsurances
    **/
    _count?: true | ServiceInsuranceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceInsuranceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceInsuranceMaxAggregateInputType
  }

  export type GetServiceInsuranceAggregateType<T extends ServiceInsuranceAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceInsurance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceInsurance[P]>
      : GetScalarType<T[P], AggregateServiceInsurance[P]>
  }




  export type ServiceInsuranceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceInsuranceWhereInput
    orderBy?: ServiceInsuranceOrderByWithAggregationInput | ServiceInsuranceOrderByWithAggregationInput[]
    by: ServiceInsuranceScalarFieldEnum[] | ServiceInsuranceScalarFieldEnum
    having?: ServiceInsuranceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceInsuranceCountAggregateInputType | true
    _min?: ServiceInsuranceMinAggregateInputType
    _max?: ServiceInsuranceMaxAggregateInputType
  }

  export type ServiceInsuranceGroupByOutputType = {
    serviceId: string
    insuranceProviderId: string
    _count: ServiceInsuranceCountAggregateOutputType | null
    _min: ServiceInsuranceMinAggregateOutputType | null
    _max: ServiceInsuranceMaxAggregateOutputType | null
  }

  type GetServiceInsuranceGroupByPayload<T extends ServiceInsuranceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceInsuranceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceInsuranceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceInsuranceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceInsuranceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceInsuranceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    serviceId?: boolean
    insuranceProviderId?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    insuranceProvider?: boolean | InsuranceProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceInsurance"]>

  export type ServiceInsuranceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    serviceId?: boolean
    insuranceProviderId?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    insuranceProvider?: boolean | InsuranceProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceInsurance"]>

  export type ServiceInsuranceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    serviceId?: boolean
    insuranceProviderId?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    insuranceProvider?: boolean | InsuranceProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceInsurance"]>

  export type ServiceInsuranceSelectScalar = {
    serviceId?: boolean
    insuranceProviderId?: boolean
  }

  export type ServiceInsuranceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"serviceId" | "insuranceProviderId", ExtArgs["result"]["serviceInsurance"]>
  export type ServiceInsuranceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    insuranceProvider?: boolean | InsuranceProviderDefaultArgs<ExtArgs>
  }
  export type ServiceInsuranceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    insuranceProvider?: boolean | InsuranceProviderDefaultArgs<ExtArgs>
  }
  export type ServiceInsuranceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    insuranceProvider?: boolean | InsuranceProviderDefaultArgs<ExtArgs>
  }

  export type $ServiceInsurancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceInsurance"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs>
      insuranceProvider: Prisma.$InsuranceProviderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      serviceId: string
      insuranceProviderId: string
    }, ExtArgs["result"]["serviceInsurance"]>
    composites: {}
  }

  type ServiceInsuranceGetPayload<S extends boolean | null | undefined | ServiceInsuranceDefaultArgs> = $Result.GetResult<Prisma.$ServiceInsurancePayload, S>

  type ServiceInsuranceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceInsuranceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceInsuranceCountAggregateInputType | true
    }

  export interface ServiceInsuranceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceInsurance'], meta: { name: 'ServiceInsurance' } }
    /**
     * Find zero or one ServiceInsurance that matches the filter.
     * @param {ServiceInsuranceFindUniqueArgs} args - Arguments to find a ServiceInsurance
     * @example
     * // Get one ServiceInsurance
     * const serviceInsurance = await prisma.serviceInsurance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceInsuranceFindUniqueArgs>(args: SelectSubset<T, ServiceInsuranceFindUniqueArgs<ExtArgs>>): Prisma__ServiceInsuranceClient<$Result.GetResult<Prisma.$ServiceInsurancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceInsurance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceInsuranceFindUniqueOrThrowArgs} args - Arguments to find a ServiceInsurance
     * @example
     * // Get one ServiceInsurance
     * const serviceInsurance = await prisma.serviceInsurance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceInsuranceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceInsuranceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceInsuranceClient<$Result.GetResult<Prisma.$ServiceInsurancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceInsurance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceInsuranceFindFirstArgs} args - Arguments to find a ServiceInsurance
     * @example
     * // Get one ServiceInsurance
     * const serviceInsurance = await prisma.serviceInsurance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceInsuranceFindFirstArgs>(args?: SelectSubset<T, ServiceInsuranceFindFirstArgs<ExtArgs>>): Prisma__ServiceInsuranceClient<$Result.GetResult<Prisma.$ServiceInsurancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceInsurance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceInsuranceFindFirstOrThrowArgs} args - Arguments to find a ServiceInsurance
     * @example
     * // Get one ServiceInsurance
     * const serviceInsurance = await prisma.serviceInsurance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceInsuranceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceInsuranceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceInsuranceClient<$Result.GetResult<Prisma.$ServiceInsurancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceInsurances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceInsuranceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceInsurances
     * const serviceInsurances = await prisma.serviceInsurance.findMany()
     * 
     * // Get first 10 ServiceInsurances
     * const serviceInsurances = await prisma.serviceInsurance.findMany({ take: 10 })
     * 
     * // Only select the `serviceId`
     * const serviceInsuranceWithServiceIdOnly = await prisma.serviceInsurance.findMany({ select: { serviceId: true } })
     * 
     */
    findMany<T extends ServiceInsuranceFindManyArgs>(args?: SelectSubset<T, ServiceInsuranceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceInsurancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceInsurance.
     * @param {ServiceInsuranceCreateArgs} args - Arguments to create a ServiceInsurance.
     * @example
     * // Create one ServiceInsurance
     * const ServiceInsurance = await prisma.serviceInsurance.create({
     *   data: {
     *     // ... data to create a ServiceInsurance
     *   }
     * })
     * 
     */
    create<T extends ServiceInsuranceCreateArgs>(args: SelectSubset<T, ServiceInsuranceCreateArgs<ExtArgs>>): Prisma__ServiceInsuranceClient<$Result.GetResult<Prisma.$ServiceInsurancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceInsurances.
     * @param {ServiceInsuranceCreateManyArgs} args - Arguments to create many ServiceInsurances.
     * @example
     * // Create many ServiceInsurances
     * const serviceInsurance = await prisma.serviceInsurance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceInsuranceCreateManyArgs>(args?: SelectSubset<T, ServiceInsuranceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceInsurances and returns the data saved in the database.
     * @param {ServiceInsuranceCreateManyAndReturnArgs} args - Arguments to create many ServiceInsurances.
     * @example
     * // Create many ServiceInsurances
     * const serviceInsurance = await prisma.serviceInsurance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceInsurances and only return the `serviceId`
     * const serviceInsuranceWithServiceIdOnly = await prisma.serviceInsurance.createManyAndReturn({
     *   select: { serviceId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceInsuranceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceInsuranceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceInsurancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceInsurance.
     * @param {ServiceInsuranceDeleteArgs} args - Arguments to delete one ServiceInsurance.
     * @example
     * // Delete one ServiceInsurance
     * const ServiceInsurance = await prisma.serviceInsurance.delete({
     *   where: {
     *     // ... filter to delete one ServiceInsurance
     *   }
     * })
     * 
     */
    delete<T extends ServiceInsuranceDeleteArgs>(args: SelectSubset<T, ServiceInsuranceDeleteArgs<ExtArgs>>): Prisma__ServiceInsuranceClient<$Result.GetResult<Prisma.$ServiceInsurancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceInsurance.
     * @param {ServiceInsuranceUpdateArgs} args - Arguments to update one ServiceInsurance.
     * @example
     * // Update one ServiceInsurance
     * const serviceInsurance = await prisma.serviceInsurance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceInsuranceUpdateArgs>(args: SelectSubset<T, ServiceInsuranceUpdateArgs<ExtArgs>>): Prisma__ServiceInsuranceClient<$Result.GetResult<Prisma.$ServiceInsurancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceInsurances.
     * @param {ServiceInsuranceDeleteManyArgs} args - Arguments to filter ServiceInsurances to delete.
     * @example
     * // Delete a few ServiceInsurances
     * const { count } = await prisma.serviceInsurance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceInsuranceDeleteManyArgs>(args?: SelectSubset<T, ServiceInsuranceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceInsurances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceInsuranceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceInsurances
     * const serviceInsurance = await prisma.serviceInsurance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceInsuranceUpdateManyArgs>(args: SelectSubset<T, ServiceInsuranceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceInsurances and returns the data updated in the database.
     * @param {ServiceInsuranceUpdateManyAndReturnArgs} args - Arguments to update many ServiceInsurances.
     * @example
     * // Update many ServiceInsurances
     * const serviceInsurance = await prisma.serviceInsurance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceInsurances and only return the `serviceId`
     * const serviceInsuranceWithServiceIdOnly = await prisma.serviceInsurance.updateManyAndReturn({
     *   select: { serviceId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceInsuranceUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceInsuranceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceInsurancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceInsurance.
     * @param {ServiceInsuranceUpsertArgs} args - Arguments to update or create a ServiceInsurance.
     * @example
     * // Update or create a ServiceInsurance
     * const serviceInsurance = await prisma.serviceInsurance.upsert({
     *   create: {
     *     // ... data to create a ServiceInsurance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceInsurance we want to update
     *   }
     * })
     */
    upsert<T extends ServiceInsuranceUpsertArgs>(args: SelectSubset<T, ServiceInsuranceUpsertArgs<ExtArgs>>): Prisma__ServiceInsuranceClient<$Result.GetResult<Prisma.$ServiceInsurancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceInsurances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceInsuranceCountArgs} args - Arguments to filter ServiceInsurances to count.
     * @example
     * // Count the number of ServiceInsurances
     * const count = await prisma.serviceInsurance.count({
     *   where: {
     *     // ... the filter for the ServiceInsurances we want to count
     *   }
     * })
    **/
    count<T extends ServiceInsuranceCountArgs>(
      args?: Subset<T, ServiceInsuranceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceInsuranceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceInsurance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceInsuranceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceInsuranceAggregateArgs>(args: Subset<T, ServiceInsuranceAggregateArgs>): Prisma.PrismaPromise<GetServiceInsuranceAggregateType<T>>

    /**
     * Group by ServiceInsurance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceInsuranceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceInsuranceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceInsuranceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceInsuranceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceInsuranceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceInsuranceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceInsurance model
   */
  readonly fields: ServiceInsuranceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceInsurance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceInsuranceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    insuranceProvider<T extends InsuranceProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InsuranceProviderDefaultArgs<ExtArgs>>): Prisma__InsuranceProviderClient<$Result.GetResult<Prisma.$InsuranceProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceInsurance model
   */
  interface ServiceInsuranceFieldRefs {
    readonly serviceId: FieldRef<"ServiceInsurance", 'String'>
    readonly insuranceProviderId: FieldRef<"ServiceInsurance", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ServiceInsurance findUnique
   */
  export type ServiceInsuranceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInsurance
     */
    select?: ServiceInsuranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInsurance
     */
    omit?: ServiceInsuranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInsuranceInclude<ExtArgs> | null
    /**
     * Filter, which ServiceInsurance to fetch.
     */
    where: ServiceInsuranceWhereUniqueInput
  }

  /**
   * ServiceInsurance findUniqueOrThrow
   */
  export type ServiceInsuranceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInsurance
     */
    select?: ServiceInsuranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInsurance
     */
    omit?: ServiceInsuranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInsuranceInclude<ExtArgs> | null
    /**
     * Filter, which ServiceInsurance to fetch.
     */
    where: ServiceInsuranceWhereUniqueInput
  }

  /**
   * ServiceInsurance findFirst
   */
  export type ServiceInsuranceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInsurance
     */
    select?: ServiceInsuranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInsurance
     */
    omit?: ServiceInsuranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInsuranceInclude<ExtArgs> | null
    /**
     * Filter, which ServiceInsurance to fetch.
     */
    where?: ServiceInsuranceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceInsurances to fetch.
     */
    orderBy?: ServiceInsuranceOrderByWithRelationInput | ServiceInsuranceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceInsurances.
     */
    cursor?: ServiceInsuranceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceInsurances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceInsurances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceInsurances.
     */
    distinct?: ServiceInsuranceScalarFieldEnum | ServiceInsuranceScalarFieldEnum[]
  }

  /**
   * ServiceInsurance findFirstOrThrow
   */
  export type ServiceInsuranceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInsurance
     */
    select?: ServiceInsuranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInsurance
     */
    omit?: ServiceInsuranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInsuranceInclude<ExtArgs> | null
    /**
     * Filter, which ServiceInsurance to fetch.
     */
    where?: ServiceInsuranceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceInsurances to fetch.
     */
    orderBy?: ServiceInsuranceOrderByWithRelationInput | ServiceInsuranceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceInsurances.
     */
    cursor?: ServiceInsuranceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceInsurances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceInsurances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceInsurances.
     */
    distinct?: ServiceInsuranceScalarFieldEnum | ServiceInsuranceScalarFieldEnum[]
  }

  /**
   * ServiceInsurance findMany
   */
  export type ServiceInsuranceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInsurance
     */
    select?: ServiceInsuranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInsurance
     */
    omit?: ServiceInsuranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInsuranceInclude<ExtArgs> | null
    /**
     * Filter, which ServiceInsurances to fetch.
     */
    where?: ServiceInsuranceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceInsurances to fetch.
     */
    orderBy?: ServiceInsuranceOrderByWithRelationInput | ServiceInsuranceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceInsurances.
     */
    cursor?: ServiceInsuranceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceInsurances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceInsurances.
     */
    skip?: number
    distinct?: ServiceInsuranceScalarFieldEnum | ServiceInsuranceScalarFieldEnum[]
  }

  /**
   * ServiceInsurance create
   */
  export type ServiceInsuranceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInsurance
     */
    select?: ServiceInsuranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInsurance
     */
    omit?: ServiceInsuranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInsuranceInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceInsurance.
     */
    data: XOR<ServiceInsuranceCreateInput, ServiceInsuranceUncheckedCreateInput>
  }

  /**
   * ServiceInsurance createMany
   */
  export type ServiceInsuranceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceInsurances.
     */
    data: ServiceInsuranceCreateManyInput | ServiceInsuranceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceInsurance createManyAndReturn
   */
  export type ServiceInsuranceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInsurance
     */
    select?: ServiceInsuranceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInsurance
     */
    omit?: ServiceInsuranceOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceInsurances.
     */
    data: ServiceInsuranceCreateManyInput | ServiceInsuranceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInsuranceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceInsurance update
   */
  export type ServiceInsuranceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInsurance
     */
    select?: ServiceInsuranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInsurance
     */
    omit?: ServiceInsuranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInsuranceInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceInsurance.
     */
    data: XOR<ServiceInsuranceUpdateInput, ServiceInsuranceUncheckedUpdateInput>
    /**
     * Choose, which ServiceInsurance to update.
     */
    where: ServiceInsuranceWhereUniqueInput
  }

  /**
   * ServiceInsurance updateMany
   */
  export type ServiceInsuranceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceInsurances.
     */
    data: XOR<ServiceInsuranceUpdateManyMutationInput, ServiceInsuranceUncheckedUpdateManyInput>
    /**
     * Filter which ServiceInsurances to update
     */
    where?: ServiceInsuranceWhereInput
    /**
     * Limit how many ServiceInsurances to update.
     */
    limit?: number
  }

  /**
   * ServiceInsurance updateManyAndReturn
   */
  export type ServiceInsuranceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInsurance
     */
    select?: ServiceInsuranceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInsurance
     */
    omit?: ServiceInsuranceOmit<ExtArgs> | null
    /**
     * The data used to update ServiceInsurances.
     */
    data: XOR<ServiceInsuranceUpdateManyMutationInput, ServiceInsuranceUncheckedUpdateManyInput>
    /**
     * Filter which ServiceInsurances to update
     */
    where?: ServiceInsuranceWhereInput
    /**
     * Limit how many ServiceInsurances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInsuranceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceInsurance upsert
   */
  export type ServiceInsuranceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInsurance
     */
    select?: ServiceInsuranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInsurance
     */
    omit?: ServiceInsuranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInsuranceInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceInsurance to update in case it exists.
     */
    where: ServiceInsuranceWhereUniqueInput
    /**
     * In case the ServiceInsurance found by the `where` argument doesn't exist, create a new ServiceInsurance with this data.
     */
    create: XOR<ServiceInsuranceCreateInput, ServiceInsuranceUncheckedCreateInput>
    /**
     * In case the ServiceInsurance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceInsuranceUpdateInput, ServiceInsuranceUncheckedUpdateInput>
  }

  /**
   * ServiceInsurance delete
   */
  export type ServiceInsuranceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInsurance
     */
    select?: ServiceInsuranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInsurance
     */
    omit?: ServiceInsuranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInsuranceInclude<ExtArgs> | null
    /**
     * Filter which ServiceInsurance to delete.
     */
    where: ServiceInsuranceWhereUniqueInput
  }

  /**
   * ServiceInsurance deleteMany
   */
  export type ServiceInsuranceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceInsurances to delete
     */
    where?: ServiceInsuranceWhereInput
    /**
     * Limit how many ServiceInsurances to delete.
     */
    limit?: number
  }

  /**
   * ServiceInsurance without action
   */
  export type ServiceInsuranceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceInsurance
     */
    select?: ServiceInsuranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceInsurance
     */
    omit?: ServiceInsuranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInsuranceInclude<ExtArgs> | null
  }


  /**
   * Model OperatingHour
   */

  export type AggregateOperatingHour = {
    _count: OperatingHourCountAggregateOutputType | null
    _avg: OperatingHourAvgAggregateOutputType | null
    _sum: OperatingHourSumAggregateOutputType | null
    _min: OperatingHourMinAggregateOutputType | null
    _max: OperatingHourMaxAggregateOutputType | null
  }

  export type OperatingHourAvgAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type OperatingHourSumAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type OperatingHourMinAggregateOutputType = {
    id: string | null
    providerId: string | null
    dayOfWeek: number | null
    startTime: string | null
    endTime: string | null
    isClosed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OperatingHourMaxAggregateOutputType = {
    id: string | null
    providerId: string | null
    dayOfWeek: number | null
    startTime: string | null
    endTime: string | null
    isClosed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OperatingHourCountAggregateOutputType = {
    id: number
    providerId: number
    dayOfWeek: number
    startTime: number
    endTime: number
    isClosed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OperatingHourAvgAggregateInputType = {
    dayOfWeek?: true
  }

  export type OperatingHourSumAggregateInputType = {
    dayOfWeek?: true
  }

  export type OperatingHourMinAggregateInputType = {
    id?: true
    providerId?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    isClosed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OperatingHourMaxAggregateInputType = {
    id?: true
    providerId?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    isClosed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OperatingHourCountAggregateInputType = {
    id?: true
    providerId?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    isClosed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OperatingHourAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperatingHour to aggregate.
     */
    where?: OperatingHourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperatingHours to fetch.
     */
    orderBy?: OperatingHourOrderByWithRelationInput | OperatingHourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OperatingHourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperatingHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperatingHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OperatingHours
    **/
    _count?: true | OperatingHourCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OperatingHourAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OperatingHourSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperatingHourMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperatingHourMaxAggregateInputType
  }

  export type GetOperatingHourAggregateType<T extends OperatingHourAggregateArgs> = {
        [P in keyof T & keyof AggregateOperatingHour]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperatingHour[P]>
      : GetScalarType<T[P], AggregateOperatingHour[P]>
  }




  export type OperatingHourGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperatingHourWhereInput
    orderBy?: OperatingHourOrderByWithAggregationInput | OperatingHourOrderByWithAggregationInput[]
    by: OperatingHourScalarFieldEnum[] | OperatingHourScalarFieldEnum
    having?: OperatingHourScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperatingHourCountAggregateInputType | true
    _avg?: OperatingHourAvgAggregateInputType
    _sum?: OperatingHourSumAggregateInputType
    _min?: OperatingHourMinAggregateInputType
    _max?: OperatingHourMaxAggregateInputType
  }

  export type OperatingHourGroupByOutputType = {
    id: string
    providerId: string
    dayOfWeek: number
    startTime: string | null
    endTime: string | null
    isClosed: boolean
    createdAt: Date
    updatedAt: Date
    _count: OperatingHourCountAggregateOutputType | null
    _avg: OperatingHourAvgAggregateOutputType | null
    _sum: OperatingHourSumAggregateOutputType | null
    _min: OperatingHourMinAggregateOutputType | null
    _max: OperatingHourMaxAggregateOutputType | null
  }

  type GetOperatingHourGroupByPayload<T extends OperatingHourGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperatingHourGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperatingHourGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperatingHourGroupByOutputType[P]>
            : GetScalarType<T[P], OperatingHourGroupByOutputType[P]>
        }
      >
    >


  export type OperatingHourSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    isClosed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operatingHour"]>

  export type OperatingHourSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    isClosed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operatingHour"]>

  export type OperatingHourSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    isClosed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operatingHour"]>

  export type OperatingHourSelectScalar = {
    id?: boolean
    providerId?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    isClosed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OperatingHourOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "providerId" | "dayOfWeek" | "startTime" | "endTime" | "isClosed" | "createdAt" | "updatedAt", ExtArgs["result"]["operatingHour"]>
  export type OperatingHourInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }
  export type OperatingHourIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }
  export type OperatingHourIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }

  export type $OperatingHourPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OperatingHour"
    objects: {
      provider: Prisma.$ProviderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      providerId: string
      dayOfWeek: number
      startTime: string | null
      endTime: string | null
      isClosed: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["operatingHour"]>
    composites: {}
  }

  type OperatingHourGetPayload<S extends boolean | null | undefined | OperatingHourDefaultArgs> = $Result.GetResult<Prisma.$OperatingHourPayload, S>

  type OperatingHourCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OperatingHourFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OperatingHourCountAggregateInputType | true
    }

  export interface OperatingHourDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OperatingHour'], meta: { name: 'OperatingHour' } }
    /**
     * Find zero or one OperatingHour that matches the filter.
     * @param {OperatingHourFindUniqueArgs} args - Arguments to find a OperatingHour
     * @example
     * // Get one OperatingHour
     * const operatingHour = await prisma.operatingHour.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OperatingHourFindUniqueArgs>(args: SelectSubset<T, OperatingHourFindUniqueArgs<ExtArgs>>): Prisma__OperatingHourClient<$Result.GetResult<Prisma.$OperatingHourPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OperatingHour that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OperatingHourFindUniqueOrThrowArgs} args - Arguments to find a OperatingHour
     * @example
     * // Get one OperatingHour
     * const operatingHour = await prisma.operatingHour.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OperatingHourFindUniqueOrThrowArgs>(args: SelectSubset<T, OperatingHourFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OperatingHourClient<$Result.GetResult<Prisma.$OperatingHourPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OperatingHour that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatingHourFindFirstArgs} args - Arguments to find a OperatingHour
     * @example
     * // Get one OperatingHour
     * const operatingHour = await prisma.operatingHour.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OperatingHourFindFirstArgs>(args?: SelectSubset<T, OperatingHourFindFirstArgs<ExtArgs>>): Prisma__OperatingHourClient<$Result.GetResult<Prisma.$OperatingHourPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OperatingHour that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatingHourFindFirstOrThrowArgs} args - Arguments to find a OperatingHour
     * @example
     * // Get one OperatingHour
     * const operatingHour = await prisma.operatingHour.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OperatingHourFindFirstOrThrowArgs>(args?: SelectSubset<T, OperatingHourFindFirstOrThrowArgs<ExtArgs>>): Prisma__OperatingHourClient<$Result.GetResult<Prisma.$OperatingHourPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OperatingHours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatingHourFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OperatingHours
     * const operatingHours = await prisma.operatingHour.findMany()
     * 
     * // Get first 10 OperatingHours
     * const operatingHours = await prisma.operatingHour.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operatingHourWithIdOnly = await prisma.operatingHour.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OperatingHourFindManyArgs>(args?: SelectSubset<T, OperatingHourFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperatingHourPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OperatingHour.
     * @param {OperatingHourCreateArgs} args - Arguments to create a OperatingHour.
     * @example
     * // Create one OperatingHour
     * const OperatingHour = await prisma.operatingHour.create({
     *   data: {
     *     // ... data to create a OperatingHour
     *   }
     * })
     * 
     */
    create<T extends OperatingHourCreateArgs>(args: SelectSubset<T, OperatingHourCreateArgs<ExtArgs>>): Prisma__OperatingHourClient<$Result.GetResult<Prisma.$OperatingHourPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OperatingHours.
     * @param {OperatingHourCreateManyArgs} args - Arguments to create many OperatingHours.
     * @example
     * // Create many OperatingHours
     * const operatingHour = await prisma.operatingHour.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OperatingHourCreateManyArgs>(args?: SelectSubset<T, OperatingHourCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OperatingHours and returns the data saved in the database.
     * @param {OperatingHourCreateManyAndReturnArgs} args - Arguments to create many OperatingHours.
     * @example
     * // Create many OperatingHours
     * const operatingHour = await prisma.operatingHour.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OperatingHours and only return the `id`
     * const operatingHourWithIdOnly = await prisma.operatingHour.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OperatingHourCreateManyAndReturnArgs>(args?: SelectSubset<T, OperatingHourCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperatingHourPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OperatingHour.
     * @param {OperatingHourDeleteArgs} args - Arguments to delete one OperatingHour.
     * @example
     * // Delete one OperatingHour
     * const OperatingHour = await prisma.operatingHour.delete({
     *   where: {
     *     // ... filter to delete one OperatingHour
     *   }
     * })
     * 
     */
    delete<T extends OperatingHourDeleteArgs>(args: SelectSubset<T, OperatingHourDeleteArgs<ExtArgs>>): Prisma__OperatingHourClient<$Result.GetResult<Prisma.$OperatingHourPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OperatingHour.
     * @param {OperatingHourUpdateArgs} args - Arguments to update one OperatingHour.
     * @example
     * // Update one OperatingHour
     * const operatingHour = await prisma.operatingHour.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OperatingHourUpdateArgs>(args: SelectSubset<T, OperatingHourUpdateArgs<ExtArgs>>): Prisma__OperatingHourClient<$Result.GetResult<Prisma.$OperatingHourPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OperatingHours.
     * @param {OperatingHourDeleteManyArgs} args - Arguments to filter OperatingHours to delete.
     * @example
     * // Delete a few OperatingHours
     * const { count } = await prisma.operatingHour.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OperatingHourDeleteManyArgs>(args?: SelectSubset<T, OperatingHourDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OperatingHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatingHourUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OperatingHours
     * const operatingHour = await prisma.operatingHour.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OperatingHourUpdateManyArgs>(args: SelectSubset<T, OperatingHourUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OperatingHours and returns the data updated in the database.
     * @param {OperatingHourUpdateManyAndReturnArgs} args - Arguments to update many OperatingHours.
     * @example
     * // Update many OperatingHours
     * const operatingHour = await prisma.operatingHour.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OperatingHours and only return the `id`
     * const operatingHourWithIdOnly = await prisma.operatingHour.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OperatingHourUpdateManyAndReturnArgs>(args: SelectSubset<T, OperatingHourUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperatingHourPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OperatingHour.
     * @param {OperatingHourUpsertArgs} args - Arguments to update or create a OperatingHour.
     * @example
     * // Update or create a OperatingHour
     * const operatingHour = await prisma.operatingHour.upsert({
     *   create: {
     *     // ... data to create a OperatingHour
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OperatingHour we want to update
     *   }
     * })
     */
    upsert<T extends OperatingHourUpsertArgs>(args: SelectSubset<T, OperatingHourUpsertArgs<ExtArgs>>): Prisma__OperatingHourClient<$Result.GetResult<Prisma.$OperatingHourPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OperatingHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatingHourCountArgs} args - Arguments to filter OperatingHours to count.
     * @example
     * // Count the number of OperatingHours
     * const count = await prisma.operatingHour.count({
     *   where: {
     *     // ... the filter for the OperatingHours we want to count
     *   }
     * })
    **/
    count<T extends OperatingHourCountArgs>(
      args?: Subset<T, OperatingHourCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperatingHourCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OperatingHour.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatingHourAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperatingHourAggregateArgs>(args: Subset<T, OperatingHourAggregateArgs>): Prisma.PrismaPromise<GetOperatingHourAggregateType<T>>

    /**
     * Group by OperatingHour.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatingHourGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OperatingHourGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OperatingHourGroupByArgs['orderBy'] }
        : { orderBy?: OperatingHourGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OperatingHourGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperatingHourGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OperatingHour model
   */
  readonly fields: OperatingHourFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OperatingHour.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OperatingHourClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    provider<T extends ProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProviderDefaultArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OperatingHour model
   */
  interface OperatingHourFieldRefs {
    readonly id: FieldRef<"OperatingHour", 'String'>
    readonly providerId: FieldRef<"OperatingHour", 'String'>
    readonly dayOfWeek: FieldRef<"OperatingHour", 'Int'>
    readonly startTime: FieldRef<"OperatingHour", 'String'>
    readonly endTime: FieldRef<"OperatingHour", 'String'>
    readonly isClosed: FieldRef<"OperatingHour", 'Boolean'>
    readonly createdAt: FieldRef<"OperatingHour", 'DateTime'>
    readonly updatedAt: FieldRef<"OperatingHour", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OperatingHour findUnique
   */
  export type OperatingHourFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatingHour
     */
    select?: OperatingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperatingHour
     */
    omit?: OperatingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatingHourInclude<ExtArgs> | null
    /**
     * Filter, which OperatingHour to fetch.
     */
    where: OperatingHourWhereUniqueInput
  }

  /**
   * OperatingHour findUniqueOrThrow
   */
  export type OperatingHourFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatingHour
     */
    select?: OperatingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperatingHour
     */
    omit?: OperatingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatingHourInclude<ExtArgs> | null
    /**
     * Filter, which OperatingHour to fetch.
     */
    where: OperatingHourWhereUniqueInput
  }

  /**
   * OperatingHour findFirst
   */
  export type OperatingHourFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatingHour
     */
    select?: OperatingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperatingHour
     */
    omit?: OperatingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatingHourInclude<ExtArgs> | null
    /**
     * Filter, which OperatingHour to fetch.
     */
    where?: OperatingHourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperatingHours to fetch.
     */
    orderBy?: OperatingHourOrderByWithRelationInput | OperatingHourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperatingHours.
     */
    cursor?: OperatingHourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperatingHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperatingHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperatingHours.
     */
    distinct?: OperatingHourScalarFieldEnum | OperatingHourScalarFieldEnum[]
  }

  /**
   * OperatingHour findFirstOrThrow
   */
  export type OperatingHourFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatingHour
     */
    select?: OperatingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperatingHour
     */
    omit?: OperatingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatingHourInclude<ExtArgs> | null
    /**
     * Filter, which OperatingHour to fetch.
     */
    where?: OperatingHourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperatingHours to fetch.
     */
    orderBy?: OperatingHourOrderByWithRelationInput | OperatingHourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperatingHours.
     */
    cursor?: OperatingHourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperatingHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperatingHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperatingHours.
     */
    distinct?: OperatingHourScalarFieldEnum | OperatingHourScalarFieldEnum[]
  }

  /**
   * OperatingHour findMany
   */
  export type OperatingHourFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatingHour
     */
    select?: OperatingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperatingHour
     */
    omit?: OperatingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatingHourInclude<ExtArgs> | null
    /**
     * Filter, which OperatingHours to fetch.
     */
    where?: OperatingHourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperatingHours to fetch.
     */
    orderBy?: OperatingHourOrderByWithRelationInput | OperatingHourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OperatingHours.
     */
    cursor?: OperatingHourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperatingHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperatingHours.
     */
    skip?: number
    distinct?: OperatingHourScalarFieldEnum | OperatingHourScalarFieldEnum[]
  }

  /**
   * OperatingHour create
   */
  export type OperatingHourCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatingHour
     */
    select?: OperatingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperatingHour
     */
    omit?: OperatingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatingHourInclude<ExtArgs> | null
    /**
     * The data needed to create a OperatingHour.
     */
    data: XOR<OperatingHourCreateInput, OperatingHourUncheckedCreateInput>
  }

  /**
   * OperatingHour createMany
   */
  export type OperatingHourCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OperatingHours.
     */
    data: OperatingHourCreateManyInput | OperatingHourCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OperatingHour createManyAndReturn
   */
  export type OperatingHourCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatingHour
     */
    select?: OperatingHourSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OperatingHour
     */
    omit?: OperatingHourOmit<ExtArgs> | null
    /**
     * The data used to create many OperatingHours.
     */
    data: OperatingHourCreateManyInput | OperatingHourCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatingHourIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OperatingHour update
   */
  export type OperatingHourUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatingHour
     */
    select?: OperatingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperatingHour
     */
    omit?: OperatingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatingHourInclude<ExtArgs> | null
    /**
     * The data needed to update a OperatingHour.
     */
    data: XOR<OperatingHourUpdateInput, OperatingHourUncheckedUpdateInput>
    /**
     * Choose, which OperatingHour to update.
     */
    where: OperatingHourWhereUniqueInput
  }

  /**
   * OperatingHour updateMany
   */
  export type OperatingHourUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OperatingHours.
     */
    data: XOR<OperatingHourUpdateManyMutationInput, OperatingHourUncheckedUpdateManyInput>
    /**
     * Filter which OperatingHours to update
     */
    where?: OperatingHourWhereInput
    /**
     * Limit how many OperatingHours to update.
     */
    limit?: number
  }

  /**
   * OperatingHour updateManyAndReturn
   */
  export type OperatingHourUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatingHour
     */
    select?: OperatingHourSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OperatingHour
     */
    omit?: OperatingHourOmit<ExtArgs> | null
    /**
     * The data used to update OperatingHours.
     */
    data: XOR<OperatingHourUpdateManyMutationInput, OperatingHourUncheckedUpdateManyInput>
    /**
     * Filter which OperatingHours to update
     */
    where?: OperatingHourWhereInput
    /**
     * Limit how many OperatingHours to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatingHourIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OperatingHour upsert
   */
  export type OperatingHourUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatingHour
     */
    select?: OperatingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperatingHour
     */
    omit?: OperatingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatingHourInclude<ExtArgs> | null
    /**
     * The filter to search for the OperatingHour to update in case it exists.
     */
    where: OperatingHourWhereUniqueInput
    /**
     * In case the OperatingHour found by the `where` argument doesn't exist, create a new OperatingHour with this data.
     */
    create: XOR<OperatingHourCreateInput, OperatingHourUncheckedCreateInput>
    /**
     * In case the OperatingHour was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OperatingHourUpdateInput, OperatingHourUncheckedUpdateInput>
  }

  /**
   * OperatingHour delete
   */
  export type OperatingHourDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatingHour
     */
    select?: OperatingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperatingHour
     */
    omit?: OperatingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatingHourInclude<ExtArgs> | null
    /**
     * Filter which OperatingHour to delete.
     */
    where: OperatingHourWhereUniqueInput
  }

  /**
   * OperatingHour deleteMany
   */
  export type OperatingHourDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperatingHours to delete
     */
    where?: OperatingHourWhereInput
    /**
     * Limit how many OperatingHours to delete.
     */
    limit?: number
  }

  /**
   * OperatingHour without action
   */
  export type OperatingHourDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatingHour
     */
    select?: OperatingHourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperatingHour
     */
    omit?: OperatingHourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatingHourInclude<ExtArgs> | null
  }


  /**
   * Model BreakTime
   */

  export type AggregateBreakTime = {
    _count: BreakTimeCountAggregateOutputType | null
    _avg: BreakTimeAvgAggregateOutputType | null
    _sum: BreakTimeSumAggregateOutputType | null
    _min: BreakTimeMinAggregateOutputType | null
    _max: BreakTimeMaxAggregateOutputType | null
  }

  export type BreakTimeAvgAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type BreakTimeSumAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type BreakTimeMinAggregateOutputType = {
    id: string | null
    providerId: string | null
    name: string | null
    dayOfWeek: number | null
    startTime: string | null
    endTime: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BreakTimeMaxAggregateOutputType = {
    id: string | null
    providerId: string | null
    name: string | null
    dayOfWeek: number | null
    startTime: string | null
    endTime: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BreakTimeCountAggregateOutputType = {
    id: number
    providerId: number
    name: number
    dayOfWeek: number
    startTime: number
    endTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BreakTimeAvgAggregateInputType = {
    dayOfWeek?: true
  }

  export type BreakTimeSumAggregateInputType = {
    dayOfWeek?: true
  }

  export type BreakTimeMinAggregateInputType = {
    id?: true
    providerId?: true
    name?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BreakTimeMaxAggregateInputType = {
    id?: true
    providerId?: true
    name?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BreakTimeCountAggregateInputType = {
    id?: true
    providerId?: true
    name?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BreakTimeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BreakTime to aggregate.
     */
    where?: BreakTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreakTimes to fetch.
     */
    orderBy?: BreakTimeOrderByWithRelationInput | BreakTimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BreakTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreakTimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreakTimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BreakTimes
    **/
    _count?: true | BreakTimeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BreakTimeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BreakTimeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BreakTimeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BreakTimeMaxAggregateInputType
  }

  export type GetBreakTimeAggregateType<T extends BreakTimeAggregateArgs> = {
        [P in keyof T & keyof AggregateBreakTime]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBreakTime[P]>
      : GetScalarType<T[P], AggregateBreakTime[P]>
  }




  export type BreakTimeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BreakTimeWhereInput
    orderBy?: BreakTimeOrderByWithAggregationInput | BreakTimeOrderByWithAggregationInput[]
    by: BreakTimeScalarFieldEnum[] | BreakTimeScalarFieldEnum
    having?: BreakTimeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BreakTimeCountAggregateInputType | true
    _avg?: BreakTimeAvgAggregateInputType
    _sum?: BreakTimeSumAggregateInputType
    _min?: BreakTimeMinAggregateInputType
    _max?: BreakTimeMaxAggregateInputType
  }

  export type BreakTimeGroupByOutputType = {
    id: string
    providerId: string
    name: string
    dayOfWeek: number
    startTime: string
    endTime: string
    createdAt: Date
    updatedAt: Date
    _count: BreakTimeCountAggregateOutputType | null
    _avg: BreakTimeAvgAggregateOutputType | null
    _sum: BreakTimeSumAggregateOutputType | null
    _min: BreakTimeMinAggregateOutputType | null
    _max: BreakTimeMaxAggregateOutputType | null
  }

  type GetBreakTimeGroupByPayload<T extends BreakTimeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BreakTimeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BreakTimeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BreakTimeGroupByOutputType[P]>
            : GetScalarType<T[P], BreakTimeGroupByOutputType[P]>
        }
      >
    >


  export type BreakTimeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    name?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["breakTime"]>

  export type BreakTimeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    name?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["breakTime"]>

  export type BreakTimeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    name?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["breakTime"]>

  export type BreakTimeSelectScalar = {
    id?: boolean
    providerId?: boolean
    name?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BreakTimeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "providerId" | "name" | "dayOfWeek" | "startTime" | "endTime" | "createdAt" | "updatedAt", ExtArgs["result"]["breakTime"]>
  export type BreakTimeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }
  export type BreakTimeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }
  export type BreakTimeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }

  export type $BreakTimePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BreakTime"
    objects: {
      provider: Prisma.$ProviderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      providerId: string
      name: string
      dayOfWeek: number
      startTime: string
      endTime: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["breakTime"]>
    composites: {}
  }

  type BreakTimeGetPayload<S extends boolean | null | undefined | BreakTimeDefaultArgs> = $Result.GetResult<Prisma.$BreakTimePayload, S>

  type BreakTimeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BreakTimeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BreakTimeCountAggregateInputType | true
    }

  export interface BreakTimeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BreakTime'], meta: { name: 'BreakTime' } }
    /**
     * Find zero or one BreakTime that matches the filter.
     * @param {BreakTimeFindUniqueArgs} args - Arguments to find a BreakTime
     * @example
     * // Get one BreakTime
     * const breakTime = await prisma.breakTime.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BreakTimeFindUniqueArgs>(args: SelectSubset<T, BreakTimeFindUniqueArgs<ExtArgs>>): Prisma__BreakTimeClient<$Result.GetResult<Prisma.$BreakTimePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BreakTime that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BreakTimeFindUniqueOrThrowArgs} args - Arguments to find a BreakTime
     * @example
     * // Get one BreakTime
     * const breakTime = await prisma.breakTime.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BreakTimeFindUniqueOrThrowArgs>(args: SelectSubset<T, BreakTimeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BreakTimeClient<$Result.GetResult<Prisma.$BreakTimePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BreakTime that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreakTimeFindFirstArgs} args - Arguments to find a BreakTime
     * @example
     * // Get one BreakTime
     * const breakTime = await prisma.breakTime.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BreakTimeFindFirstArgs>(args?: SelectSubset<T, BreakTimeFindFirstArgs<ExtArgs>>): Prisma__BreakTimeClient<$Result.GetResult<Prisma.$BreakTimePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BreakTime that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreakTimeFindFirstOrThrowArgs} args - Arguments to find a BreakTime
     * @example
     * // Get one BreakTime
     * const breakTime = await prisma.breakTime.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BreakTimeFindFirstOrThrowArgs>(args?: SelectSubset<T, BreakTimeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BreakTimeClient<$Result.GetResult<Prisma.$BreakTimePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BreakTimes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreakTimeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BreakTimes
     * const breakTimes = await prisma.breakTime.findMany()
     * 
     * // Get first 10 BreakTimes
     * const breakTimes = await prisma.breakTime.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const breakTimeWithIdOnly = await prisma.breakTime.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BreakTimeFindManyArgs>(args?: SelectSubset<T, BreakTimeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreakTimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BreakTime.
     * @param {BreakTimeCreateArgs} args - Arguments to create a BreakTime.
     * @example
     * // Create one BreakTime
     * const BreakTime = await prisma.breakTime.create({
     *   data: {
     *     // ... data to create a BreakTime
     *   }
     * })
     * 
     */
    create<T extends BreakTimeCreateArgs>(args: SelectSubset<T, BreakTimeCreateArgs<ExtArgs>>): Prisma__BreakTimeClient<$Result.GetResult<Prisma.$BreakTimePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BreakTimes.
     * @param {BreakTimeCreateManyArgs} args - Arguments to create many BreakTimes.
     * @example
     * // Create many BreakTimes
     * const breakTime = await prisma.breakTime.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BreakTimeCreateManyArgs>(args?: SelectSubset<T, BreakTimeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BreakTimes and returns the data saved in the database.
     * @param {BreakTimeCreateManyAndReturnArgs} args - Arguments to create many BreakTimes.
     * @example
     * // Create many BreakTimes
     * const breakTime = await prisma.breakTime.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BreakTimes and only return the `id`
     * const breakTimeWithIdOnly = await prisma.breakTime.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BreakTimeCreateManyAndReturnArgs>(args?: SelectSubset<T, BreakTimeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreakTimePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BreakTime.
     * @param {BreakTimeDeleteArgs} args - Arguments to delete one BreakTime.
     * @example
     * // Delete one BreakTime
     * const BreakTime = await prisma.breakTime.delete({
     *   where: {
     *     // ... filter to delete one BreakTime
     *   }
     * })
     * 
     */
    delete<T extends BreakTimeDeleteArgs>(args: SelectSubset<T, BreakTimeDeleteArgs<ExtArgs>>): Prisma__BreakTimeClient<$Result.GetResult<Prisma.$BreakTimePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BreakTime.
     * @param {BreakTimeUpdateArgs} args - Arguments to update one BreakTime.
     * @example
     * // Update one BreakTime
     * const breakTime = await prisma.breakTime.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BreakTimeUpdateArgs>(args: SelectSubset<T, BreakTimeUpdateArgs<ExtArgs>>): Prisma__BreakTimeClient<$Result.GetResult<Prisma.$BreakTimePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BreakTimes.
     * @param {BreakTimeDeleteManyArgs} args - Arguments to filter BreakTimes to delete.
     * @example
     * // Delete a few BreakTimes
     * const { count } = await prisma.breakTime.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BreakTimeDeleteManyArgs>(args?: SelectSubset<T, BreakTimeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BreakTimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreakTimeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BreakTimes
     * const breakTime = await prisma.breakTime.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BreakTimeUpdateManyArgs>(args: SelectSubset<T, BreakTimeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BreakTimes and returns the data updated in the database.
     * @param {BreakTimeUpdateManyAndReturnArgs} args - Arguments to update many BreakTimes.
     * @example
     * // Update many BreakTimes
     * const breakTime = await prisma.breakTime.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BreakTimes and only return the `id`
     * const breakTimeWithIdOnly = await prisma.breakTime.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BreakTimeUpdateManyAndReturnArgs>(args: SelectSubset<T, BreakTimeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BreakTimePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BreakTime.
     * @param {BreakTimeUpsertArgs} args - Arguments to update or create a BreakTime.
     * @example
     * // Update or create a BreakTime
     * const breakTime = await prisma.breakTime.upsert({
     *   create: {
     *     // ... data to create a BreakTime
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BreakTime we want to update
     *   }
     * })
     */
    upsert<T extends BreakTimeUpsertArgs>(args: SelectSubset<T, BreakTimeUpsertArgs<ExtArgs>>): Prisma__BreakTimeClient<$Result.GetResult<Prisma.$BreakTimePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BreakTimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreakTimeCountArgs} args - Arguments to filter BreakTimes to count.
     * @example
     * // Count the number of BreakTimes
     * const count = await prisma.breakTime.count({
     *   where: {
     *     // ... the filter for the BreakTimes we want to count
     *   }
     * })
    **/
    count<T extends BreakTimeCountArgs>(
      args?: Subset<T, BreakTimeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BreakTimeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BreakTime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreakTimeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BreakTimeAggregateArgs>(args: Subset<T, BreakTimeAggregateArgs>): Prisma.PrismaPromise<GetBreakTimeAggregateType<T>>

    /**
     * Group by BreakTime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BreakTimeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BreakTimeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BreakTimeGroupByArgs['orderBy'] }
        : { orderBy?: BreakTimeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BreakTimeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBreakTimeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BreakTime model
   */
  readonly fields: BreakTimeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BreakTime.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BreakTimeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    provider<T extends ProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProviderDefaultArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BreakTime model
   */
  interface BreakTimeFieldRefs {
    readonly id: FieldRef<"BreakTime", 'String'>
    readonly providerId: FieldRef<"BreakTime", 'String'>
    readonly name: FieldRef<"BreakTime", 'String'>
    readonly dayOfWeek: FieldRef<"BreakTime", 'Int'>
    readonly startTime: FieldRef<"BreakTime", 'String'>
    readonly endTime: FieldRef<"BreakTime", 'String'>
    readonly createdAt: FieldRef<"BreakTime", 'DateTime'>
    readonly updatedAt: FieldRef<"BreakTime", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BreakTime findUnique
   */
  export type BreakTimeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakTime
     */
    select?: BreakTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreakTime
     */
    omit?: BreakTimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakTimeInclude<ExtArgs> | null
    /**
     * Filter, which BreakTime to fetch.
     */
    where: BreakTimeWhereUniqueInput
  }

  /**
   * BreakTime findUniqueOrThrow
   */
  export type BreakTimeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakTime
     */
    select?: BreakTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreakTime
     */
    omit?: BreakTimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakTimeInclude<ExtArgs> | null
    /**
     * Filter, which BreakTime to fetch.
     */
    where: BreakTimeWhereUniqueInput
  }

  /**
   * BreakTime findFirst
   */
  export type BreakTimeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakTime
     */
    select?: BreakTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreakTime
     */
    omit?: BreakTimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakTimeInclude<ExtArgs> | null
    /**
     * Filter, which BreakTime to fetch.
     */
    where?: BreakTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreakTimes to fetch.
     */
    orderBy?: BreakTimeOrderByWithRelationInput | BreakTimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BreakTimes.
     */
    cursor?: BreakTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreakTimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreakTimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BreakTimes.
     */
    distinct?: BreakTimeScalarFieldEnum | BreakTimeScalarFieldEnum[]
  }

  /**
   * BreakTime findFirstOrThrow
   */
  export type BreakTimeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakTime
     */
    select?: BreakTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreakTime
     */
    omit?: BreakTimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakTimeInclude<ExtArgs> | null
    /**
     * Filter, which BreakTime to fetch.
     */
    where?: BreakTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreakTimes to fetch.
     */
    orderBy?: BreakTimeOrderByWithRelationInput | BreakTimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BreakTimes.
     */
    cursor?: BreakTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreakTimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreakTimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BreakTimes.
     */
    distinct?: BreakTimeScalarFieldEnum | BreakTimeScalarFieldEnum[]
  }

  /**
   * BreakTime findMany
   */
  export type BreakTimeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakTime
     */
    select?: BreakTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreakTime
     */
    omit?: BreakTimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakTimeInclude<ExtArgs> | null
    /**
     * Filter, which BreakTimes to fetch.
     */
    where?: BreakTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BreakTimes to fetch.
     */
    orderBy?: BreakTimeOrderByWithRelationInput | BreakTimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BreakTimes.
     */
    cursor?: BreakTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BreakTimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BreakTimes.
     */
    skip?: number
    distinct?: BreakTimeScalarFieldEnum | BreakTimeScalarFieldEnum[]
  }

  /**
   * BreakTime create
   */
  export type BreakTimeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakTime
     */
    select?: BreakTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreakTime
     */
    omit?: BreakTimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakTimeInclude<ExtArgs> | null
    /**
     * The data needed to create a BreakTime.
     */
    data: XOR<BreakTimeCreateInput, BreakTimeUncheckedCreateInput>
  }

  /**
   * BreakTime createMany
   */
  export type BreakTimeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BreakTimes.
     */
    data: BreakTimeCreateManyInput | BreakTimeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BreakTime createManyAndReturn
   */
  export type BreakTimeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakTime
     */
    select?: BreakTimeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BreakTime
     */
    omit?: BreakTimeOmit<ExtArgs> | null
    /**
     * The data used to create many BreakTimes.
     */
    data: BreakTimeCreateManyInput | BreakTimeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakTimeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BreakTime update
   */
  export type BreakTimeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakTime
     */
    select?: BreakTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreakTime
     */
    omit?: BreakTimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakTimeInclude<ExtArgs> | null
    /**
     * The data needed to update a BreakTime.
     */
    data: XOR<BreakTimeUpdateInput, BreakTimeUncheckedUpdateInput>
    /**
     * Choose, which BreakTime to update.
     */
    where: BreakTimeWhereUniqueInput
  }

  /**
   * BreakTime updateMany
   */
  export type BreakTimeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BreakTimes.
     */
    data: XOR<BreakTimeUpdateManyMutationInput, BreakTimeUncheckedUpdateManyInput>
    /**
     * Filter which BreakTimes to update
     */
    where?: BreakTimeWhereInput
    /**
     * Limit how many BreakTimes to update.
     */
    limit?: number
  }

  /**
   * BreakTime updateManyAndReturn
   */
  export type BreakTimeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakTime
     */
    select?: BreakTimeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BreakTime
     */
    omit?: BreakTimeOmit<ExtArgs> | null
    /**
     * The data used to update BreakTimes.
     */
    data: XOR<BreakTimeUpdateManyMutationInput, BreakTimeUncheckedUpdateManyInput>
    /**
     * Filter which BreakTimes to update
     */
    where?: BreakTimeWhereInput
    /**
     * Limit how many BreakTimes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakTimeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BreakTime upsert
   */
  export type BreakTimeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakTime
     */
    select?: BreakTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreakTime
     */
    omit?: BreakTimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakTimeInclude<ExtArgs> | null
    /**
     * The filter to search for the BreakTime to update in case it exists.
     */
    where: BreakTimeWhereUniqueInput
    /**
     * In case the BreakTime found by the `where` argument doesn't exist, create a new BreakTime with this data.
     */
    create: XOR<BreakTimeCreateInput, BreakTimeUncheckedCreateInput>
    /**
     * In case the BreakTime was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BreakTimeUpdateInput, BreakTimeUncheckedUpdateInput>
  }

  /**
   * BreakTime delete
   */
  export type BreakTimeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakTime
     */
    select?: BreakTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreakTime
     */
    omit?: BreakTimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakTimeInclude<ExtArgs> | null
    /**
     * Filter which BreakTime to delete.
     */
    where: BreakTimeWhereUniqueInput
  }

  /**
   * BreakTime deleteMany
   */
  export type BreakTimeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BreakTimes to delete
     */
    where?: BreakTimeWhereInput
    /**
     * Limit how many BreakTimes to delete.
     */
    limit?: number
  }

  /**
   * BreakTime without action
   */
  export type BreakTimeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BreakTime
     */
    select?: BreakTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BreakTime
     */
    omit?: BreakTimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BreakTimeInclude<ExtArgs> | null
  }


  /**
   * Model Appointment
   */

  export type AggregateAppointment = {
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  export type AppointmentAvgAggregateOutputType = {
    totalPrice: Decimal | null
  }

  export type AppointmentSumAggregateOutputType = {
    totalPrice: Decimal | null
  }

  export type AppointmentMinAggregateOutputType = {
    id: string | null
    appointmentNumber: string | null
    userId: string | null
    providerId: string | null
    startTime: Date | null
    endTime: Date | null
    status: $Enums.AppointmentStatus | null
    notes: string | null
    totalPrice: Decimal | null
    patientName: string | null
    patientEmail: string | null
    patientPhone: string | null
    activityNotes: string | null
    cancelledAt: Date | null
    cancellationReason: string | null
    cancelledBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppointmentMaxAggregateOutputType = {
    id: string | null
    appointmentNumber: string | null
    userId: string | null
    providerId: string | null
    startTime: Date | null
    endTime: Date | null
    status: $Enums.AppointmentStatus | null
    notes: string | null
    totalPrice: Decimal | null
    patientName: string | null
    patientEmail: string | null
    patientPhone: string | null
    activityNotes: string | null
    cancelledAt: Date | null
    cancellationReason: string | null
    cancelledBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppointmentCountAggregateOutputType = {
    id: number
    appointmentNumber: number
    userId: number
    providerId: number
    startTime: number
    endTime: number
    status: number
    notes: number
    totalPrice: number
    patientName: number
    patientEmail: number
    patientPhone: number
    activityNotes: number
    cancelledAt: number
    cancellationReason: number
    cancelledBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AppointmentAvgAggregateInputType = {
    totalPrice?: true
  }

  export type AppointmentSumAggregateInputType = {
    totalPrice?: true
  }

  export type AppointmentMinAggregateInputType = {
    id?: true
    appointmentNumber?: true
    userId?: true
    providerId?: true
    startTime?: true
    endTime?: true
    status?: true
    notes?: true
    totalPrice?: true
    patientName?: true
    patientEmail?: true
    patientPhone?: true
    activityNotes?: true
    cancelledAt?: true
    cancellationReason?: true
    cancelledBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppointmentMaxAggregateInputType = {
    id?: true
    appointmentNumber?: true
    userId?: true
    providerId?: true
    startTime?: true
    endTime?: true
    status?: true
    notes?: true
    totalPrice?: true
    patientName?: true
    patientEmail?: true
    patientPhone?: true
    activityNotes?: true
    cancelledAt?: true
    cancellationReason?: true
    cancelledBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppointmentCountAggregateInputType = {
    id?: true
    appointmentNumber?: true
    userId?: true
    providerId?: true
    startTime?: true
    endTime?: true
    status?: true
    notes?: true
    totalPrice?: true
    patientName?: true
    patientEmail?: true
    patientPhone?: true
    activityNotes?: true
    cancelledAt?: true
    cancellationReason?: true
    cancelledBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AppointmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointment to aggregate.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Appointments
    **/
    _count?: true | AppointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppointmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppointmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentMaxAggregateInputType
  }

  export type GetAppointmentAggregateType<T extends AppointmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointment[P]>
      : GetScalarType<T[P], AggregateAppointment[P]>
  }




  export type AppointmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithAggregationInput | AppointmentOrderByWithAggregationInput[]
    by: AppointmentScalarFieldEnum[] | AppointmentScalarFieldEnum
    having?: AppointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentCountAggregateInputType | true
    _avg?: AppointmentAvgAggregateInputType
    _sum?: AppointmentSumAggregateInputType
    _min?: AppointmentMinAggregateInputType
    _max?: AppointmentMaxAggregateInputType
  }

  export type AppointmentGroupByOutputType = {
    id: string
    appointmentNumber: string
    userId: string
    providerId: string
    startTime: Date
    endTime: Date
    status: $Enums.AppointmentStatus
    notes: string | null
    totalPrice: Decimal
    patientName: string
    patientEmail: string
    patientPhone: string | null
    activityNotes: string | null
    cancelledAt: Date | null
    cancellationReason: string | null
    cancelledBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  type GetAppointmentGroupByPayload<T extends AppointmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
        }
      >
    >


  export type AppointmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appointmentNumber?: boolean
    userId?: boolean
    providerId?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    notes?: boolean
    totalPrice?: boolean
    patientName?: boolean
    patientEmail?: boolean
    patientPhone?: boolean
    activityNotes?: boolean
    cancelledAt?: boolean
    cancellationReason?: boolean
    cancelledBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    canceller?: boolean | Appointment$cancellerArgs<ExtArgs>
    services?: boolean | Appointment$servicesArgs<ExtArgs>
    notifications?: boolean | Appointment$notificationsArgs<ExtArgs>
    review?: boolean | Appointment$reviewArgs<ExtArgs>
    _count?: boolean | AppointmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appointmentNumber?: boolean
    userId?: boolean
    providerId?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    notes?: boolean
    totalPrice?: boolean
    patientName?: boolean
    patientEmail?: boolean
    patientPhone?: boolean
    activityNotes?: boolean
    cancelledAt?: boolean
    cancellationReason?: boolean
    cancelledBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    canceller?: boolean | Appointment$cancellerArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appointmentNumber?: boolean
    userId?: boolean
    providerId?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    notes?: boolean
    totalPrice?: boolean
    patientName?: boolean
    patientEmail?: boolean
    patientPhone?: boolean
    activityNotes?: boolean
    cancelledAt?: boolean
    cancellationReason?: boolean
    cancelledBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    canceller?: boolean | Appointment$cancellerArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectScalar = {
    id?: boolean
    appointmentNumber?: boolean
    userId?: boolean
    providerId?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    notes?: boolean
    totalPrice?: boolean
    patientName?: boolean
    patientEmail?: boolean
    patientPhone?: boolean
    activityNotes?: boolean
    cancelledAt?: boolean
    cancellationReason?: boolean
    cancelledBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AppointmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "appointmentNumber" | "userId" | "providerId" | "startTime" | "endTime" | "status" | "notes" | "totalPrice" | "patientName" | "patientEmail" | "patientPhone" | "activityNotes" | "cancelledAt" | "cancellationReason" | "cancelledBy" | "createdAt" | "updatedAt", ExtArgs["result"]["appointment"]>
  export type AppointmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    canceller?: boolean | Appointment$cancellerArgs<ExtArgs>
    services?: boolean | Appointment$servicesArgs<ExtArgs>
    notifications?: boolean | Appointment$notificationsArgs<ExtArgs>
    review?: boolean | Appointment$reviewArgs<ExtArgs>
    _count?: boolean | AppointmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AppointmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    canceller?: boolean | Appointment$cancellerArgs<ExtArgs>
  }
  export type AppointmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    canceller?: boolean | Appointment$cancellerArgs<ExtArgs>
  }

  export type $AppointmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Appointment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      provider: Prisma.$ProviderPayload<ExtArgs>
      canceller: Prisma.$UserPayload<ExtArgs> | null
      services: Prisma.$AppointmentServicePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      review: Prisma.$ReviewPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      appointmentNumber: string
      userId: string
      providerId: string
      startTime: Date
      endTime: Date
      status: $Enums.AppointmentStatus
      notes: string | null
      totalPrice: Prisma.Decimal
      patientName: string
      patientEmail: string
      patientPhone: string | null
      activityNotes: string | null
      cancelledAt: Date | null
      cancellationReason: string | null
      cancelledBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["appointment"]>
    composites: {}
  }

  type AppointmentGetPayload<S extends boolean | null | undefined | AppointmentDefaultArgs> = $Result.GetResult<Prisma.$AppointmentPayload, S>

  type AppointmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppointmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppointmentCountAggregateInputType | true
    }

  export interface AppointmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Appointment'], meta: { name: 'Appointment' } }
    /**
     * Find zero or one Appointment that matches the filter.
     * @param {AppointmentFindUniqueArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppointmentFindUniqueArgs>(args: SelectSubset<T, AppointmentFindUniqueArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Appointment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppointmentFindUniqueOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppointmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AppointmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppointmentFindFirstArgs>(args?: SelectSubset<T, AppointmentFindFirstArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppointmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AppointmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointment.findMany()
     * 
     * // Get first 10 Appointments
     * const appointments = await prisma.appointment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appointmentWithIdOnly = await prisma.appointment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppointmentFindManyArgs>(args?: SelectSubset<T, AppointmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Appointment.
     * @param {AppointmentCreateArgs} args - Arguments to create a Appointment.
     * @example
     * // Create one Appointment
     * const Appointment = await prisma.appointment.create({
     *   data: {
     *     // ... data to create a Appointment
     *   }
     * })
     * 
     */
    create<T extends AppointmentCreateArgs>(args: SelectSubset<T, AppointmentCreateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Appointments.
     * @param {AppointmentCreateManyArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppointmentCreateManyArgs>(args?: SelectSubset<T, AppointmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Appointments and returns the data saved in the database.
     * @param {AppointmentCreateManyAndReturnArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppointmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AppointmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Appointment.
     * @param {AppointmentDeleteArgs} args - Arguments to delete one Appointment.
     * @example
     * // Delete one Appointment
     * const Appointment = await prisma.appointment.delete({
     *   where: {
     *     // ... filter to delete one Appointment
     *   }
     * })
     * 
     */
    delete<T extends AppointmentDeleteArgs>(args: SelectSubset<T, AppointmentDeleteArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Appointment.
     * @param {AppointmentUpdateArgs} args - Arguments to update one Appointment.
     * @example
     * // Update one Appointment
     * const appointment = await prisma.appointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppointmentUpdateArgs>(args: SelectSubset<T, AppointmentUpdateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Appointments.
     * @param {AppointmentDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppointmentDeleteManyArgs>(args?: SelectSubset<T, AppointmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppointmentUpdateManyArgs>(args: SelectSubset<T, AppointmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments and returns the data updated in the database.
     * @param {AppointmentUpdateManyAndReturnArgs} args - Arguments to update many Appointments.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AppointmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AppointmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Appointment.
     * @param {AppointmentUpsertArgs} args - Arguments to update or create a Appointment.
     * @example
     * // Update or create a Appointment
     * const appointment = await prisma.appointment.upsert({
     *   create: {
     *     // ... data to create a Appointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointment we want to update
     *   }
     * })
     */
    upsert<T extends AppointmentUpsertArgs>(args: SelectSubset<T, AppointmentUpsertArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointment.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends AppointmentCountArgs>(
      args?: Subset<T, AppointmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentAggregateArgs>(args: Subset<T, AppointmentAggregateArgs>): Prisma.PrismaPromise<GetAppointmentAggregateType<T>>

    /**
     * Group by Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppointmentGroupByArgs['orderBy'] }
        : { orderBy?: AppointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Appointment model
   */
  readonly fields: AppointmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Appointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppointmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    provider<T extends ProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProviderDefaultArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    canceller<T extends Appointment$cancellerArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$cancellerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    services<T extends Appointment$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Appointment$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    review<T extends Appointment$reviewArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$reviewArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Appointment model
   */
  interface AppointmentFieldRefs {
    readonly id: FieldRef<"Appointment", 'String'>
    readonly appointmentNumber: FieldRef<"Appointment", 'String'>
    readonly userId: FieldRef<"Appointment", 'String'>
    readonly providerId: FieldRef<"Appointment", 'String'>
    readonly startTime: FieldRef<"Appointment", 'DateTime'>
    readonly endTime: FieldRef<"Appointment", 'DateTime'>
    readonly status: FieldRef<"Appointment", 'AppointmentStatus'>
    readonly notes: FieldRef<"Appointment", 'String'>
    readonly totalPrice: FieldRef<"Appointment", 'Decimal'>
    readonly patientName: FieldRef<"Appointment", 'String'>
    readonly patientEmail: FieldRef<"Appointment", 'String'>
    readonly patientPhone: FieldRef<"Appointment", 'String'>
    readonly activityNotes: FieldRef<"Appointment", 'String'>
    readonly cancelledAt: FieldRef<"Appointment", 'DateTime'>
    readonly cancellationReason: FieldRef<"Appointment", 'String'>
    readonly cancelledBy: FieldRef<"Appointment", 'String'>
    readonly createdAt: FieldRef<"Appointment", 'DateTime'>
    readonly updatedAt: FieldRef<"Appointment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Appointment findUnique
   */
  export type AppointmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findUniqueOrThrow
   */
  export type AppointmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findFirst
   */
  export type AppointmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findFirstOrThrow
   */
  export type AppointmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findMany
   */
  export type AppointmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointments to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment create
   */
  export type AppointmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Appointment.
     */
    data: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
  }

  /**
   * Appointment createMany
   */
  export type AppointmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Appointment createManyAndReturn
   */
  export type AppointmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment update
   */
  export type AppointmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Appointment.
     */
    data: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
    /**
     * Choose, which Appointment to update.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment updateMany
   */
  export type AppointmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to update.
     */
    limit?: number
  }

  /**
   * Appointment updateManyAndReturn
   */
  export type AppointmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment upsert
   */
  export type AppointmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Appointment to update in case it exists.
     */
    where: AppointmentWhereUniqueInput
    /**
     * In case the Appointment found by the `where` argument doesn't exist, create a new Appointment with this data.
     */
    create: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
    /**
     * In case the Appointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
  }

  /**
   * Appointment delete
   */
  export type AppointmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter which Appointment to delete.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment deleteMany
   */
  export type AppointmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointments to delete
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to delete.
     */
    limit?: number
  }

  /**
   * Appointment.canceller
   */
  export type Appointment$cancellerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Appointment.services
   */
  export type Appointment$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentService
     */
    select?: AppointmentServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppointmentService
     */
    omit?: AppointmentServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentServiceInclude<ExtArgs> | null
    where?: AppointmentServiceWhereInput
    orderBy?: AppointmentServiceOrderByWithRelationInput | AppointmentServiceOrderByWithRelationInput[]
    cursor?: AppointmentServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentServiceScalarFieldEnum | AppointmentServiceScalarFieldEnum[]
  }

  /**
   * Appointment.notifications
   */
  export type Appointment$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Appointment.review
   */
  export type Appointment$reviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
  }

  /**
   * Appointment without action
   */
  export type AppointmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
  }


  /**
   * Model AppointmentService
   */

  export type AggregateAppointmentService = {
    _count: AppointmentServiceCountAggregateOutputType | null
    _avg: AppointmentServiceAvgAggregateOutputType | null
    _sum: AppointmentServiceSumAggregateOutputType | null
    _min: AppointmentServiceMinAggregateOutputType | null
    _max: AppointmentServiceMaxAggregateOutputType | null
  }

  export type AppointmentServiceAvgAggregateOutputType = {
    priceAtBooking: Decimal | null
  }

  export type AppointmentServiceSumAggregateOutputType = {
    priceAtBooking: Decimal | null
  }

  export type AppointmentServiceMinAggregateOutputType = {
    appointmentId: string | null
    serviceId: string | null
    priceAtBooking: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppointmentServiceMaxAggregateOutputType = {
    appointmentId: string | null
    serviceId: string | null
    priceAtBooking: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppointmentServiceCountAggregateOutputType = {
    appointmentId: number
    serviceId: number
    priceAtBooking: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AppointmentServiceAvgAggregateInputType = {
    priceAtBooking?: true
  }

  export type AppointmentServiceSumAggregateInputType = {
    priceAtBooking?: true
  }

  export type AppointmentServiceMinAggregateInputType = {
    appointmentId?: true
    serviceId?: true
    priceAtBooking?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppointmentServiceMaxAggregateInputType = {
    appointmentId?: true
    serviceId?: true
    priceAtBooking?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppointmentServiceCountAggregateInputType = {
    appointmentId?: true
    serviceId?: true
    priceAtBooking?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AppointmentServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppointmentService to aggregate.
     */
    where?: AppointmentServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppointmentServices to fetch.
     */
    orderBy?: AppointmentServiceOrderByWithRelationInput | AppointmentServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppointmentServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppointmentServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppointmentServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AppointmentServices
    **/
    _count?: true | AppointmentServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppointmentServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppointmentServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentServiceMaxAggregateInputType
  }

  export type GetAppointmentServiceAggregateType<T extends AppointmentServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointmentService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointmentService[P]>
      : GetScalarType<T[P], AggregateAppointmentService[P]>
  }




  export type AppointmentServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentServiceWhereInput
    orderBy?: AppointmentServiceOrderByWithAggregationInput | AppointmentServiceOrderByWithAggregationInput[]
    by: AppointmentServiceScalarFieldEnum[] | AppointmentServiceScalarFieldEnum
    having?: AppointmentServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentServiceCountAggregateInputType | true
    _avg?: AppointmentServiceAvgAggregateInputType
    _sum?: AppointmentServiceSumAggregateInputType
    _min?: AppointmentServiceMinAggregateInputType
    _max?: AppointmentServiceMaxAggregateInputType
  }

  export type AppointmentServiceGroupByOutputType = {
    appointmentId: string
    serviceId: string
    priceAtBooking: Decimal
    createdAt: Date
    updatedAt: Date
    _count: AppointmentServiceCountAggregateOutputType | null
    _avg: AppointmentServiceAvgAggregateOutputType | null
    _sum: AppointmentServiceSumAggregateOutputType | null
    _min: AppointmentServiceMinAggregateOutputType | null
    _max: AppointmentServiceMaxAggregateOutputType | null
  }

  type GetAppointmentServiceGroupByPayload<T extends AppointmentServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentServiceGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentServiceGroupByOutputType[P]>
        }
      >
    >


  export type AppointmentServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    appointmentId?: boolean
    serviceId?: boolean
    priceAtBooking?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointmentService"]>

  export type AppointmentServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    appointmentId?: boolean
    serviceId?: boolean
    priceAtBooking?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointmentService"]>

  export type AppointmentServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    appointmentId?: boolean
    serviceId?: boolean
    priceAtBooking?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointmentService"]>

  export type AppointmentServiceSelectScalar = {
    appointmentId?: boolean
    serviceId?: boolean
    priceAtBooking?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AppointmentServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"appointmentId" | "serviceId" | "priceAtBooking" | "createdAt" | "updatedAt", ExtArgs["result"]["appointmentService"]>
  export type AppointmentServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type AppointmentServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type AppointmentServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $AppointmentServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AppointmentService"
    objects: {
      appointment: Prisma.$AppointmentPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      appointmentId: string
      serviceId: string
      priceAtBooking: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["appointmentService"]>
    composites: {}
  }

  type AppointmentServiceGetPayload<S extends boolean | null | undefined | AppointmentServiceDefaultArgs> = $Result.GetResult<Prisma.$AppointmentServicePayload, S>

  type AppointmentServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppointmentServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppointmentServiceCountAggregateInputType | true
    }

  export interface AppointmentServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AppointmentService'], meta: { name: 'AppointmentService' } }
    /**
     * Find zero or one AppointmentService that matches the filter.
     * @param {AppointmentServiceFindUniqueArgs} args - Arguments to find a AppointmentService
     * @example
     * // Get one AppointmentService
     * const appointmentService = await prisma.appointmentService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppointmentServiceFindUniqueArgs>(args: SelectSubset<T, AppointmentServiceFindUniqueArgs<ExtArgs>>): Prisma__AppointmentServiceClient<$Result.GetResult<Prisma.$AppointmentServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AppointmentService that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppointmentServiceFindUniqueOrThrowArgs} args - Arguments to find a AppointmentService
     * @example
     * // Get one AppointmentService
     * const appointmentService = await prisma.appointmentService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppointmentServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, AppointmentServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppointmentServiceClient<$Result.GetResult<Prisma.$AppointmentServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppointmentService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentServiceFindFirstArgs} args - Arguments to find a AppointmentService
     * @example
     * // Get one AppointmentService
     * const appointmentService = await prisma.appointmentService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppointmentServiceFindFirstArgs>(args?: SelectSubset<T, AppointmentServiceFindFirstArgs<ExtArgs>>): Prisma__AppointmentServiceClient<$Result.GetResult<Prisma.$AppointmentServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppointmentService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentServiceFindFirstOrThrowArgs} args - Arguments to find a AppointmentService
     * @example
     * // Get one AppointmentService
     * const appointmentService = await prisma.appointmentService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppointmentServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, AppointmentServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppointmentServiceClient<$Result.GetResult<Prisma.$AppointmentServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AppointmentServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AppointmentServices
     * const appointmentServices = await prisma.appointmentService.findMany()
     * 
     * // Get first 10 AppointmentServices
     * const appointmentServices = await prisma.appointmentService.findMany({ take: 10 })
     * 
     * // Only select the `appointmentId`
     * const appointmentServiceWithAppointmentIdOnly = await prisma.appointmentService.findMany({ select: { appointmentId: true } })
     * 
     */
    findMany<T extends AppointmentServiceFindManyArgs>(args?: SelectSubset<T, AppointmentServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AppointmentService.
     * @param {AppointmentServiceCreateArgs} args - Arguments to create a AppointmentService.
     * @example
     * // Create one AppointmentService
     * const AppointmentService = await prisma.appointmentService.create({
     *   data: {
     *     // ... data to create a AppointmentService
     *   }
     * })
     * 
     */
    create<T extends AppointmentServiceCreateArgs>(args: SelectSubset<T, AppointmentServiceCreateArgs<ExtArgs>>): Prisma__AppointmentServiceClient<$Result.GetResult<Prisma.$AppointmentServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AppointmentServices.
     * @param {AppointmentServiceCreateManyArgs} args - Arguments to create many AppointmentServices.
     * @example
     * // Create many AppointmentServices
     * const appointmentService = await prisma.appointmentService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppointmentServiceCreateManyArgs>(args?: SelectSubset<T, AppointmentServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AppointmentServices and returns the data saved in the database.
     * @param {AppointmentServiceCreateManyAndReturnArgs} args - Arguments to create many AppointmentServices.
     * @example
     * // Create many AppointmentServices
     * const appointmentService = await prisma.appointmentService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AppointmentServices and only return the `appointmentId`
     * const appointmentServiceWithAppointmentIdOnly = await prisma.appointmentService.createManyAndReturn({
     *   select: { appointmentId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppointmentServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, AppointmentServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AppointmentService.
     * @param {AppointmentServiceDeleteArgs} args - Arguments to delete one AppointmentService.
     * @example
     * // Delete one AppointmentService
     * const AppointmentService = await prisma.appointmentService.delete({
     *   where: {
     *     // ... filter to delete one AppointmentService
     *   }
     * })
     * 
     */
    delete<T extends AppointmentServiceDeleteArgs>(args: SelectSubset<T, AppointmentServiceDeleteArgs<ExtArgs>>): Prisma__AppointmentServiceClient<$Result.GetResult<Prisma.$AppointmentServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AppointmentService.
     * @param {AppointmentServiceUpdateArgs} args - Arguments to update one AppointmentService.
     * @example
     * // Update one AppointmentService
     * const appointmentService = await prisma.appointmentService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppointmentServiceUpdateArgs>(args: SelectSubset<T, AppointmentServiceUpdateArgs<ExtArgs>>): Prisma__AppointmentServiceClient<$Result.GetResult<Prisma.$AppointmentServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AppointmentServices.
     * @param {AppointmentServiceDeleteManyArgs} args - Arguments to filter AppointmentServices to delete.
     * @example
     * // Delete a few AppointmentServices
     * const { count } = await prisma.appointmentService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppointmentServiceDeleteManyArgs>(args?: SelectSubset<T, AppointmentServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppointmentServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AppointmentServices
     * const appointmentService = await prisma.appointmentService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppointmentServiceUpdateManyArgs>(args: SelectSubset<T, AppointmentServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppointmentServices and returns the data updated in the database.
     * @param {AppointmentServiceUpdateManyAndReturnArgs} args - Arguments to update many AppointmentServices.
     * @example
     * // Update many AppointmentServices
     * const appointmentService = await prisma.appointmentService.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AppointmentServices and only return the `appointmentId`
     * const appointmentServiceWithAppointmentIdOnly = await prisma.appointmentService.updateManyAndReturn({
     *   select: { appointmentId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AppointmentServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, AppointmentServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AppointmentService.
     * @param {AppointmentServiceUpsertArgs} args - Arguments to update or create a AppointmentService.
     * @example
     * // Update or create a AppointmentService
     * const appointmentService = await prisma.appointmentService.upsert({
     *   create: {
     *     // ... data to create a AppointmentService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AppointmentService we want to update
     *   }
     * })
     */
    upsert<T extends AppointmentServiceUpsertArgs>(args: SelectSubset<T, AppointmentServiceUpsertArgs<ExtArgs>>): Prisma__AppointmentServiceClient<$Result.GetResult<Prisma.$AppointmentServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AppointmentServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentServiceCountArgs} args - Arguments to filter AppointmentServices to count.
     * @example
     * // Count the number of AppointmentServices
     * const count = await prisma.appointmentService.count({
     *   where: {
     *     // ... the filter for the AppointmentServices we want to count
     *   }
     * })
    **/
    count<T extends AppointmentServiceCountArgs>(
      args?: Subset<T, AppointmentServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AppointmentService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentServiceAggregateArgs>(args: Subset<T, AppointmentServiceAggregateArgs>): Prisma.PrismaPromise<GetAppointmentServiceAggregateType<T>>

    /**
     * Group by AppointmentService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppointmentServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppointmentServiceGroupByArgs['orderBy'] }
        : { orderBy?: AppointmentServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppointmentServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AppointmentService model
   */
  readonly fields: AppointmentServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AppointmentService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppointmentServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointment<T extends AppointmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AppointmentDefaultArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AppointmentService model
   */
  interface AppointmentServiceFieldRefs {
    readonly appointmentId: FieldRef<"AppointmentService", 'String'>
    readonly serviceId: FieldRef<"AppointmentService", 'String'>
    readonly priceAtBooking: FieldRef<"AppointmentService", 'Decimal'>
    readonly createdAt: FieldRef<"AppointmentService", 'DateTime'>
    readonly updatedAt: FieldRef<"AppointmentService", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AppointmentService findUnique
   */
  export type AppointmentServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentService
     */
    select?: AppointmentServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppointmentService
     */
    omit?: AppointmentServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentServiceInclude<ExtArgs> | null
    /**
     * Filter, which AppointmentService to fetch.
     */
    where: AppointmentServiceWhereUniqueInput
  }

  /**
   * AppointmentService findUniqueOrThrow
   */
  export type AppointmentServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentService
     */
    select?: AppointmentServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppointmentService
     */
    omit?: AppointmentServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentServiceInclude<ExtArgs> | null
    /**
     * Filter, which AppointmentService to fetch.
     */
    where: AppointmentServiceWhereUniqueInput
  }

  /**
   * AppointmentService findFirst
   */
  export type AppointmentServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentService
     */
    select?: AppointmentServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppointmentService
     */
    omit?: AppointmentServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentServiceInclude<ExtArgs> | null
    /**
     * Filter, which AppointmentService to fetch.
     */
    where?: AppointmentServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppointmentServices to fetch.
     */
    orderBy?: AppointmentServiceOrderByWithRelationInput | AppointmentServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppointmentServices.
     */
    cursor?: AppointmentServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppointmentServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppointmentServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppointmentServices.
     */
    distinct?: AppointmentServiceScalarFieldEnum | AppointmentServiceScalarFieldEnum[]
  }

  /**
   * AppointmentService findFirstOrThrow
   */
  export type AppointmentServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentService
     */
    select?: AppointmentServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppointmentService
     */
    omit?: AppointmentServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentServiceInclude<ExtArgs> | null
    /**
     * Filter, which AppointmentService to fetch.
     */
    where?: AppointmentServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppointmentServices to fetch.
     */
    orderBy?: AppointmentServiceOrderByWithRelationInput | AppointmentServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppointmentServices.
     */
    cursor?: AppointmentServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppointmentServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppointmentServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppointmentServices.
     */
    distinct?: AppointmentServiceScalarFieldEnum | AppointmentServiceScalarFieldEnum[]
  }

  /**
   * AppointmentService findMany
   */
  export type AppointmentServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentService
     */
    select?: AppointmentServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppointmentService
     */
    omit?: AppointmentServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentServiceInclude<ExtArgs> | null
    /**
     * Filter, which AppointmentServices to fetch.
     */
    where?: AppointmentServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppointmentServices to fetch.
     */
    orderBy?: AppointmentServiceOrderByWithRelationInput | AppointmentServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AppointmentServices.
     */
    cursor?: AppointmentServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppointmentServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppointmentServices.
     */
    skip?: number
    distinct?: AppointmentServiceScalarFieldEnum | AppointmentServiceScalarFieldEnum[]
  }

  /**
   * AppointmentService create
   */
  export type AppointmentServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentService
     */
    select?: AppointmentServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppointmentService
     */
    omit?: AppointmentServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a AppointmentService.
     */
    data: XOR<AppointmentServiceCreateInput, AppointmentServiceUncheckedCreateInput>
  }

  /**
   * AppointmentService createMany
   */
  export type AppointmentServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AppointmentServices.
     */
    data: AppointmentServiceCreateManyInput | AppointmentServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AppointmentService createManyAndReturn
   */
  export type AppointmentServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentService
     */
    select?: AppointmentServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AppointmentService
     */
    omit?: AppointmentServiceOmit<ExtArgs> | null
    /**
     * The data used to create many AppointmentServices.
     */
    data: AppointmentServiceCreateManyInput | AppointmentServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AppointmentService update
   */
  export type AppointmentServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentService
     */
    select?: AppointmentServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppointmentService
     */
    omit?: AppointmentServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a AppointmentService.
     */
    data: XOR<AppointmentServiceUpdateInput, AppointmentServiceUncheckedUpdateInput>
    /**
     * Choose, which AppointmentService to update.
     */
    where: AppointmentServiceWhereUniqueInput
  }

  /**
   * AppointmentService updateMany
   */
  export type AppointmentServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AppointmentServices.
     */
    data: XOR<AppointmentServiceUpdateManyMutationInput, AppointmentServiceUncheckedUpdateManyInput>
    /**
     * Filter which AppointmentServices to update
     */
    where?: AppointmentServiceWhereInput
    /**
     * Limit how many AppointmentServices to update.
     */
    limit?: number
  }

  /**
   * AppointmentService updateManyAndReturn
   */
  export type AppointmentServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentService
     */
    select?: AppointmentServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AppointmentService
     */
    omit?: AppointmentServiceOmit<ExtArgs> | null
    /**
     * The data used to update AppointmentServices.
     */
    data: XOR<AppointmentServiceUpdateManyMutationInput, AppointmentServiceUncheckedUpdateManyInput>
    /**
     * Filter which AppointmentServices to update
     */
    where?: AppointmentServiceWhereInput
    /**
     * Limit how many AppointmentServices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AppointmentService upsert
   */
  export type AppointmentServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentService
     */
    select?: AppointmentServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppointmentService
     */
    omit?: AppointmentServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the AppointmentService to update in case it exists.
     */
    where: AppointmentServiceWhereUniqueInput
    /**
     * In case the AppointmentService found by the `where` argument doesn't exist, create a new AppointmentService with this data.
     */
    create: XOR<AppointmentServiceCreateInput, AppointmentServiceUncheckedCreateInput>
    /**
     * In case the AppointmentService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppointmentServiceUpdateInput, AppointmentServiceUncheckedUpdateInput>
  }

  /**
   * AppointmentService delete
   */
  export type AppointmentServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentService
     */
    select?: AppointmentServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppointmentService
     */
    omit?: AppointmentServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentServiceInclude<ExtArgs> | null
    /**
     * Filter which AppointmentService to delete.
     */
    where: AppointmentServiceWhereUniqueInput
  }

  /**
   * AppointmentService deleteMany
   */
  export type AppointmentServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppointmentServices to delete
     */
    where?: AppointmentServiceWhereInput
    /**
     * Limit how many AppointmentServices to delete.
     */
    limit?: number
  }

  /**
   * AppointmentService without action
   */
  export type AppointmentServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentService
     */
    select?: AppointmentServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppointmentService
     */
    omit?: AppointmentServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentServiceInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    providerId: string | null
    documentType: string | null
    filePath: string | null
    verifiedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    verificationStatus: $Enums.DocumentVerificationStatus | null
    verifiedById: string | null
    rejectionReason: string | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    providerId: string | null
    documentType: string | null
    filePath: string | null
    verifiedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    verificationStatus: $Enums.DocumentVerificationStatus | null
    verifiedById: string | null
    rejectionReason: string | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    providerId: number
    documentType: number
    filePath: number
    verifiedAt: number
    createdAt: number
    updatedAt: number
    verificationStatus: number
    verifiedById: number
    rejectionReason: number
    _all: number
  }


  export type DocumentMinAggregateInputType = {
    id?: true
    providerId?: true
    documentType?: true
    filePath?: true
    verifiedAt?: true
    createdAt?: true
    updatedAt?: true
    verificationStatus?: true
    verifiedById?: true
    rejectionReason?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    providerId?: true
    documentType?: true
    filePath?: true
    verifiedAt?: true
    createdAt?: true
    updatedAt?: true
    verificationStatus?: true
    verifiedById?: true
    rejectionReason?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    providerId?: true
    documentType?: true
    filePath?: true
    verifiedAt?: true
    createdAt?: true
    updatedAt?: true
    verificationStatus?: true
    verifiedById?: true
    rejectionReason?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    providerId: string
    documentType: string
    filePath: string
    verifiedAt: Date | null
    createdAt: Date
    updatedAt: Date
    verificationStatus: $Enums.DocumentVerificationStatus
    verifiedById: string | null
    rejectionReason: string | null
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    documentType?: boolean
    filePath?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verificationStatus?: boolean
    verifiedById?: boolean
    rejectionReason?: boolean
    verifiedBy?: boolean | Document$verifiedByArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    documentType?: boolean
    filePath?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verificationStatus?: boolean
    verifiedById?: boolean
    rejectionReason?: boolean
    verifiedBy?: boolean | Document$verifiedByArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    documentType?: boolean
    filePath?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verificationStatus?: boolean
    verifiedById?: boolean
    rejectionReason?: boolean
    verifiedBy?: boolean | Document$verifiedByArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    providerId?: boolean
    documentType?: boolean
    filePath?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verificationStatus?: boolean
    verifiedById?: boolean
    rejectionReason?: boolean
  }

  export type DocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "providerId" | "documentType" | "filePath" | "verifiedAt" | "createdAt" | "updatedAt" | "verificationStatus" | "verifiedById" | "rejectionReason", ExtArgs["result"]["document"]>
  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verifiedBy?: boolean | Document$verifiedByArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verifiedBy?: boolean | Document$verifiedByArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verifiedBy?: boolean | Document$verifiedByArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      verifiedBy: Prisma.$UserPayload<ExtArgs> | null
      provider: Prisma.$ProviderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      providerId: string
      documentType: string
      filePath: string
      verifiedAt: Date | null
      createdAt: Date
      updatedAt: Date
      verificationStatus: $Enums.DocumentVerificationStatus
      verifiedById: string | null
      rejectionReason: string | null
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents and returns the data updated in the database.
     * @param {DocumentUpdateManyAndReturnArgs} args - Arguments to update many Documents.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    verifiedBy<T extends Document$verifiedByArgs<ExtArgs> = {}>(args?: Subset<T, Document$verifiedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    provider<T extends ProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProviderDefaultArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly providerId: FieldRef<"Document", 'String'>
    readonly documentType: FieldRef<"Document", 'String'>
    readonly filePath: FieldRef<"Document", 'String'>
    readonly verifiedAt: FieldRef<"Document", 'DateTime'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
    readonly updatedAt: FieldRef<"Document", 'DateTime'>
    readonly verificationStatus: FieldRef<"Document", 'DocumentVerificationStatus'>
    readonly verifiedById: FieldRef<"Document", 'String'>
    readonly rejectionReason: FieldRef<"Document", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Document updateManyAndReturn
   */
  export type DocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to delete.
     */
    limit?: number
  }

  /**
   * Document.verifiedBy
   */
  export type Document$verifiedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    isRead: boolean | null
    appointmentId: string | null
    providerId: string | null
    readAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    isRead: boolean | null
    appointmentId: string | null
    providerId: string | null
    readAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    message: number
    isRead: number
    appointmentId: number
    providerId: number
    metadata: number
    readAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    appointmentId?: true
    providerId?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    appointmentId?: true
    providerId?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    appointmentId?: true
    providerId?: true
    metadata?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead: boolean
    appointmentId: string | null
    providerId: string | null
    metadata: JsonValue | null
    readAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    appointmentId?: boolean
    providerId?: boolean
    metadata?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    appointment?: boolean | Notification$appointmentArgs<ExtArgs>
    provider?: boolean | Notification$providerArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    appointmentId?: boolean
    providerId?: boolean
    metadata?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    appointment?: boolean | Notification$appointmentArgs<ExtArgs>
    provider?: boolean | Notification$providerArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    appointmentId?: boolean
    providerId?: boolean
    metadata?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    appointment?: boolean | Notification$appointmentArgs<ExtArgs>
    provider?: boolean | Notification$providerArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    appointmentId?: boolean
    providerId?: boolean
    metadata?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "title" | "message" | "isRead" | "appointmentId" | "providerId" | "metadata" | "readAt" | "createdAt" | "updatedAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    appointment?: boolean | Notification$appointmentArgs<ExtArgs>
    provider?: boolean | Notification$providerArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    appointment?: boolean | Notification$appointmentArgs<ExtArgs>
    provider?: boolean | Notification$providerArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    appointment?: boolean | Notification$appointmentArgs<ExtArgs>
    provider?: boolean | Notification$providerArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      appointment: Prisma.$AppointmentPayload<ExtArgs> | null
      provider: Prisma.$ProviderPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.NotificationType
      title: string
      message: string
      isRead: boolean
      appointmentId: string | null
      providerId: string | null
      metadata: Prisma.JsonValue | null
      readAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    appointment<T extends Notification$appointmentArgs<ExtArgs> = {}>(args?: Subset<T, Notification$appointmentArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    provider<T extends Notification$providerArgs<ExtArgs> = {}>(args?: Subset<T, Notification$providerArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly appointmentId: FieldRef<"Notification", 'String'>
    readonly providerId: FieldRef<"Notification", 'String'>
    readonly metadata: FieldRef<"Notification", 'Json'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.appointment
   */
  export type Notification$appointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
  }

  /**
   * Notification.provider
   */
  export type Notification$providerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    where?: ProviderWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Conversation
   */

  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationMinAggregateOutputType = {
    id: string | null
    user1Id: string | null
    user2Id: string | null
    lastMessageAt: Date | null
    lastMessageContent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: string | null
    user1Id: string | null
    user2Id: string | null
    lastMessageAt: Date | null
    lastMessageContent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    user1Id: number
    user2Id: number
    lastMessageAt: number
    lastMessageContent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConversationMinAggregateInputType = {
    id?: true
    user1Id?: true
    user2Id?: true
    lastMessageAt?: true
    lastMessageContent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    user1Id?: true
    user2Id?: true
    lastMessageAt?: true
    lastMessageContent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    user1Id?: true
    user2Id?: true
    lastMessageAt?: true
    lastMessageContent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversation to aggregate.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type ConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithAggregationInput | ConversationOrderByWithAggregationInput[]
    by: ConversationScalarFieldEnum[] | ConversationScalarFieldEnum
    having?: ConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }

  export type ConversationGroupByOutputType = {
    id: string
    user1Id: string
    user2Id: string
    lastMessageAt: Date | null
    lastMessageContent: string | null
    createdAt: Date
    updatedAt: Date
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends ConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type ConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user1Id?: boolean
    user2Id?: boolean
    lastMessageAt?: boolean
    lastMessageContent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user1?: boolean | UserDefaultArgs<ExtArgs>
    user2?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user1Id?: boolean
    user2Id?: boolean
    lastMessageAt?: boolean
    lastMessageContent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user1?: boolean | UserDefaultArgs<ExtArgs>
    user2?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user1Id?: boolean
    user2Id?: boolean
    lastMessageAt?: boolean
    lastMessageContent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user1?: boolean | UserDefaultArgs<ExtArgs>
    user2?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectScalar = {
    id?: boolean
    user1Id?: boolean
    user2Id?: boolean
    lastMessageAt?: boolean
    lastMessageContent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConversationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user1Id" | "user2Id" | "lastMessageAt" | "lastMessageContent" | "createdAt" | "updatedAt", ExtArgs["result"]["conversation"]>
  export type ConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user1?: boolean | UserDefaultArgs<ExtArgs>
    user2?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user1?: boolean | UserDefaultArgs<ExtArgs>
    user2?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ConversationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user1?: boolean | UserDefaultArgs<ExtArgs>
    user2?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conversation"
    objects: {
      user1: Prisma.$UserPayload<ExtArgs>
      user2: Prisma.$UserPayload<ExtArgs>
      messages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user1Id: string
      user2Id: string
      lastMessageAt: Date | null
      lastMessageContent: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conversation"]>
    composites: {}
  }

  type ConversationGetPayload<S extends boolean | null | undefined | ConversationDefaultArgs> = $Result.GetResult<Prisma.$ConversationPayload, S>

  type ConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationCountAggregateInputType | true
    }

  export interface ConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversation'], meta: { name: 'Conversation' } }
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {ConversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationFindUniqueArgs>(args: SelectSubset<T, ConversationFindUniqueArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conversation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationFindFirstArgs>(args?: SelectSubset<T, ConversationFindFirstArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationFindManyArgs>(args?: SelectSubset<T, ConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conversation.
     * @param {ConversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
     */
    create<T extends ConversationCreateArgs>(args: SelectSubset<T, ConversationCreateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conversations.
     * @param {ConversationCreateManyArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationCreateManyArgs>(args?: SelectSubset<T, ConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conversations and returns the data saved in the database.
     * @param {ConversationCreateManyAndReturnArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Conversation.
     * @param {ConversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
     */
    delete<T extends ConversationDeleteArgs>(args: SelectSubset<T, ConversationDeleteArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conversation.
     * @param {ConversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationUpdateArgs>(args: SelectSubset<T, ConversationUpdateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conversations.
     * @param {ConversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationDeleteManyArgs>(args?: SelectSubset<T, ConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationUpdateManyArgs>(args: SelectSubset<T, ConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations and returns the data updated in the database.
     * @param {ConversationUpdateManyAndReturnArgs} args - Arguments to update many Conversations.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConversationUpdateManyAndReturnArgs>(args: SelectSubset<T, ConversationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Conversation.
     * @param {ConversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
     */
    upsert<T extends ConversationUpsertArgs>(args: SelectSubset<T, ConversationUpsertArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends ConversationCountArgs>(
      args?: Subset<T, ConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): Prisma.PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationGroupByArgs['orderBy'] }
        : { orderBy?: ConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversation model
   */
  readonly fields: ConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user1<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user2<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    messages<T extends Conversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conversation model
   */
  interface ConversationFieldRefs {
    readonly id: FieldRef<"Conversation", 'String'>
    readonly user1Id: FieldRef<"Conversation", 'String'>
    readonly user2Id: FieldRef<"Conversation", 'String'>
    readonly lastMessageAt: FieldRef<"Conversation", 'DateTime'>
    readonly lastMessageContent: FieldRef<"Conversation", 'String'>
    readonly createdAt: FieldRef<"Conversation", 'DateTime'>
    readonly updatedAt: FieldRef<"Conversation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Conversation findUnique
   */
  export type ConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findUniqueOrThrow
   */
  export type ConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findFirst
   */
  export type ConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findFirstOrThrow
   */
  export type ConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findMany
   */
  export type ConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversations to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation create
   */
  export type ConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversation.
     */
    data: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
  }

  /**
   * Conversation createMany
   */
  export type ConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversation createManyAndReturn
   */
  export type ConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation update
   */
  export type ConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversation.
     */
    data: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
    /**
     * Choose, which Conversation to update.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation updateMany
   */
  export type ConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
  }

  /**
   * Conversation updateManyAndReturn
   */
  export type ConversationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation upsert
   */
  export type ConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversation to update in case it exists.
     */
    where: ConversationWhereUniqueInput
    /**
     * In case the Conversation found by the `where` argument doesn't exist, create a new Conversation with this data.
     */
    create: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
    /**
     * In case the Conversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
  }

  /**
   * Conversation delete
   */
  export type ConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter which Conversation to delete.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation deleteMany
   */
  export type ConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversations to delete
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to delete.
     */
    limit?: number
  }

  /**
   * Conversation.messages
   */
  export type Conversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Conversation without action
   */
  export type ConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    senderId: string | null
    content: string | null
    status: $Enums.MessageStatus | null
    readAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    senderId: string | null
    content: string | null
    status: $Enums.MessageStatus | null
    readAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    conversationId: number
    senderId: number
    content: number
    status: number
    readAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    content?: true
    status?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    content?: true
    status?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    content?: true
    status?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    conversationId: string
    senderId: string
    content: string
    status: $Enums.MessageStatus
    readAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    content?: boolean
    status?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    content?: boolean
    status?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    content?: boolean
    status?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    content?: boolean
    status?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversationId" | "senderId" | "content" | "status" | "readAt" | "createdAt" | "updatedAt", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      senderId: string
      content: string
      status: $Enums.MessageStatus
      readAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly conversationId: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly status: FieldRef<"Message", 'MessageStatus'>
    readonly readAt: FieldRef<"Message", 'DateTime'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly updatedAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    rating: number | null
    professionalismRating: number | null
    cleanlinessRating: number | null
    waitTimeRating: number | null
    valueRating: number | null
  }

  export type ReviewSumAggregateOutputType = {
    rating: number | null
    professionalismRating: number | null
    cleanlinessRating: number | null
    waitTimeRating: number | null
    valueRating: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    appointmentId: string | null
    userId: string | null
    providerId: string | null
    rating: number | null
    comment: string | null
    isAnonymous: boolean | null
    professionalismRating: number | null
    cleanlinessRating: number | null
    waitTimeRating: number | null
    valueRating: number | null
    providerResponse: string | null
    respondedAt: Date | null
    isEdited: boolean | null
    editedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    appointmentId: string | null
    userId: string | null
    providerId: string | null
    rating: number | null
    comment: string | null
    isAnonymous: boolean | null
    professionalismRating: number | null
    cleanlinessRating: number | null
    waitTimeRating: number | null
    valueRating: number | null
    providerResponse: string | null
    respondedAt: Date | null
    isEdited: boolean | null
    editedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    appointmentId: number
    userId: number
    providerId: number
    rating: number
    comment: number
    isAnonymous: number
    professionalismRating: number
    cleanlinessRating: number
    waitTimeRating: number
    valueRating: number
    providerResponse: number
    respondedAt: number
    isEdited: number
    editedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    rating?: true
    professionalismRating?: true
    cleanlinessRating?: true
    waitTimeRating?: true
    valueRating?: true
  }

  export type ReviewSumAggregateInputType = {
    rating?: true
    professionalismRating?: true
    cleanlinessRating?: true
    waitTimeRating?: true
    valueRating?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    appointmentId?: true
    userId?: true
    providerId?: true
    rating?: true
    comment?: true
    isAnonymous?: true
    professionalismRating?: true
    cleanlinessRating?: true
    waitTimeRating?: true
    valueRating?: true
    providerResponse?: true
    respondedAt?: true
    isEdited?: true
    editedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    appointmentId?: true
    userId?: true
    providerId?: true
    rating?: true
    comment?: true
    isAnonymous?: true
    professionalismRating?: true
    cleanlinessRating?: true
    waitTimeRating?: true
    valueRating?: true
    providerResponse?: true
    respondedAt?: true
    isEdited?: true
    editedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    appointmentId?: true
    userId?: true
    providerId?: true
    rating?: true
    comment?: true
    isAnonymous?: true
    professionalismRating?: true
    cleanlinessRating?: true
    waitTimeRating?: true
    valueRating?: true
    providerResponse?: true
    respondedAt?: true
    isEdited?: true
    editedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: string
    appointmentId: string
    userId: string
    providerId: string
    rating: number
    comment: string | null
    isAnonymous: boolean
    professionalismRating: number | null
    cleanlinessRating: number | null
    waitTimeRating: number | null
    valueRating: number | null
    providerResponse: string | null
    respondedAt: Date | null
    isEdited: boolean
    editedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appointmentId?: boolean
    userId?: boolean
    providerId?: boolean
    rating?: boolean
    comment?: boolean
    isAnonymous?: boolean
    professionalismRating?: boolean
    cleanlinessRating?: boolean
    waitTimeRating?: boolean
    valueRating?: boolean
    providerResponse?: boolean
    respondedAt?: boolean
    isEdited?: boolean
    editedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    likes?: boolean | Review$likesArgs<ExtArgs>
    _count?: boolean | ReviewCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appointmentId?: boolean
    userId?: boolean
    providerId?: boolean
    rating?: boolean
    comment?: boolean
    isAnonymous?: boolean
    professionalismRating?: boolean
    cleanlinessRating?: boolean
    waitTimeRating?: boolean
    valueRating?: boolean
    providerResponse?: boolean
    respondedAt?: boolean
    isEdited?: boolean
    editedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appointmentId?: boolean
    userId?: boolean
    providerId?: boolean
    rating?: boolean
    comment?: boolean
    isAnonymous?: boolean
    professionalismRating?: boolean
    cleanlinessRating?: boolean
    waitTimeRating?: boolean
    valueRating?: boolean
    providerResponse?: boolean
    respondedAt?: boolean
    isEdited?: boolean
    editedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    appointmentId?: boolean
    userId?: boolean
    providerId?: boolean
    rating?: boolean
    comment?: boolean
    isAnonymous?: boolean
    professionalismRating?: boolean
    cleanlinessRating?: boolean
    waitTimeRating?: boolean
    valueRating?: boolean
    providerResponse?: boolean
    respondedAt?: boolean
    isEdited?: boolean
    editedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "appointmentId" | "userId" | "providerId" | "rating" | "comment" | "isAnonymous" | "professionalismRating" | "cleanlinessRating" | "waitTimeRating" | "valueRating" | "providerResponse" | "respondedAt" | "isEdited" | "editedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["review"]>
  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    likes?: boolean | Review$likesArgs<ExtArgs>
    _count?: boolean | ReviewCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      appointment: Prisma.$AppointmentPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      provider: Prisma.$ProviderPayload<ExtArgs>
      likes: Prisma.$ReviewLikePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      appointmentId: string
      userId: string
      providerId: string
      rating: number
      comment: string | null
      isAnonymous: boolean
      professionalismRating: number | null
      cleanlinessRating: number | null
      waitTimeRating: number | null
      valueRating: number | null
      providerResponse: string | null
      respondedAt: Date | null
      isEdited: boolean
      editedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {ReviewUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointment<T extends AppointmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AppointmentDefaultArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    provider<T extends ProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProviderDefaultArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    likes<T extends Review$likesArgs<ExtArgs> = {}>(args?: Subset<T, Review$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'String'>
    readonly appointmentId: FieldRef<"Review", 'String'>
    readonly userId: FieldRef<"Review", 'String'>
    readonly providerId: FieldRef<"Review", 'String'>
    readonly rating: FieldRef<"Review", 'Int'>
    readonly comment: FieldRef<"Review", 'String'>
    readonly isAnonymous: FieldRef<"Review", 'Boolean'>
    readonly professionalismRating: FieldRef<"Review", 'Int'>
    readonly cleanlinessRating: FieldRef<"Review", 'Int'>
    readonly waitTimeRating: FieldRef<"Review", 'Int'>
    readonly valueRating: FieldRef<"Review", 'Int'>
    readonly providerResponse: FieldRef<"Review", 'String'>
    readonly respondedAt: FieldRef<"Review", 'DateTime'>
    readonly isEdited: FieldRef<"Review", 'Boolean'>
    readonly editedAt: FieldRef<"Review", 'DateTime'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
    readonly updatedAt: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
  }

  /**
   * Review updateManyAndReturn
   */
  export type ReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number
  }

  /**
   * Review.likes
   */
  export type Review$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewLike
     */
    select?: ReviewLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewLike
     */
    omit?: ReviewLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewLikeInclude<ExtArgs> | null
    where?: ReviewLikeWhereInput
    orderBy?: ReviewLikeOrderByWithRelationInput | ReviewLikeOrderByWithRelationInput[]
    cursor?: ReviewLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewLikeScalarFieldEnum | ReviewLikeScalarFieldEnum[]
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model ReviewLike
   */

  export type AggregateReviewLike = {
    _count: ReviewLikeCountAggregateOutputType | null
    _min: ReviewLikeMinAggregateOutputType | null
    _max: ReviewLikeMaxAggregateOutputType | null
  }

  export type ReviewLikeMinAggregateOutputType = {
    id: string | null
    reviewId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type ReviewLikeMaxAggregateOutputType = {
    id: string | null
    reviewId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type ReviewLikeCountAggregateOutputType = {
    id: number
    reviewId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type ReviewLikeMinAggregateInputType = {
    id?: true
    reviewId?: true
    userId?: true
    createdAt?: true
  }

  export type ReviewLikeMaxAggregateInputType = {
    id?: true
    reviewId?: true
    userId?: true
    createdAt?: true
  }

  export type ReviewLikeCountAggregateInputType = {
    id?: true
    reviewId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type ReviewLikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewLike to aggregate.
     */
    where?: ReviewLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewLikes to fetch.
     */
    orderBy?: ReviewLikeOrderByWithRelationInput | ReviewLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReviewLikes
    **/
    _count?: true | ReviewLikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewLikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewLikeMaxAggregateInputType
  }

  export type GetReviewLikeAggregateType<T extends ReviewLikeAggregateArgs> = {
        [P in keyof T & keyof AggregateReviewLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviewLike[P]>
      : GetScalarType<T[P], AggregateReviewLike[P]>
  }




  export type ReviewLikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewLikeWhereInput
    orderBy?: ReviewLikeOrderByWithAggregationInput | ReviewLikeOrderByWithAggregationInput[]
    by: ReviewLikeScalarFieldEnum[] | ReviewLikeScalarFieldEnum
    having?: ReviewLikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewLikeCountAggregateInputType | true
    _min?: ReviewLikeMinAggregateInputType
    _max?: ReviewLikeMaxAggregateInputType
  }

  export type ReviewLikeGroupByOutputType = {
    id: string
    reviewId: string
    userId: string
    createdAt: Date
    _count: ReviewLikeCountAggregateOutputType | null
    _min: ReviewLikeMinAggregateOutputType | null
    _max: ReviewLikeMaxAggregateOutputType | null
  }

  type GetReviewLikeGroupByPayload<T extends ReviewLikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewLikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewLikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewLikeGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewLikeGroupByOutputType[P]>
        }
      >
    >


  export type ReviewLikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    userId?: boolean
    createdAt?: boolean
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewLike"]>

  export type ReviewLikeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    userId?: boolean
    createdAt?: boolean
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewLike"]>

  export type ReviewLikeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    userId?: boolean
    createdAt?: boolean
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewLike"]>

  export type ReviewLikeSelectScalar = {
    id?: boolean
    reviewId?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type ReviewLikeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reviewId" | "userId" | "createdAt", ExtArgs["result"]["reviewLike"]>
  export type ReviewLikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReviewLikeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReviewLikeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReviewLikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReviewLike"
    objects: {
      review: Prisma.$ReviewPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reviewId: string
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["reviewLike"]>
    composites: {}
  }

  type ReviewLikeGetPayload<S extends boolean | null | undefined | ReviewLikeDefaultArgs> = $Result.GetResult<Prisma.$ReviewLikePayload, S>

  type ReviewLikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewLikeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewLikeCountAggregateInputType | true
    }

  export interface ReviewLikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReviewLike'], meta: { name: 'ReviewLike' } }
    /**
     * Find zero or one ReviewLike that matches the filter.
     * @param {ReviewLikeFindUniqueArgs} args - Arguments to find a ReviewLike
     * @example
     * // Get one ReviewLike
     * const reviewLike = await prisma.reviewLike.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewLikeFindUniqueArgs>(args: SelectSubset<T, ReviewLikeFindUniqueArgs<ExtArgs>>): Prisma__ReviewLikeClient<$Result.GetResult<Prisma.$ReviewLikePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReviewLike that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewLikeFindUniqueOrThrowArgs} args - Arguments to find a ReviewLike
     * @example
     * // Get one ReviewLike
     * const reviewLike = await prisma.reviewLike.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewLikeFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewLikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewLikeClient<$Result.GetResult<Prisma.$ReviewLikePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewLike that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewLikeFindFirstArgs} args - Arguments to find a ReviewLike
     * @example
     * // Get one ReviewLike
     * const reviewLike = await prisma.reviewLike.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewLikeFindFirstArgs>(args?: SelectSubset<T, ReviewLikeFindFirstArgs<ExtArgs>>): Prisma__ReviewLikeClient<$Result.GetResult<Prisma.$ReviewLikePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewLike that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewLikeFindFirstOrThrowArgs} args - Arguments to find a ReviewLike
     * @example
     * // Get one ReviewLike
     * const reviewLike = await prisma.reviewLike.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewLikeFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewLikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewLikeClient<$Result.GetResult<Prisma.$ReviewLikePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReviewLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewLikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReviewLikes
     * const reviewLikes = await prisma.reviewLike.findMany()
     * 
     * // Get first 10 ReviewLikes
     * const reviewLikes = await prisma.reviewLike.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewLikeWithIdOnly = await prisma.reviewLike.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewLikeFindManyArgs>(args?: SelectSubset<T, ReviewLikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReviewLike.
     * @param {ReviewLikeCreateArgs} args - Arguments to create a ReviewLike.
     * @example
     * // Create one ReviewLike
     * const ReviewLike = await prisma.reviewLike.create({
     *   data: {
     *     // ... data to create a ReviewLike
     *   }
     * })
     * 
     */
    create<T extends ReviewLikeCreateArgs>(args: SelectSubset<T, ReviewLikeCreateArgs<ExtArgs>>): Prisma__ReviewLikeClient<$Result.GetResult<Prisma.$ReviewLikePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReviewLikes.
     * @param {ReviewLikeCreateManyArgs} args - Arguments to create many ReviewLikes.
     * @example
     * // Create many ReviewLikes
     * const reviewLike = await prisma.reviewLike.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewLikeCreateManyArgs>(args?: SelectSubset<T, ReviewLikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReviewLikes and returns the data saved in the database.
     * @param {ReviewLikeCreateManyAndReturnArgs} args - Arguments to create many ReviewLikes.
     * @example
     * // Create many ReviewLikes
     * const reviewLike = await prisma.reviewLike.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReviewLikes and only return the `id`
     * const reviewLikeWithIdOnly = await prisma.reviewLike.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewLikeCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewLikeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewLikePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReviewLike.
     * @param {ReviewLikeDeleteArgs} args - Arguments to delete one ReviewLike.
     * @example
     * // Delete one ReviewLike
     * const ReviewLike = await prisma.reviewLike.delete({
     *   where: {
     *     // ... filter to delete one ReviewLike
     *   }
     * })
     * 
     */
    delete<T extends ReviewLikeDeleteArgs>(args: SelectSubset<T, ReviewLikeDeleteArgs<ExtArgs>>): Prisma__ReviewLikeClient<$Result.GetResult<Prisma.$ReviewLikePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReviewLike.
     * @param {ReviewLikeUpdateArgs} args - Arguments to update one ReviewLike.
     * @example
     * // Update one ReviewLike
     * const reviewLike = await prisma.reviewLike.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewLikeUpdateArgs>(args: SelectSubset<T, ReviewLikeUpdateArgs<ExtArgs>>): Prisma__ReviewLikeClient<$Result.GetResult<Prisma.$ReviewLikePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReviewLikes.
     * @param {ReviewLikeDeleteManyArgs} args - Arguments to filter ReviewLikes to delete.
     * @example
     * // Delete a few ReviewLikes
     * const { count } = await prisma.reviewLike.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewLikeDeleteManyArgs>(args?: SelectSubset<T, ReviewLikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewLikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReviewLikes
     * const reviewLike = await prisma.reviewLike.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewLikeUpdateManyArgs>(args: SelectSubset<T, ReviewLikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewLikes and returns the data updated in the database.
     * @param {ReviewLikeUpdateManyAndReturnArgs} args - Arguments to update many ReviewLikes.
     * @example
     * // Update many ReviewLikes
     * const reviewLike = await prisma.reviewLike.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReviewLikes and only return the `id`
     * const reviewLikeWithIdOnly = await prisma.reviewLike.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewLikeUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewLikeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewLikePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReviewLike.
     * @param {ReviewLikeUpsertArgs} args - Arguments to update or create a ReviewLike.
     * @example
     * // Update or create a ReviewLike
     * const reviewLike = await prisma.reviewLike.upsert({
     *   create: {
     *     // ... data to create a ReviewLike
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReviewLike we want to update
     *   }
     * })
     */
    upsert<T extends ReviewLikeUpsertArgs>(args: SelectSubset<T, ReviewLikeUpsertArgs<ExtArgs>>): Prisma__ReviewLikeClient<$Result.GetResult<Prisma.$ReviewLikePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReviewLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewLikeCountArgs} args - Arguments to filter ReviewLikes to count.
     * @example
     * // Count the number of ReviewLikes
     * const count = await prisma.reviewLike.count({
     *   where: {
     *     // ... the filter for the ReviewLikes we want to count
     *   }
     * })
    **/
    count<T extends ReviewLikeCountArgs>(
      args?: Subset<T, ReviewLikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewLikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReviewLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewLikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewLikeAggregateArgs>(args: Subset<T, ReviewLikeAggregateArgs>): Prisma.PrismaPromise<GetReviewLikeAggregateType<T>>

    /**
     * Group by ReviewLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewLikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewLikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewLikeGroupByArgs['orderBy'] }
        : { orderBy?: ReviewLikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewLikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReviewLike model
   */
  readonly fields: ReviewLikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReviewLike.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewLikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    review<T extends ReviewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReviewDefaultArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReviewLike model
   */
  interface ReviewLikeFieldRefs {
    readonly id: FieldRef<"ReviewLike", 'String'>
    readonly reviewId: FieldRef<"ReviewLike", 'String'>
    readonly userId: FieldRef<"ReviewLike", 'String'>
    readonly createdAt: FieldRef<"ReviewLike", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReviewLike findUnique
   */
  export type ReviewLikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewLike
     */
    select?: ReviewLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewLike
     */
    omit?: ReviewLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewLikeInclude<ExtArgs> | null
    /**
     * Filter, which ReviewLike to fetch.
     */
    where: ReviewLikeWhereUniqueInput
  }

  /**
   * ReviewLike findUniqueOrThrow
   */
  export type ReviewLikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewLike
     */
    select?: ReviewLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewLike
     */
    omit?: ReviewLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewLikeInclude<ExtArgs> | null
    /**
     * Filter, which ReviewLike to fetch.
     */
    where: ReviewLikeWhereUniqueInput
  }

  /**
   * ReviewLike findFirst
   */
  export type ReviewLikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewLike
     */
    select?: ReviewLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewLike
     */
    omit?: ReviewLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewLikeInclude<ExtArgs> | null
    /**
     * Filter, which ReviewLike to fetch.
     */
    where?: ReviewLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewLikes to fetch.
     */
    orderBy?: ReviewLikeOrderByWithRelationInput | ReviewLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewLikes.
     */
    cursor?: ReviewLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewLikes.
     */
    distinct?: ReviewLikeScalarFieldEnum | ReviewLikeScalarFieldEnum[]
  }

  /**
   * ReviewLike findFirstOrThrow
   */
  export type ReviewLikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewLike
     */
    select?: ReviewLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewLike
     */
    omit?: ReviewLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewLikeInclude<ExtArgs> | null
    /**
     * Filter, which ReviewLike to fetch.
     */
    where?: ReviewLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewLikes to fetch.
     */
    orderBy?: ReviewLikeOrderByWithRelationInput | ReviewLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewLikes.
     */
    cursor?: ReviewLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewLikes.
     */
    distinct?: ReviewLikeScalarFieldEnum | ReviewLikeScalarFieldEnum[]
  }

  /**
   * ReviewLike findMany
   */
  export type ReviewLikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewLike
     */
    select?: ReviewLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewLike
     */
    omit?: ReviewLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewLikeInclude<ExtArgs> | null
    /**
     * Filter, which ReviewLikes to fetch.
     */
    where?: ReviewLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewLikes to fetch.
     */
    orderBy?: ReviewLikeOrderByWithRelationInput | ReviewLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReviewLikes.
     */
    cursor?: ReviewLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewLikes.
     */
    skip?: number
    distinct?: ReviewLikeScalarFieldEnum | ReviewLikeScalarFieldEnum[]
  }

  /**
   * ReviewLike create
   */
  export type ReviewLikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewLike
     */
    select?: ReviewLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewLike
     */
    omit?: ReviewLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewLikeInclude<ExtArgs> | null
    /**
     * The data needed to create a ReviewLike.
     */
    data: XOR<ReviewLikeCreateInput, ReviewLikeUncheckedCreateInput>
  }

  /**
   * ReviewLike createMany
   */
  export type ReviewLikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReviewLikes.
     */
    data: ReviewLikeCreateManyInput | ReviewLikeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReviewLike createManyAndReturn
   */
  export type ReviewLikeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewLike
     */
    select?: ReviewLikeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewLike
     */
    omit?: ReviewLikeOmit<ExtArgs> | null
    /**
     * The data used to create many ReviewLikes.
     */
    data: ReviewLikeCreateManyInput | ReviewLikeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewLikeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewLike update
   */
  export type ReviewLikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewLike
     */
    select?: ReviewLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewLike
     */
    omit?: ReviewLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewLikeInclude<ExtArgs> | null
    /**
     * The data needed to update a ReviewLike.
     */
    data: XOR<ReviewLikeUpdateInput, ReviewLikeUncheckedUpdateInput>
    /**
     * Choose, which ReviewLike to update.
     */
    where: ReviewLikeWhereUniqueInput
  }

  /**
   * ReviewLike updateMany
   */
  export type ReviewLikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReviewLikes.
     */
    data: XOR<ReviewLikeUpdateManyMutationInput, ReviewLikeUncheckedUpdateManyInput>
    /**
     * Filter which ReviewLikes to update
     */
    where?: ReviewLikeWhereInput
    /**
     * Limit how many ReviewLikes to update.
     */
    limit?: number
  }

  /**
   * ReviewLike updateManyAndReturn
   */
  export type ReviewLikeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewLike
     */
    select?: ReviewLikeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewLike
     */
    omit?: ReviewLikeOmit<ExtArgs> | null
    /**
     * The data used to update ReviewLikes.
     */
    data: XOR<ReviewLikeUpdateManyMutationInput, ReviewLikeUncheckedUpdateManyInput>
    /**
     * Filter which ReviewLikes to update
     */
    where?: ReviewLikeWhereInput
    /**
     * Limit how many ReviewLikes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewLikeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewLike upsert
   */
  export type ReviewLikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewLike
     */
    select?: ReviewLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewLike
     */
    omit?: ReviewLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewLikeInclude<ExtArgs> | null
    /**
     * The filter to search for the ReviewLike to update in case it exists.
     */
    where: ReviewLikeWhereUniqueInput
    /**
     * In case the ReviewLike found by the `where` argument doesn't exist, create a new ReviewLike with this data.
     */
    create: XOR<ReviewLikeCreateInput, ReviewLikeUncheckedCreateInput>
    /**
     * In case the ReviewLike was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewLikeUpdateInput, ReviewLikeUncheckedUpdateInput>
  }

  /**
   * ReviewLike delete
   */
  export type ReviewLikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewLike
     */
    select?: ReviewLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewLike
     */
    omit?: ReviewLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewLikeInclude<ExtArgs> | null
    /**
     * Filter which ReviewLike to delete.
     */
    where: ReviewLikeWhereUniqueInput
  }

  /**
   * ReviewLike deleteMany
   */
  export type ReviewLikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewLikes to delete
     */
    where?: ReviewLikeWhereInput
    /**
     * Limit how many ReviewLikes to delete.
     */
    limit?: number
  }

  /**
   * ReviewLike without action
   */
  export type ReviewLikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewLike
     */
    select?: ReviewLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewLike
     */
    omit?: ReviewLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewLikeInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    action: string | null
    targetType: string | null
    targetId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    action: string | null
    targetType: string | null
    targetId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    adminId: number
    action: number
    targetType: number
    targetId: number
    oldValue: number
    newValue: number
    metadata: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    adminId?: true
    action?: true
    targetType?: true
    targetId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    adminId?: true
    action?: true
    targetType?: true
    targetId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    adminId?: true
    action?: true
    targetType?: true
    targetId?: true
    oldValue?: true
    newValue?: true
    metadata?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    adminId: string
    action: string
    targetType: string
    targetId: string
    oldValue: JsonValue | null
    newValue: JsonValue | null
    metadata: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    action?: boolean
    targetType?: boolean
    targetId?: boolean
    oldValue?: boolean
    newValue?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    action?: boolean
    targetType?: boolean
    targetId?: boolean
    oldValue?: boolean
    newValue?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    action?: boolean
    targetType?: boolean
    targetId?: boolean
    oldValue?: boolean
    newValue?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    adminId?: boolean
    action?: boolean
    targetType?: boolean
    targetId?: boolean
    oldValue?: boolean
    newValue?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminId" | "action" | "targetType" | "targetId" | "oldValue" | "newValue" | "metadata" | "ipAddress" | "userAgent" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      admin: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      action: string
      targetType: string
      targetId: string
      oldValue: Prisma.JsonValue | null
      newValue: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly adminId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly targetType: FieldRef<"AuditLog", 'String'>
    readonly targetId: FieldRef<"AuditLog", 'String'>
    readonly oldValue: FieldRef<"AuditLog", 'Json'>
    readonly newValue: FieldRef<"AuditLog", 'Json'>
    readonly metadata: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model ProviderStatusHistory
   */

  export type AggregateProviderStatusHistory = {
    _count: ProviderStatusHistoryCountAggregateOutputType | null
    _min: ProviderStatusHistoryMinAggregateOutputType | null
    _max: ProviderStatusHistoryMaxAggregateOutputType | null
  }

  export type ProviderStatusHistoryMinAggregateOutputType = {
    id: string | null
    providerId: string | null
    fromStatus: $Enums.ProviderStatus | null
    toStatus: $Enums.ProviderStatus | null
    reason: string | null
    changedById: string | null
    createdAt: Date | null
  }

  export type ProviderStatusHistoryMaxAggregateOutputType = {
    id: string | null
    providerId: string | null
    fromStatus: $Enums.ProviderStatus | null
    toStatus: $Enums.ProviderStatus | null
    reason: string | null
    changedById: string | null
    createdAt: Date | null
  }

  export type ProviderStatusHistoryCountAggregateOutputType = {
    id: number
    providerId: number
    fromStatus: number
    toStatus: number
    reason: number
    changedById: number
    createdAt: number
    _all: number
  }


  export type ProviderStatusHistoryMinAggregateInputType = {
    id?: true
    providerId?: true
    fromStatus?: true
    toStatus?: true
    reason?: true
    changedById?: true
    createdAt?: true
  }

  export type ProviderStatusHistoryMaxAggregateInputType = {
    id?: true
    providerId?: true
    fromStatus?: true
    toStatus?: true
    reason?: true
    changedById?: true
    createdAt?: true
  }

  export type ProviderStatusHistoryCountAggregateInputType = {
    id?: true
    providerId?: true
    fromStatus?: true
    toStatus?: true
    reason?: true
    changedById?: true
    createdAt?: true
    _all?: true
  }

  export type ProviderStatusHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProviderStatusHistory to aggregate.
     */
    where?: ProviderStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderStatusHistories to fetch.
     */
    orderBy?: ProviderStatusHistoryOrderByWithRelationInput | ProviderStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProviderStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderStatusHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProviderStatusHistories
    **/
    _count?: true | ProviderStatusHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProviderStatusHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProviderStatusHistoryMaxAggregateInputType
  }

  export type GetProviderStatusHistoryAggregateType<T extends ProviderStatusHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateProviderStatusHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProviderStatusHistory[P]>
      : GetScalarType<T[P], AggregateProviderStatusHistory[P]>
  }




  export type ProviderStatusHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProviderStatusHistoryWhereInput
    orderBy?: ProviderStatusHistoryOrderByWithAggregationInput | ProviderStatusHistoryOrderByWithAggregationInput[]
    by: ProviderStatusHistoryScalarFieldEnum[] | ProviderStatusHistoryScalarFieldEnum
    having?: ProviderStatusHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProviderStatusHistoryCountAggregateInputType | true
    _min?: ProviderStatusHistoryMinAggregateInputType
    _max?: ProviderStatusHistoryMaxAggregateInputType
  }

  export type ProviderStatusHistoryGroupByOutputType = {
    id: string
    providerId: string
    fromStatus: $Enums.ProviderStatus
    toStatus: $Enums.ProviderStatus
    reason: string | null
    changedById: string
    createdAt: Date
    _count: ProviderStatusHistoryCountAggregateOutputType | null
    _min: ProviderStatusHistoryMinAggregateOutputType | null
    _max: ProviderStatusHistoryMaxAggregateOutputType | null
  }

  type GetProviderStatusHistoryGroupByPayload<T extends ProviderStatusHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProviderStatusHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProviderStatusHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProviderStatusHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], ProviderStatusHistoryGroupByOutputType[P]>
        }
      >
    >


  export type ProviderStatusHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    fromStatus?: boolean
    toStatus?: boolean
    reason?: boolean
    changedById?: boolean
    createdAt?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    changedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["providerStatusHistory"]>

  export type ProviderStatusHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    fromStatus?: boolean
    toStatus?: boolean
    reason?: boolean
    changedById?: boolean
    createdAt?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    changedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["providerStatusHistory"]>

  export type ProviderStatusHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    fromStatus?: boolean
    toStatus?: boolean
    reason?: boolean
    changedById?: boolean
    createdAt?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    changedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["providerStatusHistory"]>

  export type ProviderStatusHistorySelectScalar = {
    id?: boolean
    providerId?: boolean
    fromStatus?: boolean
    toStatus?: boolean
    reason?: boolean
    changedById?: boolean
    createdAt?: boolean
  }

  export type ProviderStatusHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "providerId" | "fromStatus" | "toStatus" | "reason" | "changedById" | "createdAt", ExtArgs["result"]["providerStatusHistory"]>
  export type ProviderStatusHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    changedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProviderStatusHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    changedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProviderStatusHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    changedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProviderStatusHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProviderStatusHistory"
    objects: {
      provider: Prisma.$ProviderPayload<ExtArgs>
      changedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      providerId: string
      fromStatus: $Enums.ProviderStatus
      toStatus: $Enums.ProviderStatus
      reason: string | null
      changedById: string
      createdAt: Date
    }, ExtArgs["result"]["providerStatusHistory"]>
    composites: {}
  }

  type ProviderStatusHistoryGetPayload<S extends boolean | null | undefined | ProviderStatusHistoryDefaultArgs> = $Result.GetResult<Prisma.$ProviderStatusHistoryPayload, S>

  type ProviderStatusHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProviderStatusHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProviderStatusHistoryCountAggregateInputType | true
    }

  export interface ProviderStatusHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProviderStatusHistory'], meta: { name: 'ProviderStatusHistory' } }
    /**
     * Find zero or one ProviderStatusHistory that matches the filter.
     * @param {ProviderStatusHistoryFindUniqueArgs} args - Arguments to find a ProviderStatusHistory
     * @example
     * // Get one ProviderStatusHistory
     * const providerStatusHistory = await prisma.providerStatusHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProviderStatusHistoryFindUniqueArgs>(args: SelectSubset<T, ProviderStatusHistoryFindUniqueArgs<ExtArgs>>): Prisma__ProviderStatusHistoryClient<$Result.GetResult<Prisma.$ProviderStatusHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProviderStatusHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProviderStatusHistoryFindUniqueOrThrowArgs} args - Arguments to find a ProviderStatusHistory
     * @example
     * // Get one ProviderStatusHistory
     * const providerStatusHistory = await prisma.providerStatusHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProviderStatusHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ProviderStatusHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProviderStatusHistoryClient<$Result.GetResult<Prisma.$ProviderStatusHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProviderStatusHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderStatusHistoryFindFirstArgs} args - Arguments to find a ProviderStatusHistory
     * @example
     * // Get one ProviderStatusHistory
     * const providerStatusHistory = await prisma.providerStatusHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProviderStatusHistoryFindFirstArgs>(args?: SelectSubset<T, ProviderStatusHistoryFindFirstArgs<ExtArgs>>): Prisma__ProviderStatusHistoryClient<$Result.GetResult<Prisma.$ProviderStatusHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProviderStatusHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderStatusHistoryFindFirstOrThrowArgs} args - Arguments to find a ProviderStatusHistory
     * @example
     * // Get one ProviderStatusHistory
     * const providerStatusHistory = await prisma.providerStatusHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProviderStatusHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ProviderStatusHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProviderStatusHistoryClient<$Result.GetResult<Prisma.$ProviderStatusHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProviderStatusHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderStatusHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProviderStatusHistories
     * const providerStatusHistories = await prisma.providerStatusHistory.findMany()
     * 
     * // Get first 10 ProviderStatusHistories
     * const providerStatusHistories = await prisma.providerStatusHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const providerStatusHistoryWithIdOnly = await prisma.providerStatusHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProviderStatusHistoryFindManyArgs>(args?: SelectSubset<T, ProviderStatusHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderStatusHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProviderStatusHistory.
     * @param {ProviderStatusHistoryCreateArgs} args - Arguments to create a ProviderStatusHistory.
     * @example
     * // Create one ProviderStatusHistory
     * const ProviderStatusHistory = await prisma.providerStatusHistory.create({
     *   data: {
     *     // ... data to create a ProviderStatusHistory
     *   }
     * })
     * 
     */
    create<T extends ProviderStatusHistoryCreateArgs>(args: SelectSubset<T, ProviderStatusHistoryCreateArgs<ExtArgs>>): Prisma__ProviderStatusHistoryClient<$Result.GetResult<Prisma.$ProviderStatusHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProviderStatusHistories.
     * @param {ProviderStatusHistoryCreateManyArgs} args - Arguments to create many ProviderStatusHistories.
     * @example
     * // Create many ProviderStatusHistories
     * const providerStatusHistory = await prisma.providerStatusHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProviderStatusHistoryCreateManyArgs>(args?: SelectSubset<T, ProviderStatusHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProviderStatusHistories and returns the data saved in the database.
     * @param {ProviderStatusHistoryCreateManyAndReturnArgs} args - Arguments to create many ProviderStatusHistories.
     * @example
     * // Create many ProviderStatusHistories
     * const providerStatusHistory = await prisma.providerStatusHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProviderStatusHistories and only return the `id`
     * const providerStatusHistoryWithIdOnly = await prisma.providerStatusHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProviderStatusHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ProviderStatusHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderStatusHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProviderStatusHistory.
     * @param {ProviderStatusHistoryDeleteArgs} args - Arguments to delete one ProviderStatusHistory.
     * @example
     * // Delete one ProviderStatusHistory
     * const ProviderStatusHistory = await prisma.providerStatusHistory.delete({
     *   where: {
     *     // ... filter to delete one ProviderStatusHistory
     *   }
     * })
     * 
     */
    delete<T extends ProviderStatusHistoryDeleteArgs>(args: SelectSubset<T, ProviderStatusHistoryDeleteArgs<ExtArgs>>): Prisma__ProviderStatusHistoryClient<$Result.GetResult<Prisma.$ProviderStatusHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProviderStatusHistory.
     * @param {ProviderStatusHistoryUpdateArgs} args - Arguments to update one ProviderStatusHistory.
     * @example
     * // Update one ProviderStatusHistory
     * const providerStatusHistory = await prisma.providerStatusHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProviderStatusHistoryUpdateArgs>(args: SelectSubset<T, ProviderStatusHistoryUpdateArgs<ExtArgs>>): Prisma__ProviderStatusHistoryClient<$Result.GetResult<Prisma.$ProviderStatusHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProviderStatusHistories.
     * @param {ProviderStatusHistoryDeleteManyArgs} args - Arguments to filter ProviderStatusHistories to delete.
     * @example
     * // Delete a few ProviderStatusHistories
     * const { count } = await prisma.providerStatusHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProviderStatusHistoryDeleteManyArgs>(args?: SelectSubset<T, ProviderStatusHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProviderStatusHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderStatusHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProviderStatusHistories
     * const providerStatusHistory = await prisma.providerStatusHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProviderStatusHistoryUpdateManyArgs>(args: SelectSubset<T, ProviderStatusHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProviderStatusHistories and returns the data updated in the database.
     * @param {ProviderStatusHistoryUpdateManyAndReturnArgs} args - Arguments to update many ProviderStatusHistories.
     * @example
     * // Update many ProviderStatusHistories
     * const providerStatusHistory = await prisma.providerStatusHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProviderStatusHistories and only return the `id`
     * const providerStatusHistoryWithIdOnly = await prisma.providerStatusHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProviderStatusHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ProviderStatusHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderStatusHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProviderStatusHistory.
     * @param {ProviderStatusHistoryUpsertArgs} args - Arguments to update or create a ProviderStatusHistory.
     * @example
     * // Update or create a ProviderStatusHistory
     * const providerStatusHistory = await prisma.providerStatusHistory.upsert({
     *   create: {
     *     // ... data to create a ProviderStatusHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProviderStatusHistory we want to update
     *   }
     * })
     */
    upsert<T extends ProviderStatusHistoryUpsertArgs>(args: SelectSubset<T, ProviderStatusHistoryUpsertArgs<ExtArgs>>): Prisma__ProviderStatusHistoryClient<$Result.GetResult<Prisma.$ProviderStatusHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProviderStatusHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderStatusHistoryCountArgs} args - Arguments to filter ProviderStatusHistories to count.
     * @example
     * // Count the number of ProviderStatusHistories
     * const count = await prisma.providerStatusHistory.count({
     *   where: {
     *     // ... the filter for the ProviderStatusHistories we want to count
     *   }
     * })
    **/
    count<T extends ProviderStatusHistoryCountArgs>(
      args?: Subset<T, ProviderStatusHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProviderStatusHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProviderStatusHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderStatusHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProviderStatusHistoryAggregateArgs>(args: Subset<T, ProviderStatusHistoryAggregateArgs>): Prisma.PrismaPromise<GetProviderStatusHistoryAggregateType<T>>

    /**
     * Group by ProviderStatusHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderStatusHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProviderStatusHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProviderStatusHistoryGroupByArgs['orderBy'] }
        : { orderBy?: ProviderStatusHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProviderStatusHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProviderStatusHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProviderStatusHistory model
   */
  readonly fields: ProviderStatusHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProviderStatusHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProviderStatusHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    provider<T extends ProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProviderDefaultArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    changedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProviderStatusHistory model
   */
  interface ProviderStatusHistoryFieldRefs {
    readonly id: FieldRef<"ProviderStatusHistory", 'String'>
    readonly providerId: FieldRef<"ProviderStatusHistory", 'String'>
    readonly fromStatus: FieldRef<"ProviderStatusHistory", 'ProviderStatus'>
    readonly toStatus: FieldRef<"ProviderStatusHistory", 'ProviderStatus'>
    readonly reason: FieldRef<"ProviderStatusHistory", 'String'>
    readonly changedById: FieldRef<"ProviderStatusHistory", 'String'>
    readonly createdAt: FieldRef<"ProviderStatusHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProviderStatusHistory findUnique
   */
  export type ProviderStatusHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderStatusHistory
     */
    select?: ProviderStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderStatusHistory
     */
    omit?: ProviderStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ProviderStatusHistory to fetch.
     */
    where: ProviderStatusHistoryWhereUniqueInput
  }

  /**
   * ProviderStatusHistory findUniqueOrThrow
   */
  export type ProviderStatusHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderStatusHistory
     */
    select?: ProviderStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderStatusHistory
     */
    omit?: ProviderStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ProviderStatusHistory to fetch.
     */
    where: ProviderStatusHistoryWhereUniqueInput
  }

  /**
   * ProviderStatusHistory findFirst
   */
  export type ProviderStatusHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderStatusHistory
     */
    select?: ProviderStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderStatusHistory
     */
    omit?: ProviderStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ProviderStatusHistory to fetch.
     */
    where?: ProviderStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderStatusHistories to fetch.
     */
    orderBy?: ProviderStatusHistoryOrderByWithRelationInput | ProviderStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProviderStatusHistories.
     */
    cursor?: ProviderStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderStatusHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProviderStatusHistories.
     */
    distinct?: ProviderStatusHistoryScalarFieldEnum | ProviderStatusHistoryScalarFieldEnum[]
  }

  /**
   * ProviderStatusHistory findFirstOrThrow
   */
  export type ProviderStatusHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderStatusHistory
     */
    select?: ProviderStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderStatusHistory
     */
    omit?: ProviderStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ProviderStatusHistory to fetch.
     */
    where?: ProviderStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderStatusHistories to fetch.
     */
    orderBy?: ProviderStatusHistoryOrderByWithRelationInput | ProviderStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProviderStatusHistories.
     */
    cursor?: ProviderStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderStatusHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProviderStatusHistories.
     */
    distinct?: ProviderStatusHistoryScalarFieldEnum | ProviderStatusHistoryScalarFieldEnum[]
  }

  /**
   * ProviderStatusHistory findMany
   */
  export type ProviderStatusHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderStatusHistory
     */
    select?: ProviderStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderStatusHistory
     */
    omit?: ProviderStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ProviderStatusHistories to fetch.
     */
    where?: ProviderStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderStatusHistories to fetch.
     */
    orderBy?: ProviderStatusHistoryOrderByWithRelationInput | ProviderStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProviderStatusHistories.
     */
    cursor?: ProviderStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderStatusHistories.
     */
    skip?: number
    distinct?: ProviderStatusHistoryScalarFieldEnum | ProviderStatusHistoryScalarFieldEnum[]
  }

  /**
   * ProviderStatusHistory create
   */
  export type ProviderStatusHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderStatusHistory
     */
    select?: ProviderStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderStatusHistory
     */
    omit?: ProviderStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderStatusHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ProviderStatusHistory.
     */
    data: XOR<ProviderStatusHistoryCreateInput, ProviderStatusHistoryUncheckedCreateInput>
  }

  /**
   * ProviderStatusHistory createMany
   */
  export type ProviderStatusHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProviderStatusHistories.
     */
    data: ProviderStatusHistoryCreateManyInput | ProviderStatusHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProviderStatusHistory createManyAndReturn
   */
  export type ProviderStatusHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderStatusHistory
     */
    select?: ProviderStatusHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderStatusHistory
     */
    omit?: ProviderStatusHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many ProviderStatusHistories.
     */
    data: ProviderStatusHistoryCreateManyInput | ProviderStatusHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderStatusHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProviderStatusHistory update
   */
  export type ProviderStatusHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderStatusHistory
     */
    select?: ProviderStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderStatusHistory
     */
    omit?: ProviderStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderStatusHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ProviderStatusHistory.
     */
    data: XOR<ProviderStatusHistoryUpdateInput, ProviderStatusHistoryUncheckedUpdateInput>
    /**
     * Choose, which ProviderStatusHistory to update.
     */
    where: ProviderStatusHistoryWhereUniqueInput
  }

  /**
   * ProviderStatusHistory updateMany
   */
  export type ProviderStatusHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProviderStatusHistories.
     */
    data: XOR<ProviderStatusHistoryUpdateManyMutationInput, ProviderStatusHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ProviderStatusHistories to update
     */
    where?: ProviderStatusHistoryWhereInput
    /**
     * Limit how many ProviderStatusHistories to update.
     */
    limit?: number
  }

  /**
   * ProviderStatusHistory updateManyAndReturn
   */
  export type ProviderStatusHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderStatusHistory
     */
    select?: ProviderStatusHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderStatusHistory
     */
    omit?: ProviderStatusHistoryOmit<ExtArgs> | null
    /**
     * The data used to update ProviderStatusHistories.
     */
    data: XOR<ProviderStatusHistoryUpdateManyMutationInput, ProviderStatusHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ProviderStatusHistories to update
     */
    where?: ProviderStatusHistoryWhereInput
    /**
     * Limit how many ProviderStatusHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderStatusHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProviderStatusHistory upsert
   */
  export type ProviderStatusHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderStatusHistory
     */
    select?: ProviderStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderStatusHistory
     */
    omit?: ProviderStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderStatusHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ProviderStatusHistory to update in case it exists.
     */
    where: ProviderStatusHistoryWhereUniqueInput
    /**
     * In case the ProviderStatusHistory found by the `where` argument doesn't exist, create a new ProviderStatusHistory with this data.
     */
    create: XOR<ProviderStatusHistoryCreateInput, ProviderStatusHistoryUncheckedCreateInput>
    /**
     * In case the ProviderStatusHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProviderStatusHistoryUpdateInput, ProviderStatusHistoryUncheckedUpdateInput>
  }

  /**
   * ProviderStatusHistory delete
   */
  export type ProviderStatusHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderStatusHistory
     */
    select?: ProviderStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderStatusHistory
     */
    omit?: ProviderStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter which ProviderStatusHistory to delete.
     */
    where: ProviderStatusHistoryWhereUniqueInput
  }

  /**
   * ProviderStatusHistory deleteMany
   */
  export type ProviderStatusHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProviderStatusHistories to delete
     */
    where?: ProviderStatusHistoryWhereInput
    /**
     * Limit how many ProviderStatusHistories to delete.
     */
    limit?: number
  }

  /**
   * ProviderStatusHistory without action
   */
  export type ProviderStatusHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderStatusHistory
     */
    select?: ProviderStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderStatusHistory
     */
    omit?: ProviderStatusHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderStatusHistoryInclude<ExtArgs> | null
  }


  /**
   * Model SystemFeedback
   */

  export type AggregateSystemFeedback = {
    _count: SystemFeedbackCountAggregateOutputType | null
    _avg: SystemFeedbackAvgAggregateOutputType | null
    _sum: SystemFeedbackSumAggregateOutputType | null
    _min: SystemFeedbackMinAggregateOutputType | null
    _max: SystemFeedbackMaxAggregateOutputType | null
  }

  export type SystemFeedbackAvgAggregateOutputType = {
    satisfactionRating: number | null
  }

  export type SystemFeedbackSumAggregateOutputType = {
    satisfactionRating: number | null
  }

  export type SystemFeedbackMinAggregateOutputType = {
    id: string | null
    userId: string | null
    category: $Enums.FeedbackCategory | null
    priority: $Enums.FeedbackPriority | null
    title: string | null
    message: string | null
    satisfactionRating: number | null
    adminResponse: string | null
    respondedAt: Date | null
    respondedById: string | null
    isRead: boolean | null
    isResolved: boolean | null
    resolvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemFeedbackMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    category: $Enums.FeedbackCategory | null
    priority: $Enums.FeedbackPriority | null
    title: string | null
    message: string | null
    satisfactionRating: number | null
    adminResponse: string | null
    respondedAt: Date | null
    respondedById: string | null
    isRead: boolean | null
    isResolved: boolean | null
    resolvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemFeedbackCountAggregateOutputType = {
    id: number
    userId: number
    category: number
    priority: number
    title: number
    message: number
    satisfactionRating: number
    adminResponse: number
    respondedAt: number
    respondedById: number
    isRead: number
    isResolved: number
    resolvedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SystemFeedbackAvgAggregateInputType = {
    satisfactionRating?: true
  }

  export type SystemFeedbackSumAggregateInputType = {
    satisfactionRating?: true
  }

  export type SystemFeedbackMinAggregateInputType = {
    id?: true
    userId?: true
    category?: true
    priority?: true
    title?: true
    message?: true
    satisfactionRating?: true
    adminResponse?: true
    respondedAt?: true
    respondedById?: true
    isRead?: true
    isResolved?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemFeedbackMaxAggregateInputType = {
    id?: true
    userId?: true
    category?: true
    priority?: true
    title?: true
    message?: true
    satisfactionRating?: true
    adminResponse?: true
    respondedAt?: true
    respondedById?: true
    isRead?: true
    isResolved?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemFeedbackCountAggregateInputType = {
    id?: true
    userId?: true
    category?: true
    priority?: true
    title?: true
    message?: true
    satisfactionRating?: true
    adminResponse?: true
    respondedAt?: true
    respondedById?: true
    isRead?: true
    isResolved?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemFeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemFeedback to aggregate.
     */
    where?: SystemFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemFeedbacks to fetch.
     */
    orderBy?: SystemFeedbackOrderByWithRelationInput | SystemFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemFeedbacks
    **/
    _count?: true | SystemFeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemFeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemFeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemFeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemFeedbackMaxAggregateInputType
  }

  export type GetSystemFeedbackAggregateType<T extends SystemFeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemFeedback[P]>
      : GetScalarType<T[P], AggregateSystemFeedback[P]>
  }




  export type SystemFeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemFeedbackWhereInput
    orderBy?: SystemFeedbackOrderByWithAggregationInput | SystemFeedbackOrderByWithAggregationInput[]
    by: SystemFeedbackScalarFieldEnum[] | SystemFeedbackScalarFieldEnum
    having?: SystemFeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemFeedbackCountAggregateInputType | true
    _avg?: SystemFeedbackAvgAggregateInputType
    _sum?: SystemFeedbackSumAggregateInputType
    _min?: SystemFeedbackMinAggregateInputType
    _max?: SystemFeedbackMaxAggregateInputType
  }

  export type SystemFeedbackGroupByOutputType = {
    id: string
    userId: string
    category: $Enums.FeedbackCategory
    priority: $Enums.FeedbackPriority | null
    title: string
    message: string
    satisfactionRating: number | null
    adminResponse: string | null
    respondedAt: Date | null
    respondedById: string | null
    isRead: boolean
    isResolved: boolean
    resolvedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SystemFeedbackCountAggregateOutputType | null
    _avg: SystemFeedbackAvgAggregateOutputType | null
    _sum: SystemFeedbackSumAggregateOutputType | null
    _min: SystemFeedbackMinAggregateOutputType | null
    _max: SystemFeedbackMaxAggregateOutputType | null
  }

  type GetSystemFeedbackGroupByPayload<T extends SystemFeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemFeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemFeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemFeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], SystemFeedbackGroupByOutputType[P]>
        }
      >
    >


  export type SystemFeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    category?: boolean
    priority?: boolean
    title?: boolean
    message?: boolean
    satisfactionRating?: boolean
    adminResponse?: boolean
    respondedAt?: boolean
    respondedById?: boolean
    isRead?: boolean
    isResolved?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    respondedBy?: boolean | SystemFeedback$respondedByArgs<ExtArgs>
  }, ExtArgs["result"]["systemFeedback"]>

  export type SystemFeedbackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    category?: boolean
    priority?: boolean
    title?: boolean
    message?: boolean
    satisfactionRating?: boolean
    adminResponse?: boolean
    respondedAt?: boolean
    respondedById?: boolean
    isRead?: boolean
    isResolved?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    respondedBy?: boolean | SystemFeedback$respondedByArgs<ExtArgs>
  }, ExtArgs["result"]["systemFeedback"]>

  export type SystemFeedbackSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    category?: boolean
    priority?: boolean
    title?: boolean
    message?: boolean
    satisfactionRating?: boolean
    adminResponse?: boolean
    respondedAt?: boolean
    respondedById?: boolean
    isRead?: boolean
    isResolved?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    respondedBy?: boolean | SystemFeedback$respondedByArgs<ExtArgs>
  }, ExtArgs["result"]["systemFeedback"]>

  export type SystemFeedbackSelectScalar = {
    id?: boolean
    userId?: boolean
    category?: boolean
    priority?: boolean
    title?: boolean
    message?: boolean
    satisfactionRating?: boolean
    adminResponse?: boolean
    respondedAt?: boolean
    respondedById?: boolean
    isRead?: boolean
    isResolved?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SystemFeedbackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "category" | "priority" | "title" | "message" | "satisfactionRating" | "adminResponse" | "respondedAt" | "respondedById" | "isRead" | "isResolved" | "resolvedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["systemFeedback"]>
  export type SystemFeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    respondedBy?: boolean | SystemFeedback$respondedByArgs<ExtArgs>
  }
  export type SystemFeedbackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    respondedBy?: boolean | SystemFeedback$respondedByArgs<ExtArgs>
  }
  export type SystemFeedbackIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    respondedBy?: boolean | SystemFeedback$respondedByArgs<ExtArgs>
  }

  export type $SystemFeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemFeedback"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      respondedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      category: $Enums.FeedbackCategory
      priority: $Enums.FeedbackPriority | null
      title: string
      message: string
      satisfactionRating: number | null
      adminResponse: string | null
      respondedAt: Date | null
      respondedById: string | null
      isRead: boolean
      isResolved: boolean
      resolvedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["systemFeedback"]>
    composites: {}
  }

  type SystemFeedbackGetPayload<S extends boolean | null | undefined | SystemFeedbackDefaultArgs> = $Result.GetResult<Prisma.$SystemFeedbackPayload, S>

  type SystemFeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemFeedbackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemFeedbackCountAggregateInputType | true
    }

  export interface SystemFeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemFeedback'], meta: { name: 'SystemFeedback' } }
    /**
     * Find zero or one SystemFeedback that matches the filter.
     * @param {SystemFeedbackFindUniqueArgs} args - Arguments to find a SystemFeedback
     * @example
     * // Get one SystemFeedback
     * const systemFeedback = await prisma.systemFeedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemFeedbackFindUniqueArgs>(args: SelectSubset<T, SystemFeedbackFindUniqueArgs<ExtArgs>>): Prisma__SystemFeedbackClient<$Result.GetResult<Prisma.$SystemFeedbackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemFeedback that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemFeedbackFindUniqueOrThrowArgs} args - Arguments to find a SystemFeedback
     * @example
     * // Get one SystemFeedback
     * const systemFeedback = await prisma.systemFeedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemFeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemFeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemFeedbackClient<$Result.GetResult<Prisma.$SystemFeedbackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemFeedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemFeedbackFindFirstArgs} args - Arguments to find a SystemFeedback
     * @example
     * // Get one SystemFeedback
     * const systemFeedback = await prisma.systemFeedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemFeedbackFindFirstArgs>(args?: SelectSubset<T, SystemFeedbackFindFirstArgs<ExtArgs>>): Prisma__SystemFeedbackClient<$Result.GetResult<Prisma.$SystemFeedbackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemFeedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemFeedbackFindFirstOrThrowArgs} args - Arguments to find a SystemFeedback
     * @example
     * // Get one SystemFeedback
     * const systemFeedback = await prisma.systemFeedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemFeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemFeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemFeedbackClient<$Result.GetResult<Prisma.$SystemFeedbackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemFeedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemFeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemFeedbacks
     * const systemFeedbacks = await prisma.systemFeedback.findMany()
     * 
     * // Get first 10 SystemFeedbacks
     * const systemFeedbacks = await prisma.systemFeedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemFeedbackWithIdOnly = await prisma.systemFeedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemFeedbackFindManyArgs>(args?: SelectSubset<T, SystemFeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemFeedback.
     * @param {SystemFeedbackCreateArgs} args - Arguments to create a SystemFeedback.
     * @example
     * // Create one SystemFeedback
     * const SystemFeedback = await prisma.systemFeedback.create({
     *   data: {
     *     // ... data to create a SystemFeedback
     *   }
     * })
     * 
     */
    create<T extends SystemFeedbackCreateArgs>(args: SelectSubset<T, SystemFeedbackCreateArgs<ExtArgs>>): Prisma__SystemFeedbackClient<$Result.GetResult<Prisma.$SystemFeedbackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemFeedbacks.
     * @param {SystemFeedbackCreateManyArgs} args - Arguments to create many SystemFeedbacks.
     * @example
     * // Create many SystemFeedbacks
     * const systemFeedback = await prisma.systemFeedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemFeedbackCreateManyArgs>(args?: SelectSubset<T, SystemFeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemFeedbacks and returns the data saved in the database.
     * @param {SystemFeedbackCreateManyAndReturnArgs} args - Arguments to create many SystemFeedbacks.
     * @example
     * // Create many SystemFeedbacks
     * const systemFeedback = await prisma.systemFeedback.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemFeedbacks and only return the `id`
     * const systemFeedbackWithIdOnly = await prisma.systemFeedback.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemFeedbackCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemFeedbackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemFeedbackPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemFeedback.
     * @param {SystemFeedbackDeleteArgs} args - Arguments to delete one SystemFeedback.
     * @example
     * // Delete one SystemFeedback
     * const SystemFeedback = await prisma.systemFeedback.delete({
     *   where: {
     *     // ... filter to delete one SystemFeedback
     *   }
     * })
     * 
     */
    delete<T extends SystemFeedbackDeleteArgs>(args: SelectSubset<T, SystemFeedbackDeleteArgs<ExtArgs>>): Prisma__SystemFeedbackClient<$Result.GetResult<Prisma.$SystemFeedbackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemFeedback.
     * @param {SystemFeedbackUpdateArgs} args - Arguments to update one SystemFeedback.
     * @example
     * // Update one SystemFeedback
     * const systemFeedback = await prisma.systemFeedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemFeedbackUpdateArgs>(args: SelectSubset<T, SystemFeedbackUpdateArgs<ExtArgs>>): Prisma__SystemFeedbackClient<$Result.GetResult<Prisma.$SystemFeedbackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemFeedbacks.
     * @param {SystemFeedbackDeleteManyArgs} args - Arguments to filter SystemFeedbacks to delete.
     * @example
     * // Delete a few SystemFeedbacks
     * const { count } = await prisma.systemFeedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemFeedbackDeleteManyArgs>(args?: SelectSubset<T, SystemFeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemFeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemFeedbacks
     * const systemFeedback = await prisma.systemFeedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemFeedbackUpdateManyArgs>(args: SelectSubset<T, SystemFeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemFeedbacks and returns the data updated in the database.
     * @param {SystemFeedbackUpdateManyAndReturnArgs} args - Arguments to update many SystemFeedbacks.
     * @example
     * // Update many SystemFeedbacks
     * const systemFeedback = await prisma.systemFeedback.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemFeedbacks and only return the `id`
     * const systemFeedbackWithIdOnly = await prisma.systemFeedback.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemFeedbackUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemFeedbackUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemFeedbackPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemFeedback.
     * @param {SystemFeedbackUpsertArgs} args - Arguments to update or create a SystemFeedback.
     * @example
     * // Update or create a SystemFeedback
     * const systemFeedback = await prisma.systemFeedback.upsert({
     *   create: {
     *     // ... data to create a SystemFeedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemFeedback we want to update
     *   }
     * })
     */
    upsert<T extends SystemFeedbackUpsertArgs>(args: SelectSubset<T, SystemFeedbackUpsertArgs<ExtArgs>>): Prisma__SystemFeedbackClient<$Result.GetResult<Prisma.$SystemFeedbackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemFeedbackCountArgs} args - Arguments to filter SystemFeedbacks to count.
     * @example
     * // Count the number of SystemFeedbacks
     * const count = await prisma.systemFeedback.count({
     *   where: {
     *     // ... the filter for the SystemFeedbacks we want to count
     *   }
     * })
    **/
    count<T extends SystemFeedbackCountArgs>(
      args?: Subset<T, SystemFeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemFeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemFeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemFeedbackAggregateArgs>(args: Subset<T, SystemFeedbackAggregateArgs>): Prisma.PrismaPromise<GetSystemFeedbackAggregateType<T>>

    /**
     * Group by SystemFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemFeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemFeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemFeedbackGroupByArgs['orderBy'] }
        : { orderBy?: SystemFeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemFeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemFeedback model
   */
  readonly fields: SystemFeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemFeedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemFeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    respondedBy<T extends SystemFeedback$respondedByArgs<ExtArgs> = {}>(args?: Subset<T, SystemFeedback$respondedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemFeedback model
   */
  interface SystemFeedbackFieldRefs {
    readonly id: FieldRef<"SystemFeedback", 'String'>
    readonly userId: FieldRef<"SystemFeedback", 'String'>
    readonly category: FieldRef<"SystemFeedback", 'FeedbackCategory'>
    readonly priority: FieldRef<"SystemFeedback", 'FeedbackPriority'>
    readonly title: FieldRef<"SystemFeedback", 'String'>
    readonly message: FieldRef<"SystemFeedback", 'String'>
    readonly satisfactionRating: FieldRef<"SystemFeedback", 'Int'>
    readonly adminResponse: FieldRef<"SystemFeedback", 'String'>
    readonly respondedAt: FieldRef<"SystemFeedback", 'DateTime'>
    readonly respondedById: FieldRef<"SystemFeedback", 'String'>
    readonly isRead: FieldRef<"SystemFeedback", 'Boolean'>
    readonly isResolved: FieldRef<"SystemFeedback", 'Boolean'>
    readonly resolvedAt: FieldRef<"SystemFeedback", 'DateTime'>
    readonly createdAt: FieldRef<"SystemFeedback", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemFeedback", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemFeedback findUnique
   */
  export type SystemFeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemFeedback
     */
    select?: SystemFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemFeedback
     */
    omit?: SystemFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which SystemFeedback to fetch.
     */
    where: SystemFeedbackWhereUniqueInput
  }

  /**
   * SystemFeedback findUniqueOrThrow
   */
  export type SystemFeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemFeedback
     */
    select?: SystemFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemFeedback
     */
    omit?: SystemFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which SystemFeedback to fetch.
     */
    where: SystemFeedbackWhereUniqueInput
  }

  /**
   * SystemFeedback findFirst
   */
  export type SystemFeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemFeedback
     */
    select?: SystemFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemFeedback
     */
    omit?: SystemFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which SystemFeedback to fetch.
     */
    where?: SystemFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemFeedbacks to fetch.
     */
    orderBy?: SystemFeedbackOrderByWithRelationInput | SystemFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemFeedbacks.
     */
    cursor?: SystemFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemFeedbacks.
     */
    distinct?: SystemFeedbackScalarFieldEnum | SystemFeedbackScalarFieldEnum[]
  }

  /**
   * SystemFeedback findFirstOrThrow
   */
  export type SystemFeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemFeedback
     */
    select?: SystemFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemFeedback
     */
    omit?: SystemFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which SystemFeedback to fetch.
     */
    where?: SystemFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemFeedbacks to fetch.
     */
    orderBy?: SystemFeedbackOrderByWithRelationInput | SystemFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemFeedbacks.
     */
    cursor?: SystemFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemFeedbacks.
     */
    distinct?: SystemFeedbackScalarFieldEnum | SystemFeedbackScalarFieldEnum[]
  }

  /**
   * SystemFeedback findMany
   */
  export type SystemFeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemFeedback
     */
    select?: SystemFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemFeedback
     */
    omit?: SystemFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which SystemFeedbacks to fetch.
     */
    where?: SystemFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemFeedbacks to fetch.
     */
    orderBy?: SystemFeedbackOrderByWithRelationInput | SystemFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemFeedbacks.
     */
    cursor?: SystemFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemFeedbacks.
     */
    skip?: number
    distinct?: SystemFeedbackScalarFieldEnum | SystemFeedbackScalarFieldEnum[]
  }

  /**
   * SystemFeedback create
   */
  export type SystemFeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemFeedback
     */
    select?: SystemFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemFeedback
     */
    omit?: SystemFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a SystemFeedback.
     */
    data: XOR<SystemFeedbackCreateInput, SystemFeedbackUncheckedCreateInput>
  }

  /**
   * SystemFeedback createMany
   */
  export type SystemFeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemFeedbacks.
     */
    data: SystemFeedbackCreateManyInput | SystemFeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemFeedback createManyAndReturn
   */
  export type SystemFeedbackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemFeedback
     */
    select?: SystemFeedbackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemFeedback
     */
    omit?: SystemFeedbackOmit<ExtArgs> | null
    /**
     * The data used to create many SystemFeedbacks.
     */
    data: SystemFeedbackCreateManyInput | SystemFeedbackCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemFeedbackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SystemFeedback update
   */
  export type SystemFeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemFeedback
     */
    select?: SystemFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemFeedback
     */
    omit?: SystemFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a SystemFeedback.
     */
    data: XOR<SystemFeedbackUpdateInput, SystemFeedbackUncheckedUpdateInput>
    /**
     * Choose, which SystemFeedback to update.
     */
    where: SystemFeedbackWhereUniqueInput
  }

  /**
   * SystemFeedback updateMany
   */
  export type SystemFeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemFeedbacks.
     */
    data: XOR<SystemFeedbackUpdateManyMutationInput, SystemFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which SystemFeedbacks to update
     */
    where?: SystemFeedbackWhereInput
    /**
     * Limit how many SystemFeedbacks to update.
     */
    limit?: number
  }

  /**
   * SystemFeedback updateManyAndReturn
   */
  export type SystemFeedbackUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemFeedback
     */
    select?: SystemFeedbackSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemFeedback
     */
    omit?: SystemFeedbackOmit<ExtArgs> | null
    /**
     * The data used to update SystemFeedbacks.
     */
    data: XOR<SystemFeedbackUpdateManyMutationInput, SystemFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which SystemFeedbacks to update
     */
    where?: SystemFeedbackWhereInput
    /**
     * Limit how many SystemFeedbacks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemFeedbackIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SystemFeedback upsert
   */
  export type SystemFeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemFeedback
     */
    select?: SystemFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemFeedback
     */
    omit?: SystemFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemFeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the SystemFeedback to update in case it exists.
     */
    where: SystemFeedbackWhereUniqueInput
    /**
     * In case the SystemFeedback found by the `where` argument doesn't exist, create a new SystemFeedback with this data.
     */
    create: XOR<SystemFeedbackCreateInput, SystemFeedbackUncheckedCreateInput>
    /**
     * In case the SystemFeedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemFeedbackUpdateInput, SystemFeedbackUncheckedUpdateInput>
  }

  /**
   * SystemFeedback delete
   */
  export type SystemFeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemFeedback
     */
    select?: SystemFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemFeedback
     */
    omit?: SystemFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemFeedbackInclude<ExtArgs> | null
    /**
     * Filter which SystemFeedback to delete.
     */
    where: SystemFeedbackWhereUniqueInput
  }

  /**
   * SystemFeedback deleteMany
   */
  export type SystemFeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemFeedbacks to delete
     */
    where?: SystemFeedbackWhereInput
    /**
     * Limit how many SystemFeedbacks to delete.
     */
    limit?: number
  }

  /**
   * SystemFeedback.respondedBy
   */
  export type SystemFeedback$respondedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SystemFeedback without action
   */
  export type SystemFeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemFeedback
     */
    select?: SystemFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemFeedback
     */
    omit?: SystemFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemFeedbackInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    role: 'role',
    status: 'status',
    emailVerified: 'emailVerified',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    suspendedAt: 'suspendedAt',
    suspendReason: 'suspendReason',
    suspendedById: 'suspendedById'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    expiresAt: 'expiresAt',
    token: 'token',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    userId: 'userId'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    providerId: 'providerId',
    userId: 'userId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    idToken: 'idToken',
    accessTokenExpiresAt: 'accessTokenExpiresAt',
    refreshTokenExpiresAt: 'refreshTokenExpiresAt',
    scope: 'scope',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    icon: 'icon',
    color: 'color',
    isActive: 'isActive',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const ProviderScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    categoryId: 'categoryId',
    verifiedBy: 'verifiedBy',
    healthcareName: 'healthcareName',
    description: 'description',
    phoneNumber: 'phoneNumber',
    email: 'email',
    coverPhoto: 'coverPhoto',
    status: 'status',
    address: 'address',
    city: 'city',
    province: 'province',
    latitude: 'latitude',
    longitude: 'longitude',
    slotDuration: 'slotDuration',
    verifiedAt: 'verifiedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProviderScalarFieldEnum = (typeof ProviderScalarFieldEnum)[keyof typeof ProviderScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    providerId: 'providerId',
    name: 'name',
    description: 'description',
    type: 'type',
    pricingModel: 'pricingModel',
    fixedPrice: 'fixedPrice',
    priceMin: 'priceMin',
    priceMax: 'priceMax',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const ServicePackageScalarFieldEnum: {
    parentPackageId: 'parentPackageId',
    childServiceId: 'childServiceId',
    createdAt: 'createdAt'
  };

  export type ServicePackageScalarFieldEnum = (typeof ServicePackageScalarFieldEnum)[keyof typeof ServicePackageScalarFieldEnum]


  export const InsuranceProviderScalarFieldEnum: {
    id: 'id',
    name: 'name',
    isActive: 'isActive'
  };

  export type InsuranceProviderScalarFieldEnum = (typeof InsuranceProviderScalarFieldEnum)[keyof typeof InsuranceProviderScalarFieldEnum]


  export const ServiceInsuranceScalarFieldEnum: {
    serviceId: 'serviceId',
    insuranceProviderId: 'insuranceProviderId'
  };

  export type ServiceInsuranceScalarFieldEnum = (typeof ServiceInsuranceScalarFieldEnum)[keyof typeof ServiceInsuranceScalarFieldEnum]


  export const OperatingHourScalarFieldEnum: {
    id: 'id',
    providerId: 'providerId',
    dayOfWeek: 'dayOfWeek',
    startTime: 'startTime',
    endTime: 'endTime',
    isClosed: 'isClosed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OperatingHourScalarFieldEnum = (typeof OperatingHourScalarFieldEnum)[keyof typeof OperatingHourScalarFieldEnum]


  export const BreakTimeScalarFieldEnum: {
    id: 'id',
    providerId: 'providerId',
    name: 'name',
    dayOfWeek: 'dayOfWeek',
    startTime: 'startTime',
    endTime: 'endTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BreakTimeScalarFieldEnum = (typeof BreakTimeScalarFieldEnum)[keyof typeof BreakTimeScalarFieldEnum]


  export const AppointmentScalarFieldEnum: {
    id: 'id',
    appointmentNumber: 'appointmentNumber',
    userId: 'userId',
    providerId: 'providerId',
    startTime: 'startTime',
    endTime: 'endTime',
    status: 'status',
    notes: 'notes',
    totalPrice: 'totalPrice',
    patientName: 'patientName',
    patientEmail: 'patientEmail',
    patientPhone: 'patientPhone',
    activityNotes: 'activityNotes',
    cancelledAt: 'cancelledAt',
    cancellationReason: 'cancellationReason',
    cancelledBy: 'cancelledBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AppointmentScalarFieldEnum = (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum]


  export const AppointmentServiceScalarFieldEnum: {
    appointmentId: 'appointmentId',
    serviceId: 'serviceId',
    priceAtBooking: 'priceAtBooking',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AppointmentServiceScalarFieldEnum = (typeof AppointmentServiceScalarFieldEnum)[keyof typeof AppointmentServiceScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    providerId: 'providerId',
    documentType: 'documentType',
    filePath: 'filePath',
    verifiedAt: 'verifiedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    verificationStatus: 'verificationStatus',
    verifiedById: 'verifiedById',
    rejectionReason: 'rejectionReason'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    message: 'message',
    isRead: 'isRead',
    appointmentId: 'appointmentId',
    providerId: 'providerId',
    metadata: 'metadata',
    readAt: 'readAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    user1Id: 'user1Id',
    user2Id: 'user2Id',
    lastMessageAt: 'lastMessageAt',
    lastMessageContent: 'lastMessageContent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    senderId: 'senderId',
    content: 'content',
    status: 'status',
    readAt: 'readAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    appointmentId: 'appointmentId',
    userId: 'userId',
    providerId: 'providerId',
    rating: 'rating',
    comment: 'comment',
    isAnonymous: 'isAnonymous',
    professionalismRating: 'professionalismRating',
    cleanlinessRating: 'cleanlinessRating',
    waitTimeRating: 'waitTimeRating',
    valueRating: 'valueRating',
    providerResponse: 'providerResponse',
    respondedAt: 'respondedAt',
    isEdited: 'isEdited',
    editedAt: 'editedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const ReviewLikeScalarFieldEnum: {
    id: 'id',
    reviewId: 'reviewId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type ReviewLikeScalarFieldEnum = (typeof ReviewLikeScalarFieldEnum)[keyof typeof ReviewLikeScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    action: 'action',
    targetType: 'targetType',
    targetId: 'targetId',
    oldValue: 'oldValue',
    newValue: 'newValue',
    metadata: 'metadata',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const ProviderStatusHistoryScalarFieldEnum: {
    id: 'id',
    providerId: 'providerId',
    fromStatus: 'fromStatus',
    toStatus: 'toStatus',
    reason: 'reason',
    changedById: 'changedById',
    createdAt: 'createdAt'
  };

  export type ProviderStatusHistoryScalarFieldEnum = (typeof ProviderStatusHistoryScalarFieldEnum)[keyof typeof ProviderStatusHistoryScalarFieldEnum]


  export const SystemFeedbackScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    category: 'category',
    priority: 'priority',
    title: 'title',
    message: 'message',
    satisfactionRating: 'satisfactionRating',
    adminResponse: 'adminResponse',
    respondedAt: 'respondedAt',
    respondedById: 'respondedById',
    isRead: 'isRead',
    isResolved: 'isResolved',
    resolvedAt: 'resolvedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SystemFeedbackScalarFieldEnum = (typeof SystemFeedbackScalarFieldEnum)[keyof typeof SystemFeedbackScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'ProviderStatus'
   */
  export type EnumProviderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProviderStatus'>
    


  /**
   * Reference to a field of type 'ProviderStatus[]'
   */
  export type ListEnumProviderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProviderStatus[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'ServiceType'
   */
  export type EnumServiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceType'>
    


  /**
   * Reference to a field of type 'ServiceType[]'
   */
  export type ListEnumServiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceType[]'>
    


  /**
   * Reference to a field of type 'PricingModel'
   */
  export type EnumPricingModelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PricingModel'>
    


  /**
   * Reference to a field of type 'PricingModel[]'
   */
  export type ListEnumPricingModelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PricingModel[]'>
    


  /**
   * Reference to a field of type 'AppointmentStatus'
   */
  export type EnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus'>
    


  /**
   * Reference to a field of type 'AppointmentStatus[]'
   */
  export type ListEnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus[]'>
    


  /**
   * Reference to a field of type 'DocumentVerificationStatus'
   */
  export type EnumDocumentVerificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentVerificationStatus'>
    


  /**
   * Reference to a field of type 'DocumentVerificationStatus[]'
   */
  export type ListEnumDocumentVerificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentVerificationStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'MessageStatus'
   */
  export type EnumMessageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageStatus'>
    


  /**
   * Reference to a field of type 'MessageStatus[]'
   */
  export type ListEnumMessageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageStatus[]'>
    


  /**
   * Reference to a field of type 'FeedbackCategory'
   */
  export type EnumFeedbackCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackCategory'>
    


  /**
   * Reference to a field of type 'FeedbackCategory[]'
   */
  export type ListEnumFeedbackCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackCategory[]'>
    


  /**
   * Reference to a field of type 'FeedbackPriority'
   */
  export type EnumFeedbackPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackPriority'>
    


  /**
   * Reference to a field of type 'FeedbackPriority[]'
   */
  export type ListEnumFeedbackPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackPriority[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    suspendedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    suspendReason?: StringNullableFilter<"User"> | string | null
    suspendedById?: StringNullableFilter<"User"> | string | null
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    suspendedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    suspendedUsers?: UserListRelationFilter
    provider?: XOR<ProviderNullableScalarRelationFilter, ProviderWhereInput> | null
    verifiedProviders?: ProviderListRelationFilter
    appointments?: AppointmentListRelationFilter
    cancelledAppointments?: AppointmentListRelationFilter
    notifications?: NotificationListRelationFilter
    conversationsAsUser1?: ConversationListRelationFilter
    conversationsAsUser2?: ConversationListRelationFilter
    sentMessages?: MessageListRelationFilter
    reviews?: ReviewListRelationFilter
    reviewLikes?: ReviewLikeListRelationFilter
    feedbackSubmitted?: SystemFeedbackListRelationFilter
    feedbackResponses?: SystemFeedbackListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    providerStatusChanges?: ProviderStatusHistoryListRelationFilter
    verifiedDocuments?: DocumentListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
    status?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    suspendedAt?: SortOrderInput | SortOrder
    suspendReason?: SortOrderInput | SortOrder
    suspendedById?: SortOrderInput | SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    suspendedBy?: UserOrderByWithRelationInput
    suspendedUsers?: UserOrderByRelationAggregateInput
    provider?: ProviderOrderByWithRelationInput
    verifiedProviders?: ProviderOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
    cancelledAppointments?: AppointmentOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    conversationsAsUser1?: ConversationOrderByRelationAggregateInput
    conversationsAsUser2?: ConversationOrderByRelationAggregateInput
    sentMessages?: MessageOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    reviewLikes?: ReviewLikeOrderByRelationAggregateInput
    feedbackSubmitted?: SystemFeedbackOrderByRelationAggregateInput
    feedbackResponses?: SystemFeedbackOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    providerStatusChanges?: ProviderStatusHistoryOrderByRelationAggregateInput
    verifiedDocuments?: DocumentOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    suspendedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    suspendReason?: StringNullableFilter<"User"> | string | null
    suspendedById?: StringNullableFilter<"User"> | string | null
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    suspendedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    suspendedUsers?: UserListRelationFilter
    provider?: XOR<ProviderNullableScalarRelationFilter, ProviderWhereInput> | null
    verifiedProviders?: ProviderListRelationFilter
    appointments?: AppointmentListRelationFilter
    cancelledAppointments?: AppointmentListRelationFilter
    notifications?: NotificationListRelationFilter
    conversationsAsUser1?: ConversationListRelationFilter
    conversationsAsUser2?: ConversationListRelationFilter
    sentMessages?: MessageListRelationFilter
    reviews?: ReviewListRelationFilter
    reviewLikes?: ReviewLikeListRelationFilter
    feedbackSubmitted?: SystemFeedbackListRelationFilter
    feedbackResponses?: SystemFeedbackListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    providerStatusChanges?: ProviderStatusHistoryListRelationFilter
    verifiedDocuments?: DocumentListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
    status?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    suspendedAt?: SortOrderInput | SortOrder
    suspendReason?: SortOrderInput | SortOrder
    suspendedById?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusWithAggregatesFilter<"User"> | $Enums.UserStatus
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    suspendedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    suspendReason?: StringNullableWithAggregatesFilter<"User"> | string | null
    suspendedById?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    token?: StringWithAggregatesFilter<"Session"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userId?: StringWithAggregatesFilter<"Session"> | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    accountId?: StringWithAggregatesFilter<"Account"> | string
    providerId?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    password?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    id?: StringFilter<"Verification"> | string
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }, "id">

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    OR?: VerificationScalarWhereWithAggregatesInput[]
    NOT?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verification"> | string
    identifier?: StringWithAggregatesFilter<"Verification"> | string
    value?: StringWithAggregatesFilter<"Verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    icon?: StringNullableFilter<"Category"> | string | null
    color?: StringFilter<"Category"> | string
    isActive?: BoolFilter<"Category"> | boolean
    sortOrder?: IntFilter<"Category"> | number
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    providers?: ProviderListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    providers?: ProviderOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    icon?: StringNullableFilter<"Category"> | string | null
    color?: StringFilter<"Category"> | string
    isActive?: BoolFilter<"Category"> | boolean
    sortOrder?: IntFilter<"Category"> | number
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    providers?: ProviderListRelationFilter
  }, "id" | "slug">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    slug?: StringWithAggregatesFilter<"Category"> | string
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
    icon?: StringNullableWithAggregatesFilter<"Category"> | string | null
    color?: StringWithAggregatesFilter<"Category"> | string
    isActive?: BoolWithAggregatesFilter<"Category"> | boolean
    sortOrder?: IntWithAggregatesFilter<"Category"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type ProviderWhereInput = {
    AND?: ProviderWhereInput | ProviderWhereInput[]
    OR?: ProviderWhereInput[]
    NOT?: ProviderWhereInput | ProviderWhereInput[]
    id?: StringFilter<"Provider"> | string
    userId?: StringFilter<"Provider"> | string
    categoryId?: StringNullableFilter<"Provider"> | string | null
    verifiedBy?: StringNullableFilter<"Provider"> | string | null
    healthcareName?: StringFilter<"Provider"> | string
    description?: StringNullableFilter<"Provider"> | string | null
    phoneNumber?: StringNullableFilter<"Provider"> | string | null
    email?: StringNullableFilter<"Provider"> | string | null
    coverPhoto?: StringNullableFilter<"Provider"> | string | null
    status?: EnumProviderStatusFilter<"Provider"> | $Enums.ProviderStatus
    address?: StringFilter<"Provider"> | string
    city?: StringFilter<"Provider"> | string
    province?: StringFilter<"Provider"> | string
    latitude?: DecimalNullableFilter<"Provider"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Provider"> | Decimal | DecimalJsLike | number | string | null
    slotDuration?: IntFilter<"Provider"> | number
    verifiedAt?: DateTimeNullableFilter<"Provider"> | Date | string | null
    createdAt?: DateTimeFilter<"Provider"> | Date | string
    updatedAt?: DateTimeFilter<"Provider"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    verifier?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    services?: ServiceListRelationFilter
    operatingHours?: OperatingHourListRelationFilter
    appointments?: AppointmentListRelationFilter
    documents?: DocumentListRelationFilter
    breakTimes?: BreakTimeListRelationFilter
    notifications?: NotificationListRelationFilter
    reviews?: ReviewListRelationFilter
    statusHistory?: ProviderStatusHistoryListRelationFilter
  }

  export type ProviderOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    healthcareName?: SortOrder
    description?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    coverPhoto?: SortOrderInput | SortOrder
    status?: SortOrder
    address?: SortOrder
    city?: SortOrder
    province?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    slotDuration?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
    verifier?: UserOrderByWithRelationInput
    services?: ServiceOrderByRelationAggregateInput
    operatingHours?: OperatingHourOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    breakTimes?: BreakTimeOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    statusHistory?: ProviderStatusHistoryOrderByRelationAggregateInput
  }

  export type ProviderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ProviderWhereInput | ProviderWhereInput[]
    OR?: ProviderWhereInput[]
    NOT?: ProviderWhereInput | ProviderWhereInput[]
    categoryId?: StringNullableFilter<"Provider"> | string | null
    verifiedBy?: StringNullableFilter<"Provider"> | string | null
    healthcareName?: StringFilter<"Provider"> | string
    description?: StringNullableFilter<"Provider"> | string | null
    phoneNumber?: StringNullableFilter<"Provider"> | string | null
    email?: StringNullableFilter<"Provider"> | string | null
    coverPhoto?: StringNullableFilter<"Provider"> | string | null
    status?: EnumProviderStatusFilter<"Provider"> | $Enums.ProviderStatus
    address?: StringFilter<"Provider"> | string
    city?: StringFilter<"Provider"> | string
    province?: StringFilter<"Provider"> | string
    latitude?: DecimalNullableFilter<"Provider"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Provider"> | Decimal | DecimalJsLike | number | string | null
    slotDuration?: IntFilter<"Provider"> | number
    verifiedAt?: DateTimeNullableFilter<"Provider"> | Date | string | null
    createdAt?: DateTimeFilter<"Provider"> | Date | string
    updatedAt?: DateTimeFilter<"Provider"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    verifier?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    services?: ServiceListRelationFilter
    operatingHours?: OperatingHourListRelationFilter
    appointments?: AppointmentListRelationFilter
    documents?: DocumentListRelationFilter
    breakTimes?: BreakTimeListRelationFilter
    notifications?: NotificationListRelationFilter
    reviews?: ReviewListRelationFilter
    statusHistory?: ProviderStatusHistoryListRelationFilter
  }, "id" | "userId">

  export type ProviderOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    healthcareName?: SortOrder
    description?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    coverPhoto?: SortOrderInput | SortOrder
    status?: SortOrder
    address?: SortOrder
    city?: SortOrder
    province?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    slotDuration?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProviderCountOrderByAggregateInput
    _avg?: ProviderAvgOrderByAggregateInput
    _max?: ProviderMaxOrderByAggregateInput
    _min?: ProviderMinOrderByAggregateInput
    _sum?: ProviderSumOrderByAggregateInput
  }

  export type ProviderScalarWhereWithAggregatesInput = {
    AND?: ProviderScalarWhereWithAggregatesInput | ProviderScalarWhereWithAggregatesInput[]
    OR?: ProviderScalarWhereWithAggregatesInput[]
    NOT?: ProviderScalarWhereWithAggregatesInput | ProviderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Provider"> | string
    userId?: StringWithAggregatesFilter<"Provider"> | string
    categoryId?: StringNullableWithAggregatesFilter<"Provider"> | string | null
    verifiedBy?: StringNullableWithAggregatesFilter<"Provider"> | string | null
    healthcareName?: StringWithAggregatesFilter<"Provider"> | string
    description?: StringNullableWithAggregatesFilter<"Provider"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"Provider"> | string | null
    email?: StringNullableWithAggregatesFilter<"Provider"> | string | null
    coverPhoto?: StringNullableWithAggregatesFilter<"Provider"> | string | null
    status?: EnumProviderStatusWithAggregatesFilter<"Provider"> | $Enums.ProviderStatus
    address?: StringWithAggregatesFilter<"Provider"> | string
    city?: StringWithAggregatesFilter<"Provider"> | string
    province?: StringWithAggregatesFilter<"Provider"> | string
    latitude?: DecimalNullableWithAggregatesFilter<"Provider"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableWithAggregatesFilter<"Provider"> | Decimal | DecimalJsLike | number | string | null
    slotDuration?: IntWithAggregatesFilter<"Provider"> | number
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"Provider"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Provider"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Provider"> | Date | string
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: StringFilter<"Service"> | string
    providerId?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    type?: EnumServiceTypeFilter<"Service"> | $Enums.ServiceType
    pricingModel?: EnumPricingModelFilter<"Service"> | $Enums.PricingModel
    fixedPrice?: IntFilter<"Service"> | number
    priceMin?: IntFilter<"Service"> | number
    priceMax?: IntFilter<"Service"> | number
    isActive?: BoolFilter<"Service"> | boolean
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
    appointments?: AppointmentServiceListRelationFilter
    includedServices?: ServicePackageListRelationFilter
    partOfPackages?: ServicePackageListRelationFilter
    acceptedInsurances?: ServiceInsuranceListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    pricingModel?: SortOrder
    fixedPrice?: SortOrder
    priceMin?: SortOrder
    priceMax?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    provider?: ProviderOrderByWithRelationInput
    appointments?: AppointmentServiceOrderByRelationAggregateInput
    includedServices?: ServicePackageOrderByRelationAggregateInput
    partOfPackages?: ServicePackageOrderByRelationAggregateInput
    acceptedInsurances?: ServiceInsuranceOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    providerId?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    type?: EnumServiceTypeFilter<"Service"> | $Enums.ServiceType
    pricingModel?: EnumPricingModelFilter<"Service"> | $Enums.PricingModel
    fixedPrice?: IntFilter<"Service"> | number
    priceMin?: IntFilter<"Service"> | number
    priceMax?: IntFilter<"Service"> | number
    isActive?: BoolFilter<"Service"> | boolean
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
    appointments?: AppointmentServiceListRelationFilter
    includedServices?: ServicePackageListRelationFilter
    partOfPackages?: ServicePackageListRelationFilter
    acceptedInsurances?: ServiceInsuranceListRelationFilter
  }, "id">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    pricingModel?: SortOrder
    fixedPrice?: SortOrder
    priceMin?: SortOrder
    priceMax?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Service"> | string
    providerId?: StringWithAggregatesFilter<"Service"> | string
    name?: StringWithAggregatesFilter<"Service"> | string
    description?: StringNullableWithAggregatesFilter<"Service"> | string | null
    type?: EnumServiceTypeWithAggregatesFilter<"Service"> | $Enums.ServiceType
    pricingModel?: EnumPricingModelWithAggregatesFilter<"Service"> | $Enums.PricingModel
    fixedPrice?: IntWithAggregatesFilter<"Service"> | number
    priceMin?: IntWithAggregatesFilter<"Service"> | number
    priceMax?: IntWithAggregatesFilter<"Service"> | number
    isActive?: BoolWithAggregatesFilter<"Service"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
  }

  export type ServicePackageWhereInput = {
    AND?: ServicePackageWhereInput | ServicePackageWhereInput[]
    OR?: ServicePackageWhereInput[]
    NOT?: ServicePackageWhereInput | ServicePackageWhereInput[]
    parentPackageId?: StringFilter<"ServicePackage"> | string
    childServiceId?: StringFilter<"ServicePackage"> | string
    createdAt?: DateTimeFilter<"ServicePackage"> | Date | string
    parentPackage?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    childService?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }

  export type ServicePackageOrderByWithRelationInput = {
    parentPackageId?: SortOrder
    childServiceId?: SortOrder
    createdAt?: SortOrder
    parentPackage?: ServiceOrderByWithRelationInput
    childService?: ServiceOrderByWithRelationInput
  }

  export type ServicePackageWhereUniqueInput = Prisma.AtLeast<{
    parentPackageId_childServiceId?: ServicePackageParentPackageIdChildServiceIdCompoundUniqueInput
    AND?: ServicePackageWhereInput | ServicePackageWhereInput[]
    OR?: ServicePackageWhereInput[]
    NOT?: ServicePackageWhereInput | ServicePackageWhereInput[]
    parentPackageId?: StringFilter<"ServicePackage"> | string
    childServiceId?: StringFilter<"ServicePackage"> | string
    createdAt?: DateTimeFilter<"ServicePackage"> | Date | string
    parentPackage?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    childService?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }, "parentPackageId_childServiceId">

  export type ServicePackageOrderByWithAggregationInput = {
    parentPackageId?: SortOrder
    childServiceId?: SortOrder
    createdAt?: SortOrder
    _count?: ServicePackageCountOrderByAggregateInput
    _max?: ServicePackageMaxOrderByAggregateInput
    _min?: ServicePackageMinOrderByAggregateInput
  }

  export type ServicePackageScalarWhereWithAggregatesInput = {
    AND?: ServicePackageScalarWhereWithAggregatesInput | ServicePackageScalarWhereWithAggregatesInput[]
    OR?: ServicePackageScalarWhereWithAggregatesInput[]
    NOT?: ServicePackageScalarWhereWithAggregatesInput | ServicePackageScalarWhereWithAggregatesInput[]
    parentPackageId?: StringWithAggregatesFilter<"ServicePackage"> | string
    childServiceId?: StringWithAggregatesFilter<"ServicePackage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ServicePackage"> | Date | string
  }

  export type InsuranceProviderWhereInput = {
    AND?: InsuranceProviderWhereInput | InsuranceProviderWhereInput[]
    OR?: InsuranceProviderWhereInput[]
    NOT?: InsuranceProviderWhereInput | InsuranceProviderWhereInput[]
    id?: StringFilter<"InsuranceProvider"> | string
    name?: StringFilter<"InsuranceProvider"> | string
    isActive?: BoolFilter<"InsuranceProvider"> | boolean
    services?: ServiceInsuranceListRelationFilter
  }

  export type InsuranceProviderOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    services?: ServiceInsuranceOrderByRelationAggregateInput
  }

  export type InsuranceProviderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: InsuranceProviderWhereInput | InsuranceProviderWhereInput[]
    OR?: InsuranceProviderWhereInput[]
    NOT?: InsuranceProviderWhereInput | InsuranceProviderWhereInput[]
    isActive?: BoolFilter<"InsuranceProvider"> | boolean
    services?: ServiceInsuranceListRelationFilter
  }, "id" | "name">

  export type InsuranceProviderOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    _count?: InsuranceProviderCountOrderByAggregateInput
    _max?: InsuranceProviderMaxOrderByAggregateInput
    _min?: InsuranceProviderMinOrderByAggregateInput
  }

  export type InsuranceProviderScalarWhereWithAggregatesInput = {
    AND?: InsuranceProviderScalarWhereWithAggregatesInput | InsuranceProviderScalarWhereWithAggregatesInput[]
    OR?: InsuranceProviderScalarWhereWithAggregatesInput[]
    NOT?: InsuranceProviderScalarWhereWithAggregatesInput | InsuranceProviderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InsuranceProvider"> | string
    name?: StringWithAggregatesFilter<"InsuranceProvider"> | string
    isActive?: BoolWithAggregatesFilter<"InsuranceProvider"> | boolean
  }

  export type ServiceInsuranceWhereInput = {
    AND?: ServiceInsuranceWhereInput | ServiceInsuranceWhereInput[]
    OR?: ServiceInsuranceWhereInput[]
    NOT?: ServiceInsuranceWhereInput | ServiceInsuranceWhereInput[]
    serviceId?: StringFilter<"ServiceInsurance"> | string
    insuranceProviderId?: StringFilter<"ServiceInsurance"> | string
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    insuranceProvider?: XOR<InsuranceProviderScalarRelationFilter, InsuranceProviderWhereInput>
  }

  export type ServiceInsuranceOrderByWithRelationInput = {
    serviceId?: SortOrder
    insuranceProviderId?: SortOrder
    service?: ServiceOrderByWithRelationInput
    insuranceProvider?: InsuranceProviderOrderByWithRelationInput
  }

  export type ServiceInsuranceWhereUniqueInput = Prisma.AtLeast<{
    serviceId_insuranceProviderId?: ServiceInsuranceServiceIdInsuranceProviderIdCompoundUniqueInput
    AND?: ServiceInsuranceWhereInput | ServiceInsuranceWhereInput[]
    OR?: ServiceInsuranceWhereInput[]
    NOT?: ServiceInsuranceWhereInput | ServiceInsuranceWhereInput[]
    serviceId?: StringFilter<"ServiceInsurance"> | string
    insuranceProviderId?: StringFilter<"ServiceInsurance"> | string
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    insuranceProvider?: XOR<InsuranceProviderScalarRelationFilter, InsuranceProviderWhereInput>
  }, "serviceId_insuranceProviderId">

  export type ServiceInsuranceOrderByWithAggregationInput = {
    serviceId?: SortOrder
    insuranceProviderId?: SortOrder
    _count?: ServiceInsuranceCountOrderByAggregateInput
    _max?: ServiceInsuranceMaxOrderByAggregateInput
    _min?: ServiceInsuranceMinOrderByAggregateInput
  }

  export type ServiceInsuranceScalarWhereWithAggregatesInput = {
    AND?: ServiceInsuranceScalarWhereWithAggregatesInput | ServiceInsuranceScalarWhereWithAggregatesInput[]
    OR?: ServiceInsuranceScalarWhereWithAggregatesInput[]
    NOT?: ServiceInsuranceScalarWhereWithAggregatesInput | ServiceInsuranceScalarWhereWithAggregatesInput[]
    serviceId?: StringWithAggregatesFilter<"ServiceInsurance"> | string
    insuranceProviderId?: StringWithAggregatesFilter<"ServiceInsurance"> | string
  }

  export type OperatingHourWhereInput = {
    AND?: OperatingHourWhereInput | OperatingHourWhereInput[]
    OR?: OperatingHourWhereInput[]
    NOT?: OperatingHourWhereInput | OperatingHourWhereInput[]
    id?: StringFilter<"OperatingHour"> | string
    providerId?: StringFilter<"OperatingHour"> | string
    dayOfWeek?: IntFilter<"OperatingHour"> | number
    startTime?: StringNullableFilter<"OperatingHour"> | string | null
    endTime?: StringNullableFilter<"OperatingHour"> | string | null
    isClosed?: BoolFilter<"OperatingHour"> | boolean
    createdAt?: DateTimeFilter<"OperatingHour"> | Date | string
    updatedAt?: DateTimeFilter<"OperatingHour"> | Date | string
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
  }

  export type OperatingHourOrderByWithRelationInput = {
    id?: SortOrder
    providerId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    isClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    provider?: ProviderOrderByWithRelationInput
  }

  export type OperatingHourWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OperatingHourWhereInput | OperatingHourWhereInput[]
    OR?: OperatingHourWhereInput[]
    NOT?: OperatingHourWhereInput | OperatingHourWhereInput[]
    providerId?: StringFilter<"OperatingHour"> | string
    dayOfWeek?: IntFilter<"OperatingHour"> | number
    startTime?: StringNullableFilter<"OperatingHour"> | string | null
    endTime?: StringNullableFilter<"OperatingHour"> | string | null
    isClosed?: BoolFilter<"OperatingHour"> | boolean
    createdAt?: DateTimeFilter<"OperatingHour"> | Date | string
    updatedAt?: DateTimeFilter<"OperatingHour"> | Date | string
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
  }, "id">

  export type OperatingHourOrderByWithAggregationInput = {
    id?: SortOrder
    providerId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    isClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OperatingHourCountOrderByAggregateInput
    _avg?: OperatingHourAvgOrderByAggregateInput
    _max?: OperatingHourMaxOrderByAggregateInput
    _min?: OperatingHourMinOrderByAggregateInput
    _sum?: OperatingHourSumOrderByAggregateInput
  }

  export type OperatingHourScalarWhereWithAggregatesInput = {
    AND?: OperatingHourScalarWhereWithAggregatesInput | OperatingHourScalarWhereWithAggregatesInput[]
    OR?: OperatingHourScalarWhereWithAggregatesInput[]
    NOT?: OperatingHourScalarWhereWithAggregatesInput | OperatingHourScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OperatingHour"> | string
    providerId?: StringWithAggregatesFilter<"OperatingHour"> | string
    dayOfWeek?: IntWithAggregatesFilter<"OperatingHour"> | number
    startTime?: StringNullableWithAggregatesFilter<"OperatingHour"> | string | null
    endTime?: StringNullableWithAggregatesFilter<"OperatingHour"> | string | null
    isClosed?: BoolWithAggregatesFilter<"OperatingHour"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"OperatingHour"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OperatingHour"> | Date | string
  }

  export type BreakTimeWhereInput = {
    AND?: BreakTimeWhereInput | BreakTimeWhereInput[]
    OR?: BreakTimeWhereInput[]
    NOT?: BreakTimeWhereInput | BreakTimeWhereInput[]
    id?: StringFilter<"BreakTime"> | string
    providerId?: StringFilter<"BreakTime"> | string
    name?: StringFilter<"BreakTime"> | string
    dayOfWeek?: IntFilter<"BreakTime"> | number
    startTime?: StringFilter<"BreakTime"> | string
    endTime?: StringFilter<"BreakTime"> | string
    createdAt?: DateTimeFilter<"BreakTime"> | Date | string
    updatedAt?: DateTimeFilter<"BreakTime"> | Date | string
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
  }

  export type BreakTimeOrderByWithRelationInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    provider?: ProviderOrderByWithRelationInput
  }

  export type BreakTimeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BreakTimeWhereInput | BreakTimeWhereInput[]
    OR?: BreakTimeWhereInput[]
    NOT?: BreakTimeWhereInput | BreakTimeWhereInput[]
    providerId?: StringFilter<"BreakTime"> | string
    name?: StringFilter<"BreakTime"> | string
    dayOfWeek?: IntFilter<"BreakTime"> | number
    startTime?: StringFilter<"BreakTime"> | string
    endTime?: StringFilter<"BreakTime"> | string
    createdAt?: DateTimeFilter<"BreakTime"> | Date | string
    updatedAt?: DateTimeFilter<"BreakTime"> | Date | string
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
  }, "id">

  export type BreakTimeOrderByWithAggregationInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BreakTimeCountOrderByAggregateInput
    _avg?: BreakTimeAvgOrderByAggregateInput
    _max?: BreakTimeMaxOrderByAggregateInput
    _min?: BreakTimeMinOrderByAggregateInput
    _sum?: BreakTimeSumOrderByAggregateInput
  }

  export type BreakTimeScalarWhereWithAggregatesInput = {
    AND?: BreakTimeScalarWhereWithAggregatesInput | BreakTimeScalarWhereWithAggregatesInput[]
    OR?: BreakTimeScalarWhereWithAggregatesInput[]
    NOT?: BreakTimeScalarWhereWithAggregatesInput | BreakTimeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BreakTime"> | string
    providerId?: StringWithAggregatesFilter<"BreakTime"> | string
    name?: StringWithAggregatesFilter<"BreakTime"> | string
    dayOfWeek?: IntWithAggregatesFilter<"BreakTime"> | number
    startTime?: StringWithAggregatesFilter<"BreakTime"> | string
    endTime?: StringWithAggregatesFilter<"BreakTime"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BreakTime"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BreakTime"> | Date | string
  }

  export type AppointmentWhereInput = {
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    id?: StringFilter<"Appointment"> | string
    appointmentNumber?: StringFilter<"Appointment"> | string
    userId?: StringFilter<"Appointment"> | string
    providerId?: StringFilter<"Appointment"> | string
    startTime?: DateTimeFilter<"Appointment"> | Date | string
    endTime?: DateTimeFilter<"Appointment"> | Date | string
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    notes?: StringNullableFilter<"Appointment"> | string | null
    totalPrice?: DecimalFilter<"Appointment"> | Decimal | DecimalJsLike | number | string
    patientName?: StringFilter<"Appointment"> | string
    patientEmail?: StringFilter<"Appointment"> | string
    patientPhone?: StringNullableFilter<"Appointment"> | string | null
    activityNotes?: StringNullableFilter<"Appointment"> | string | null
    cancelledAt?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    cancellationReason?: StringNullableFilter<"Appointment"> | string | null
    cancelledBy?: StringNullableFilter<"Appointment"> | string | null
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
    canceller?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    services?: AppointmentServiceListRelationFilter
    notifications?: NotificationListRelationFilter
    review?: XOR<ReviewNullableScalarRelationFilter, ReviewWhereInput> | null
  }

  export type AppointmentOrderByWithRelationInput = {
    id?: SortOrder
    appointmentNumber?: SortOrder
    userId?: SortOrder
    providerId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    totalPrice?: SortOrder
    patientName?: SortOrder
    patientEmail?: SortOrder
    patientPhone?: SortOrderInput | SortOrder
    activityNotes?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    cancellationReason?: SortOrderInput | SortOrder
    cancelledBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    provider?: ProviderOrderByWithRelationInput
    canceller?: UserOrderByWithRelationInput
    services?: AppointmentServiceOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    review?: ReviewOrderByWithRelationInput
  }

  export type AppointmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    appointmentNumber?: string
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    userId?: StringFilter<"Appointment"> | string
    providerId?: StringFilter<"Appointment"> | string
    startTime?: DateTimeFilter<"Appointment"> | Date | string
    endTime?: DateTimeFilter<"Appointment"> | Date | string
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    notes?: StringNullableFilter<"Appointment"> | string | null
    totalPrice?: DecimalFilter<"Appointment"> | Decimal | DecimalJsLike | number | string
    patientName?: StringFilter<"Appointment"> | string
    patientEmail?: StringFilter<"Appointment"> | string
    patientPhone?: StringNullableFilter<"Appointment"> | string | null
    activityNotes?: StringNullableFilter<"Appointment"> | string | null
    cancelledAt?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    cancellationReason?: StringNullableFilter<"Appointment"> | string | null
    cancelledBy?: StringNullableFilter<"Appointment"> | string | null
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
    canceller?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    services?: AppointmentServiceListRelationFilter
    notifications?: NotificationListRelationFilter
    review?: XOR<ReviewNullableScalarRelationFilter, ReviewWhereInput> | null
  }, "id" | "appointmentNumber">

  export type AppointmentOrderByWithAggregationInput = {
    id?: SortOrder
    appointmentNumber?: SortOrder
    userId?: SortOrder
    providerId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    totalPrice?: SortOrder
    patientName?: SortOrder
    patientEmail?: SortOrder
    patientPhone?: SortOrderInput | SortOrder
    activityNotes?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    cancellationReason?: SortOrderInput | SortOrder
    cancelledBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AppointmentCountOrderByAggregateInput
    _avg?: AppointmentAvgOrderByAggregateInput
    _max?: AppointmentMaxOrderByAggregateInput
    _min?: AppointmentMinOrderByAggregateInput
    _sum?: AppointmentSumOrderByAggregateInput
  }

  export type AppointmentScalarWhereWithAggregatesInput = {
    AND?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    OR?: AppointmentScalarWhereWithAggregatesInput[]
    NOT?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Appointment"> | string
    appointmentNumber?: StringWithAggregatesFilter<"Appointment"> | string
    userId?: StringWithAggregatesFilter<"Appointment"> | string
    providerId?: StringWithAggregatesFilter<"Appointment"> | string
    startTime?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    status?: EnumAppointmentStatusWithAggregatesFilter<"Appointment"> | $Enums.AppointmentStatus
    notes?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    totalPrice?: DecimalWithAggregatesFilter<"Appointment"> | Decimal | DecimalJsLike | number | string
    patientName?: StringWithAggregatesFilter<"Appointment"> | string
    patientEmail?: StringWithAggregatesFilter<"Appointment"> | string
    patientPhone?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    activityNotes?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"Appointment"> | Date | string | null
    cancellationReason?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    cancelledBy?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
  }

  export type AppointmentServiceWhereInput = {
    AND?: AppointmentServiceWhereInput | AppointmentServiceWhereInput[]
    OR?: AppointmentServiceWhereInput[]
    NOT?: AppointmentServiceWhereInput | AppointmentServiceWhereInput[]
    appointmentId?: StringFilter<"AppointmentService"> | string
    serviceId?: StringFilter<"AppointmentService"> | string
    priceAtBooking?: DecimalFilter<"AppointmentService"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"AppointmentService"> | Date | string
    updatedAt?: DateTimeFilter<"AppointmentService"> | Date | string
    appointment?: XOR<AppointmentScalarRelationFilter, AppointmentWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }

  export type AppointmentServiceOrderByWithRelationInput = {
    appointmentId?: SortOrder
    serviceId?: SortOrder
    priceAtBooking?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    appointment?: AppointmentOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type AppointmentServiceWhereUniqueInput = Prisma.AtLeast<{
    appointmentId_serviceId?: AppointmentServiceAppointmentIdServiceIdCompoundUniqueInput
    AND?: AppointmentServiceWhereInput | AppointmentServiceWhereInput[]
    OR?: AppointmentServiceWhereInput[]
    NOT?: AppointmentServiceWhereInput | AppointmentServiceWhereInput[]
    appointmentId?: StringFilter<"AppointmentService"> | string
    serviceId?: StringFilter<"AppointmentService"> | string
    priceAtBooking?: DecimalFilter<"AppointmentService"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"AppointmentService"> | Date | string
    updatedAt?: DateTimeFilter<"AppointmentService"> | Date | string
    appointment?: XOR<AppointmentScalarRelationFilter, AppointmentWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }, "appointmentId_serviceId">

  export type AppointmentServiceOrderByWithAggregationInput = {
    appointmentId?: SortOrder
    serviceId?: SortOrder
    priceAtBooking?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AppointmentServiceCountOrderByAggregateInput
    _avg?: AppointmentServiceAvgOrderByAggregateInput
    _max?: AppointmentServiceMaxOrderByAggregateInput
    _min?: AppointmentServiceMinOrderByAggregateInput
    _sum?: AppointmentServiceSumOrderByAggregateInput
  }

  export type AppointmentServiceScalarWhereWithAggregatesInput = {
    AND?: AppointmentServiceScalarWhereWithAggregatesInput | AppointmentServiceScalarWhereWithAggregatesInput[]
    OR?: AppointmentServiceScalarWhereWithAggregatesInput[]
    NOT?: AppointmentServiceScalarWhereWithAggregatesInput | AppointmentServiceScalarWhereWithAggregatesInput[]
    appointmentId?: StringWithAggregatesFilter<"AppointmentService"> | string
    serviceId?: StringWithAggregatesFilter<"AppointmentService"> | string
    priceAtBooking?: DecimalWithAggregatesFilter<"AppointmentService"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"AppointmentService"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AppointmentService"> | Date | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    providerId?: StringFilter<"Document"> | string
    documentType?: StringFilter<"Document"> | string
    filePath?: StringFilter<"Document"> | string
    verifiedAt?: DateTimeNullableFilter<"Document"> | Date | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    verificationStatus?: EnumDocumentVerificationStatusFilter<"Document"> | $Enums.DocumentVerificationStatus
    verifiedById?: StringNullableFilter<"Document"> | string | null
    rejectionReason?: StringNullableFilter<"Document"> | string | null
    verifiedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    providerId?: SortOrder
    documentType?: SortOrder
    filePath?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    verificationStatus?: SortOrder
    verifiedById?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    verifiedBy?: UserOrderByWithRelationInput
    provider?: ProviderOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    providerId?: StringFilter<"Document"> | string
    documentType?: StringFilter<"Document"> | string
    filePath?: StringFilter<"Document"> | string
    verifiedAt?: DateTimeNullableFilter<"Document"> | Date | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    verificationStatus?: EnumDocumentVerificationStatusFilter<"Document"> | $Enums.DocumentVerificationStatus
    verifiedById?: StringNullableFilter<"Document"> | string | null
    rejectionReason?: StringNullableFilter<"Document"> | string | null
    verifiedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    providerId?: SortOrder
    documentType?: SortOrder
    filePath?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    verificationStatus?: SortOrder
    verifiedById?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    providerId?: StringWithAggregatesFilter<"Document"> | string
    documentType?: StringWithAggregatesFilter<"Document"> | string
    filePath?: StringWithAggregatesFilter<"Document"> | string
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"Document"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    verificationStatus?: EnumDocumentVerificationStatusWithAggregatesFilter<"Document"> | $Enums.DocumentVerificationStatus
    verifiedById?: StringNullableWithAggregatesFilter<"Document"> | string | null
    rejectionReason?: StringNullableWithAggregatesFilter<"Document"> | string | null
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    appointmentId?: StringNullableFilter<"Notification"> | string | null
    providerId?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    appointment?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null
    provider?: XOR<ProviderNullableScalarRelationFilter, ProviderWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    appointmentId?: SortOrderInput | SortOrder
    providerId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    appointment?: AppointmentOrderByWithRelationInput
    provider?: ProviderOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    appointmentId?: StringNullableFilter<"Notification"> | string | null
    providerId?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    appointment?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null
    provider?: XOR<ProviderNullableScalarRelationFilter, ProviderWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    appointmentId?: SortOrderInput | SortOrder
    providerId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    appointmentId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    providerId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Notification">
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type ConversationWhereInput = {
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    id?: StringFilter<"Conversation"> | string
    user1Id?: StringFilter<"Conversation"> | string
    user2Id?: StringFilter<"Conversation"> | string
    lastMessageAt?: DateTimeNullableFilter<"Conversation"> | Date | string | null
    lastMessageContent?: StringNullableFilter<"Conversation"> | string | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    user1?: XOR<UserScalarRelationFilter, UserWhereInput>
    user2?: XOR<UserScalarRelationFilter, UserWhereInput>
    messages?: MessageListRelationFilter
  }

  export type ConversationOrderByWithRelationInput = {
    id?: SortOrder
    user1Id?: SortOrder
    user2Id?: SortOrder
    lastMessageAt?: SortOrderInput | SortOrder
    lastMessageContent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user1?: UserOrderByWithRelationInput
    user2?: UserOrderByWithRelationInput
    messages?: MessageOrderByRelationAggregateInput
  }

  export type ConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user1Id_user2Id?: ConversationUser1IdUser2IdCompoundUniqueInput
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    user1Id?: StringFilter<"Conversation"> | string
    user2Id?: StringFilter<"Conversation"> | string
    lastMessageAt?: DateTimeNullableFilter<"Conversation"> | Date | string | null
    lastMessageContent?: StringNullableFilter<"Conversation"> | string | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    user1?: XOR<UserScalarRelationFilter, UserWhereInput>
    user2?: XOR<UserScalarRelationFilter, UserWhereInput>
    messages?: MessageListRelationFilter
  }, "id" | "user1Id_user2Id">

  export type ConversationOrderByWithAggregationInput = {
    id?: SortOrder
    user1Id?: SortOrder
    user2Id?: SortOrder
    lastMessageAt?: SortOrderInput | SortOrder
    lastMessageContent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConversationCountOrderByAggregateInput
    _max?: ConversationMaxOrderByAggregateInput
    _min?: ConversationMinOrderByAggregateInput
  }

  export type ConversationScalarWhereWithAggregatesInput = {
    AND?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    OR?: ConversationScalarWhereWithAggregatesInput[]
    NOT?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Conversation"> | string
    user1Id?: StringWithAggregatesFilter<"Conversation"> | string
    user2Id?: StringWithAggregatesFilter<"Conversation"> | string
    lastMessageAt?: DateTimeNullableWithAggregatesFilter<"Conversation"> | Date | string | null
    lastMessageContent?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    status?: EnumMessageStatusFilter<"Message"> | $Enums.MessageStatus
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    status?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    conversationId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    status?: EnumMessageStatusFilter<"Message"> | $Enums.MessageStatus
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    status?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    conversationId?: StringWithAggregatesFilter<"Message"> | string
    senderId?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    status?: EnumMessageStatusWithAggregatesFilter<"Message"> | $Enums.MessageStatus
    readAt?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: StringFilter<"Review"> | string
    appointmentId?: StringFilter<"Review"> | string
    userId?: StringFilter<"Review"> | string
    providerId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    isAnonymous?: BoolFilter<"Review"> | boolean
    professionalismRating?: IntNullableFilter<"Review"> | number | null
    cleanlinessRating?: IntNullableFilter<"Review"> | number | null
    waitTimeRating?: IntNullableFilter<"Review"> | number | null
    valueRating?: IntNullableFilter<"Review"> | number | null
    providerResponse?: StringNullableFilter<"Review"> | string | null
    respondedAt?: DateTimeNullableFilter<"Review"> | Date | string | null
    isEdited?: BoolFilter<"Review"> | boolean
    editedAt?: DateTimeNullableFilter<"Review"> | Date | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    appointment?: XOR<AppointmentScalarRelationFilter, AppointmentWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
    likes?: ReviewLikeListRelationFilter
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    appointmentId?: SortOrder
    userId?: SortOrder
    providerId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    isAnonymous?: SortOrder
    professionalismRating?: SortOrderInput | SortOrder
    cleanlinessRating?: SortOrderInput | SortOrder
    waitTimeRating?: SortOrderInput | SortOrder
    valueRating?: SortOrderInput | SortOrder
    providerResponse?: SortOrderInput | SortOrder
    respondedAt?: SortOrderInput | SortOrder
    isEdited?: SortOrder
    editedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    appointment?: AppointmentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    provider?: ProviderOrderByWithRelationInput
    likes?: ReviewLikeOrderByRelationAggregateInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    appointmentId?: string
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    userId?: StringFilter<"Review"> | string
    providerId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    isAnonymous?: BoolFilter<"Review"> | boolean
    professionalismRating?: IntNullableFilter<"Review"> | number | null
    cleanlinessRating?: IntNullableFilter<"Review"> | number | null
    waitTimeRating?: IntNullableFilter<"Review"> | number | null
    valueRating?: IntNullableFilter<"Review"> | number | null
    providerResponse?: StringNullableFilter<"Review"> | string | null
    respondedAt?: DateTimeNullableFilter<"Review"> | Date | string | null
    isEdited?: BoolFilter<"Review"> | boolean
    editedAt?: DateTimeNullableFilter<"Review"> | Date | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    appointment?: XOR<AppointmentScalarRelationFilter, AppointmentWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
    likes?: ReviewLikeListRelationFilter
  }, "id" | "appointmentId">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    appointmentId?: SortOrder
    userId?: SortOrder
    providerId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    isAnonymous?: SortOrder
    professionalismRating?: SortOrderInput | SortOrder
    cleanlinessRating?: SortOrderInput | SortOrder
    waitTimeRating?: SortOrderInput | SortOrder
    valueRating?: SortOrderInput | SortOrder
    providerResponse?: SortOrderInput | SortOrder
    respondedAt?: SortOrderInput | SortOrder
    isEdited?: SortOrder
    editedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Review"> | string
    appointmentId?: StringWithAggregatesFilter<"Review"> | string
    userId?: StringWithAggregatesFilter<"Review"> | string
    providerId?: StringWithAggregatesFilter<"Review"> | string
    rating?: IntWithAggregatesFilter<"Review"> | number
    comment?: StringNullableWithAggregatesFilter<"Review"> | string | null
    isAnonymous?: BoolWithAggregatesFilter<"Review"> | boolean
    professionalismRating?: IntNullableWithAggregatesFilter<"Review"> | number | null
    cleanlinessRating?: IntNullableWithAggregatesFilter<"Review"> | number | null
    waitTimeRating?: IntNullableWithAggregatesFilter<"Review"> | number | null
    valueRating?: IntNullableWithAggregatesFilter<"Review"> | number | null
    providerResponse?: StringNullableWithAggregatesFilter<"Review"> | string | null
    respondedAt?: DateTimeNullableWithAggregatesFilter<"Review"> | Date | string | null
    isEdited?: BoolWithAggregatesFilter<"Review"> | boolean
    editedAt?: DateTimeNullableWithAggregatesFilter<"Review"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
  }

  export type ReviewLikeWhereInput = {
    AND?: ReviewLikeWhereInput | ReviewLikeWhereInput[]
    OR?: ReviewLikeWhereInput[]
    NOT?: ReviewLikeWhereInput | ReviewLikeWhereInput[]
    id?: StringFilter<"ReviewLike"> | string
    reviewId?: StringFilter<"ReviewLike"> | string
    userId?: StringFilter<"ReviewLike"> | string
    createdAt?: DateTimeFilter<"ReviewLike"> | Date | string
    review?: XOR<ReviewScalarRelationFilter, ReviewWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReviewLikeOrderByWithRelationInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    review?: ReviewOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ReviewLikeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    reviewId_userId?: ReviewLikeReviewIdUserIdCompoundUniqueInput
    AND?: ReviewLikeWhereInput | ReviewLikeWhereInput[]
    OR?: ReviewLikeWhereInput[]
    NOT?: ReviewLikeWhereInput | ReviewLikeWhereInput[]
    reviewId?: StringFilter<"ReviewLike"> | string
    userId?: StringFilter<"ReviewLike"> | string
    createdAt?: DateTimeFilter<"ReviewLike"> | Date | string
    review?: XOR<ReviewScalarRelationFilter, ReviewWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "reviewId_userId">

  export type ReviewLikeOrderByWithAggregationInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: ReviewLikeCountOrderByAggregateInput
    _max?: ReviewLikeMaxOrderByAggregateInput
    _min?: ReviewLikeMinOrderByAggregateInput
  }

  export type ReviewLikeScalarWhereWithAggregatesInput = {
    AND?: ReviewLikeScalarWhereWithAggregatesInput | ReviewLikeScalarWhereWithAggregatesInput[]
    OR?: ReviewLikeScalarWhereWithAggregatesInput[]
    NOT?: ReviewLikeScalarWhereWithAggregatesInput | ReviewLikeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReviewLike"> | string
    reviewId?: StringWithAggregatesFilter<"ReviewLike"> | string
    userId?: StringWithAggregatesFilter<"ReviewLike"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ReviewLike"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    adminId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    targetType?: StringFilter<"AuditLog"> | string
    targetId?: StringFilter<"AuditLog"> | string
    oldValue?: JsonNullableFilter<"AuditLog">
    newValue?: JsonNullableFilter<"AuditLog">
    metadata?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    admin?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    admin?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    adminId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    targetType?: StringFilter<"AuditLog"> | string
    targetId?: StringFilter<"AuditLog"> | string
    oldValue?: JsonNullableFilter<"AuditLog">
    newValue?: JsonNullableFilter<"AuditLog">
    metadata?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    admin?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    adminId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    targetType?: StringWithAggregatesFilter<"AuditLog"> | string
    targetId?: StringWithAggregatesFilter<"AuditLog"> | string
    oldValue?: JsonNullableWithAggregatesFilter<"AuditLog">
    newValue?: JsonNullableWithAggregatesFilter<"AuditLog">
    metadata?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type ProviderStatusHistoryWhereInput = {
    AND?: ProviderStatusHistoryWhereInput | ProviderStatusHistoryWhereInput[]
    OR?: ProviderStatusHistoryWhereInput[]
    NOT?: ProviderStatusHistoryWhereInput | ProviderStatusHistoryWhereInput[]
    id?: StringFilter<"ProviderStatusHistory"> | string
    providerId?: StringFilter<"ProviderStatusHistory"> | string
    fromStatus?: EnumProviderStatusFilter<"ProviderStatusHistory"> | $Enums.ProviderStatus
    toStatus?: EnumProviderStatusFilter<"ProviderStatusHistory"> | $Enums.ProviderStatus
    reason?: StringNullableFilter<"ProviderStatusHistory"> | string | null
    changedById?: StringFilter<"ProviderStatusHistory"> | string
    createdAt?: DateTimeFilter<"ProviderStatusHistory"> | Date | string
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
    changedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ProviderStatusHistoryOrderByWithRelationInput = {
    id?: SortOrder
    providerId?: SortOrder
    fromStatus?: SortOrder
    toStatus?: SortOrder
    reason?: SortOrderInput | SortOrder
    changedById?: SortOrder
    createdAt?: SortOrder
    provider?: ProviderOrderByWithRelationInput
    changedBy?: UserOrderByWithRelationInput
  }

  export type ProviderStatusHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProviderStatusHistoryWhereInput | ProviderStatusHistoryWhereInput[]
    OR?: ProviderStatusHistoryWhereInput[]
    NOT?: ProviderStatusHistoryWhereInput | ProviderStatusHistoryWhereInput[]
    providerId?: StringFilter<"ProviderStatusHistory"> | string
    fromStatus?: EnumProviderStatusFilter<"ProviderStatusHistory"> | $Enums.ProviderStatus
    toStatus?: EnumProviderStatusFilter<"ProviderStatusHistory"> | $Enums.ProviderStatus
    reason?: StringNullableFilter<"ProviderStatusHistory"> | string | null
    changedById?: StringFilter<"ProviderStatusHistory"> | string
    createdAt?: DateTimeFilter<"ProviderStatusHistory"> | Date | string
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
    changedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ProviderStatusHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    providerId?: SortOrder
    fromStatus?: SortOrder
    toStatus?: SortOrder
    reason?: SortOrderInput | SortOrder
    changedById?: SortOrder
    createdAt?: SortOrder
    _count?: ProviderStatusHistoryCountOrderByAggregateInput
    _max?: ProviderStatusHistoryMaxOrderByAggregateInput
    _min?: ProviderStatusHistoryMinOrderByAggregateInput
  }

  export type ProviderStatusHistoryScalarWhereWithAggregatesInput = {
    AND?: ProviderStatusHistoryScalarWhereWithAggregatesInput | ProviderStatusHistoryScalarWhereWithAggregatesInput[]
    OR?: ProviderStatusHistoryScalarWhereWithAggregatesInput[]
    NOT?: ProviderStatusHistoryScalarWhereWithAggregatesInput | ProviderStatusHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProviderStatusHistory"> | string
    providerId?: StringWithAggregatesFilter<"ProviderStatusHistory"> | string
    fromStatus?: EnumProviderStatusWithAggregatesFilter<"ProviderStatusHistory"> | $Enums.ProviderStatus
    toStatus?: EnumProviderStatusWithAggregatesFilter<"ProviderStatusHistory"> | $Enums.ProviderStatus
    reason?: StringNullableWithAggregatesFilter<"ProviderStatusHistory"> | string | null
    changedById?: StringWithAggregatesFilter<"ProviderStatusHistory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProviderStatusHistory"> | Date | string
  }

  export type SystemFeedbackWhereInput = {
    AND?: SystemFeedbackWhereInput | SystemFeedbackWhereInput[]
    OR?: SystemFeedbackWhereInput[]
    NOT?: SystemFeedbackWhereInput | SystemFeedbackWhereInput[]
    id?: StringFilter<"SystemFeedback"> | string
    userId?: StringFilter<"SystemFeedback"> | string
    category?: EnumFeedbackCategoryFilter<"SystemFeedback"> | $Enums.FeedbackCategory
    priority?: EnumFeedbackPriorityNullableFilter<"SystemFeedback"> | $Enums.FeedbackPriority | null
    title?: StringFilter<"SystemFeedback"> | string
    message?: StringFilter<"SystemFeedback"> | string
    satisfactionRating?: IntNullableFilter<"SystemFeedback"> | number | null
    adminResponse?: StringNullableFilter<"SystemFeedback"> | string | null
    respondedAt?: DateTimeNullableFilter<"SystemFeedback"> | Date | string | null
    respondedById?: StringNullableFilter<"SystemFeedback"> | string | null
    isRead?: BoolFilter<"SystemFeedback"> | boolean
    isResolved?: BoolFilter<"SystemFeedback"> | boolean
    resolvedAt?: DateTimeNullableFilter<"SystemFeedback"> | Date | string | null
    createdAt?: DateTimeFilter<"SystemFeedback"> | Date | string
    updatedAt?: DateTimeFilter<"SystemFeedback"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    respondedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type SystemFeedbackOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    category?: SortOrder
    priority?: SortOrderInput | SortOrder
    title?: SortOrder
    message?: SortOrder
    satisfactionRating?: SortOrderInput | SortOrder
    adminResponse?: SortOrderInput | SortOrder
    respondedAt?: SortOrderInput | SortOrder
    respondedById?: SortOrderInput | SortOrder
    isRead?: SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    respondedBy?: UserOrderByWithRelationInput
  }

  export type SystemFeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemFeedbackWhereInput | SystemFeedbackWhereInput[]
    OR?: SystemFeedbackWhereInput[]
    NOT?: SystemFeedbackWhereInput | SystemFeedbackWhereInput[]
    userId?: StringFilter<"SystemFeedback"> | string
    category?: EnumFeedbackCategoryFilter<"SystemFeedback"> | $Enums.FeedbackCategory
    priority?: EnumFeedbackPriorityNullableFilter<"SystemFeedback"> | $Enums.FeedbackPriority | null
    title?: StringFilter<"SystemFeedback"> | string
    message?: StringFilter<"SystemFeedback"> | string
    satisfactionRating?: IntNullableFilter<"SystemFeedback"> | number | null
    adminResponse?: StringNullableFilter<"SystemFeedback"> | string | null
    respondedAt?: DateTimeNullableFilter<"SystemFeedback"> | Date | string | null
    respondedById?: StringNullableFilter<"SystemFeedback"> | string | null
    isRead?: BoolFilter<"SystemFeedback"> | boolean
    isResolved?: BoolFilter<"SystemFeedback"> | boolean
    resolvedAt?: DateTimeNullableFilter<"SystemFeedback"> | Date | string | null
    createdAt?: DateTimeFilter<"SystemFeedback"> | Date | string
    updatedAt?: DateTimeFilter<"SystemFeedback"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    respondedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type SystemFeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    category?: SortOrder
    priority?: SortOrderInput | SortOrder
    title?: SortOrder
    message?: SortOrder
    satisfactionRating?: SortOrderInput | SortOrder
    adminResponse?: SortOrderInput | SortOrder
    respondedAt?: SortOrderInput | SortOrder
    respondedById?: SortOrderInput | SortOrder
    isRead?: SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemFeedbackCountOrderByAggregateInput
    _avg?: SystemFeedbackAvgOrderByAggregateInput
    _max?: SystemFeedbackMaxOrderByAggregateInput
    _min?: SystemFeedbackMinOrderByAggregateInput
    _sum?: SystemFeedbackSumOrderByAggregateInput
  }

  export type SystemFeedbackScalarWhereWithAggregatesInput = {
    AND?: SystemFeedbackScalarWhereWithAggregatesInput | SystemFeedbackScalarWhereWithAggregatesInput[]
    OR?: SystemFeedbackScalarWhereWithAggregatesInput[]
    NOT?: SystemFeedbackScalarWhereWithAggregatesInput | SystemFeedbackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemFeedback"> | string
    userId?: StringWithAggregatesFilter<"SystemFeedback"> | string
    category?: EnumFeedbackCategoryWithAggregatesFilter<"SystemFeedback"> | $Enums.FeedbackCategory
    priority?: EnumFeedbackPriorityNullableWithAggregatesFilter<"SystemFeedback"> | $Enums.FeedbackPriority | null
    title?: StringWithAggregatesFilter<"SystemFeedback"> | string
    message?: StringWithAggregatesFilter<"SystemFeedback"> | string
    satisfactionRating?: IntNullableWithAggregatesFilter<"SystemFeedback"> | number | null
    adminResponse?: StringNullableWithAggregatesFilter<"SystemFeedback"> | string | null
    respondedAt?: DateTimeNullableWithAggregatesFilter<"SystemFeedback"> | Date | string | null
    respondedById?: StringNullableWithAggregatesFilter<"SystemFeedback"> | string | null
    isRead?: BoolWithAggregatesFilter<"SystemFeedback"> | boolean
    isResolved?: BoolWithAggregatesFilter<"SystemFeedback"> | boolean
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"SystemFeedback"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SystemFeedback"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemFeedback"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    suspendedBy?: UserCreateNestedOneWithoutSuspendedUsersInput
    suspendedUsers?: UserCreateNestedManyWithoutSuspendedByInput
    provider?: ProviderCreateNestedOneWithoutUserInput
    verifiedProviders?: ProviderCreateNestedManyWithoutVerifierInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    cancelledAppointments?: AppointmentCreateNestedManyWithoutCancellerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    conversationsAsUser1?: ConversationCreateNestedManyWithoutUser1Input
    conversationsAsUser2?: ConversationCreateNestedManyWithoutUser2Input
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewLikes?: ReviewLikeCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackCreateNestedManyWithoutRespondedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutAdminInput
    providerStatusChanges?: ProviderStatusHistoryCreateNestedManyWithoutChangedByInput
    verifiedDocuments?: DocumentCreateNestedManyWithoutVerifiedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    suspendedById?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    suspendedUsers?: UserUncheckedCreateNestedManyWithoutSuspendedByInput
    provider?: ProviderUncheckedCreateNestedOneWithoutUserInput
    verifiedProviders?: ProviderUncheckedCreateNestedManyWithoutVerifierInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    cancelledAppointments?: AppointmentUncheckedCreateNestedManyWithoutCancellerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conversationsAsUser1?: ConversationUncheckedCreateNestedManyWithoutUser1Input
    conversationsAsUser2?: ConversationUncheckedCreateNestedManyWithoutUser2Input
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewLikes?: ReviewLikeUncheckedCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackUncheckedCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackUncheckedCreateNestedManyWithoutRespondedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    verifiedDocuments?: DocumentUncheckedCreateNestedManyWithoutVerifiedByInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    suspendedBy?: UserUpdateOneWithoutSuspendedUsersNestedInput
    suspendedUsers?: UserUpdateManyWithoutSuspendedByNestedInput
    provider?: ProviderUpdateOneWithoutUserNestedInput
    verifiedProviders?: ProviderUpdateManyWithoutVerifierNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    cancelledAppointments?: AppointmentUpdateManyWithoutCancellerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    conversationsAsUser1?: ConversationUpdateManyWithoutUser1NestedInput
    conversationsAsUser2?: ConversationUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewLikes?: ReviewLikeUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUpdateManyWithoutRespondedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutAdminNestedInput
    providerStatusChanges?: ProviderStatusHistoryUpdateManyWithoutChangedByNestedInput
    verifiedDocuments?: DocumentUpdateManyWithoutVerifiedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedById?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    suspendedUsers?: UserUncheckedUpdateManyWithoutSuspendedByNestedInput
    provider?: ProviderUncheckedUpdateOneWithoutUserNestedInput
    verifiedProviders?: ProviderUncheckedUpdateManyWithoutVerifierNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    cancelledAppointments?: AppointmentUncheckedUpdateManyWithoutCancellerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conversationsAsUser1?: ConversationUncheckedUpdateManyWithoutUser1NestedInput
    conversationsAsUser2?: ConversationUncheckedUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewLikes?: ReviewLikeUncheckedUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUncheckedUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUncheckedUpdateManyWithoutRespondedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminNestedInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    verifiedDocuments?: DocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    suspendedById?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type SessionCreateManyInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AccountCreateInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUncheckedCreateInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateManyInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    color?: string
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    providers?: ProviderCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    color?: string
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    providers?: ProviderUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    providers?: ProviderUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    providers?: ProviderUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    color?: string
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProviderCreateInput = {
    id?: string
    healthcareName: string
    description?: string | null
    phoneNumber?: string | null
    email?: string | null
    coverPhoto?: string | null
    status?: $Enums.ProviderStatus
    address: string
    city?: string
    province?: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    slotDuration?: number
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProviderInput
    category?: CategoryCreateNestedOneWithoutProvidersInput
    verifier?: UserCreateNestedOneWithoutVerifiedProvidersInput
    services?: ServiceCreateNestedManyWithoutProviderInput
    operatingHours?: OperatingHourCreateNestedManyWithoutProviderInput
    appointments?: AppointmentCreateNestedManyWithoutProviderInput
    documents?: DocumentCreateNestedManyWithoutProviderInput
    breakTimes?: BreakTimeCreateNestedManyWithoutProviderInput
    notifications?: NotificationCreateNestedManyWithoutProviderInput
    reviews?: ReviewCreateNestedManyWithoutProviderInput
    statusHistory?: ProviderStatusHistoryCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateInput = {
    id?: string
    userId: string
    categoryId?: string | null
    verifiedBy?: string | null
    healthcareName: string
    description?: string | null
    phoneNumber?: string | null
    email?: string | null
    coverPhoto?: string | null
    status?: $Enums.ProviderStatus
    address: string
    city?: string
    province?: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    slotDuration?: number
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutProviderInput
    operatingHours?: OperatingHourUncheckedCreateNestedManyWithoutProviderInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutProviderInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProviderInput
    breakTimes?: BreakTimeUncheckedCreateNestedManyWithoutProviderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutProviderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProviderInput
    statusHistory?: ProviderStatusHistoryUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    healthcareName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    slotDuration?: IntFieldUpdateOperationsInput | number
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProviderNestedInput
    category?: CategoryUpdateOneWithoutProvidersNestedInput
    verifier?: UserUpdateOneWithoutVerifiedProvidersNestedInput
    services?: ServiceUpdateManyWithoutProviderNestedInput
    operatingHours?: OperatingHourUpdateManyWithoutProviderNestedInput
    appointments?: AppointmentUpdateManyWithoutProviderNestedInput
    documents?: DocumentUpdateManyWithoutProviderNestedInput
    breakTimes?: BreakTimeUpdateManyWithoutProviderNestedInput
    notifications?: NotificationUpdateManyWithoutProviderNestedInput
    reviews?: ReviewUpdateManyWithoutProviderNestedInput
    statusHistory?: ProviderStatusHistoryUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    healthcareName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    slotDuration?: IntFieldUpdateOperationsInput | number
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutProviderNestedInput
    operatingHours?: OperatingHourUncheckedUpdateManyWithoutProviderNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutProviderNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProviderNestedInput
    breakTimes?: BreakTimeUncheckedUpdateManyWithoutProviderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutProviderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProviderNestedInput
    statusHistory?: ProviderStatusHistoryUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type ProviderCreateManyInput = {
    id?: string
    userId: string
    categoryId?: string | null
    verifiedBy?: string | null
    healthcareName: string
    description?: string | null
    phoneNumber?: string | null
    email?: string | null
    coverPhoto?: string | null
    status?: $Enums.ProviderStatus
    address: string
    city?: string
    province?: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    slotDuration?: number
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProviderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    healthcareName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    slotDuration?: IntFieldUpdateOperationsInput | number
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProviderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    healthcareName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    slotDuration?: IntFieldUpdateOperationsInput | number
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateInput = {
    id?: string
    name: string
    description?: string | null
    type?: $Enums.ServiceType
    pricingModel?: $Enums.PricingModel
    fixedPrice?: number
    priceMin?: number
    priceMax?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: ProviderCreateNestedOneWithoutServicesInput
    appointments?: AppointmentServiceCreateNestedManyWithoutServiceInput
    includedServices?: ServicePackageCreateNestedManyWithoutParentPackageInput
    partOfPackages?: ServicePackageCreateNestedManyWithoutChildServiceInput
    acceptedInsurances?: ServiceInsuranceCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    providerId: string
    name: string
    description?: string | null
    type?: $Enums.ServiceType
    pricingModel?: $Enums.PricingModel
    fixedPrice?: number
    priceMin?: number
    priceMax?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentServiceUncheckedCreateNestedManyWithoutServiceInput
    includedServices?: ServicePackageUncheckedCreateNestedManyWithoutParentPackageInput
    partOfPackages?: ServicePackageUncheckedCreateNestedManyWithoutChildServiceInput
    acceptedInsurances?: ServiceInsuranceUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    fixedPrice?: IntFieldUpdateOperationsInput | number
    priceMin?: IntFieldUpdateOperationsInput | number
    priceMax?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: ProviderUpdateOneRequiredWithoutServicesNestedInput
    appointments?: AppointmentServiceUpdateManyWithoutServiceNestedInput
    includedServices?: ServicePackageUpdateManyWithoutParentPackageNestedInput
    partOfPackages?: ServicePackageUpdateManyWithoutChildServiceNestedInput
    acceptedInsurances?: ServiceInsuranceUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    fixedPrice?: IntFieldUpdateOperationsInput | number
    priceMin?: IntFieldUpdateOperationsInput | number
    priceMax?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentServiceUncheckedUpdateManyWithoutServiceNestedInput
    includedServices?: ServicePackageUncheckedUpdateManyWithoutParentPackageNestedInput
    partOfPackages?: ServicePackageUncheckedUpdateManyWithoutChildServiceNestedInput
    acceptedInsurances?: ServiceInsuranceUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    providerId: string
    name: string
    description?: string | null
    type?: $Enums.ServiceType
    pricingModel?: $Enums.PricingModel
    fixedPrice?: number
    priceMin?: number
    priceMax?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    fixedPrice?: IntFieldUpdateOperationsInput | number
    priceMin?: IntFieldUpdateOperationsInput | number
    priceMax?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    fixedPrice?: IntFieldUpdateOperationsInput | number
    priceMin?: IntFieldUpdateOperationsInput | number
    priceMax?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePackageCreateInput = {
    createdAt?: Date | string
    parentPackage: ServiceCreateNestedOneWithoutIncludedServicesInput
    childService: ServiceCreateNestedOneWithoutPartOfPackagesInput
  }

  export type ServicePackageUncheckedCreateInput = {
    parentPackageId: string
    childServiceId: string
    createdAt?: Date | string
  }

  export type ServicePackageUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentPackage?: ServiceUpdateOneRequiredWithoutIncludedServicesNestedInput
    childService?: ServiceUpdateOneRequiredWithoutPartOfPackagesNestedInput
  }

  export type ServicePackageUncheckedUpdateInput = {
    parentPackageId?: StringFieldUpdateOperationsInput | string
    childServiceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePackageCreateManyInput = {
    parentPackageId: string
    childServiceId: string
    createdAt?: Date | string
  }

  export type ServicePackageUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePackageUncheckedUpdateManyInput = {
    parentPackageId?: StringFieldUpdateOperationsInput | string
    childServiceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsuranceProviderCreateInput = {
    id?: string
    name: string
    isActive?: boolean
    services?: ServiceInsuranceCreateNestedManyWithoutInsuranceProviderInput
  }

  export type InsuranceProviderUncheckedCreateInput = {
    id?: string
    name: string
    isActive?: boolean
    services?: ServiceInsuranceUncheckedCreateNestedManyWithoutInsuranceProviderInput
  }

  export type InsuranceProviderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    services?: ServiceInsuranceUpdateManyWithoutInsuranceProviderNestedInput
  }

  export type InsuranceProviderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    services?: ServiceInsuranceUncheckedUpdateManyWithoutInsuranceProviderNestedInput
  }

  export type InsuranceProviderCreateManyInput = {
    id?: string
    name: string
    isActive?: boolean
  }

  export type InsuranceProviderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InsuranceProviderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServiceInsuranceCreateInput = {
    service: ServiceCreateNestedOneWithoutAcceptedInsurancesInput
    insuranceProvider: InsuranceProviderCreateNestedOneWithoutServicesInput
  }

  export type ServiceInsuranceUncheckedCreateInput = {
    serviceId: string
    insuranceProviderId: string
  }

  export type ServiceInsuranceUpdateInput = {
    service?: ServiceUpdateOneRequiredWithoutAcceptedInsurancesNestedInput
    insuranceProvider?: InsuranceProviderUpdateOneRequiredWithoutServicesNestedInput
  }

  export type ServiceInsuranceUncheckedUpdateInput = {
    serviceId?: StringFieldUpdateOperationsInput | string
    insuranceProviderId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceInsuranceCreateManyInput = {
    serviceId: string
    insuranceProviderId: string
  }

  export type ServiceInsuranceUpdateManyMutationInput = {

  }

  export type ServiceInsuranceUncheckedUpdateManyInput = {
    serviceId?: StringFieldUpdateOperationsInput | string
    insuranceProviderId?: StringFieldUpdateOperationsInput | string
  }

  export type OperatingHourCreateInput = {
    id?: string
    dayOfWeek: number
    startTime?: string | null
    endTime?: string | null
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: ProviderCreateNestedOneWithoutOperatingHoursInput
  }

  export type OperatingHourUncheckedCreateInput = {
    id?: string
    providerId: string
    dayOfWeek: number
    startTime?: string | null
    endTime?: string | null
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OperatingHourUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: ProviderUpdateOneRequiredWithoutOperatingHoursNestedInput
  }

  export type OperatingHourUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperatingHourCreateManyInput = {
    id?: string
    providerId: string
    dayOfWeek: number
    startTime?: string | null
    endTime?: string | null
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OperatingHourUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperatingHourUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreakTimeCreateInput = {
    id?: string
    name?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: ProviderCreateNestedOneWithoutBreakTimesInput
  }

  export type BreakTimeUncheckedCreateInput = {
    id?: string
    providerId: string
    name?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreakTimeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: ProviderUpdateOneRequiredWithoutBreakTimesNestedInput
  }

  export type BreakTimeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreakTimeCreateManyInput = {
    id?: string
    providerId: string
    name?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreakTimeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreakTimeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateInput = {
    id?: string
    appointmentNumber: string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.AppointmentStatus
    notes?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    patientName: string
    patientEmail: string
    patientPhone?: string | null
    activityNotes?: string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAppointmentsInput
    provider: ProviderCreateNestedOneWithoutAppointmentsInput
    canceller?: UserCreateNestedOneWithoutCancelledAppointmentsInput
    services?: AppointmentServiceCreateNestedManyWithoutAppointmentInput
    notifications?: NotificationCreateNestedManyWithoutAppointmentInput
    review?: ReviewCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateInput = {
    id?: string
    appointmentNumber: string
    userId: string
    providerId: string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.AppointmentStatus
    notes?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    patientName: string
    patientEmail: string
    patientPhone?: string | null
    activityNotes?: string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    cancelledBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: AppointmentServiceUncheckedCreateNestedManyWithoutAppointmentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutAppointmentInput
    review?: ReviewUncheckedCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentNumber?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patientName?: StringFieldUpdateOperationsInput | string
    patientEmail?: StringFieldUpdateOperationsInput | string
    patientPhone?: NullableStringFieldUpdateOperationsInput | string | null
    activityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAppointmentsNestedInput
    provider?: ProviderUpdateOneRequiredWithoutAppointmentsNestedInput
    canceller?: UserUpdateOneWithoutCancelledAppointmentsNestedInput
    services?: AppointmentServiceUpdateManyWithoutAppointmentNestedInput
    notifications?: NotificationUpdateManyWithoutAppointmentNestedInput
    review?: ReviewUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentNumber?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patientName?: StringFieldUpdateOperationsInput | string
    patientEmail?: StringFieldUpdateOperationsInput | string
    patientPhone?: NullableStringFieldUpdateOperationsInput | string | null
    activityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: AppointmentServiceUncheckedUpdateManyWithoutAppointmentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutAppointmentNestedInput
    review?: ReviewUncheckedUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentCreateManyInput = {
    id?: string
    appointmentNumber: string
    userId: string
    providerId: string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.AppointmentStatus
    notes?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    patientName: string
    patientEmail: string
    patientPhone?: string | null
    activityNotes?: string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    cancelledBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentNumber?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patientName?: StringFieldUpdateOperationsInput | string
    patientEmail?: StringFieldUpdateOperationsInput | string
    patientPhone?: NullableStringFieldUpdateOperationsInput | string | null
    activityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentNumber?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patientName?: StringFieldUpdateOperationsInput | string
    patientEmail?: StringFieldUpdateOperationsInput | string
    patientPhone?: NullableStringFieldUpdateOperationsInput | string | null
    activityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentServiceCreateInput = {
    priceAtBooking: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment: AppointmentCreateNestedOneWithoutServicesInput
    service: ServiceCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentServiceUncheckedCreateInput = {
    appointmentId: string
    serviceId: string
    priceAtBooking: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentServiceUpdateInput = {
    priceAtBooking?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneRequiredWithoutServicesNestedInput
    service?: ServiceUpdateOneRequiredWithoutAppointmentsNestedInput
  }

  export type AppointmentServiceUncheckedUpdateInput = {
    appointmentId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    priceAtBooking?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentServiceCreateManyInput = {
    appointmentId: string
    serviceId: string
    priceAtBooking: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentServiceUpdateManyMutationInput = {
    priceAtBooking?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentServiceUncheckedUpdateManyInput = {
    appointmentId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    priceAtBooking?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    id?: string
    documentType: string
    filePath: string
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    verificationStatus?: $Enums.DocumentVerificationStatus
    rejectionReason?: string | null
    verifiedBy?: UserCreateNestedOneWithoutVerifiedDocumentsInput
    provider: ProviderCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    providerId: string
    documentType: string
    filePath: string
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    verificationStatus?: $Enums.DocumentVerificationStatus
    verifiedById?: string | null
    rejectionReason?: string | null
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationStatus?: EnumDocumentVerificationStatusFieldUpdateOperationsInput | $Enums.DocumentVerificationStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: UserUpdateOneWithoutVerifiedDocumentsNestedInput
    provider?: ProviderUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationStatus?: EnumDocumentVerificationStatusFieldUpdateOperationsInput | $Enums.DocumentVerificationStatus
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentCreateManyInput = {
    id?: string
    providerId: string
    documentType: string
    filePath: string
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    verificationStatus?: $Enums.DocumentVerificationStatus
    verifiedById?: string | null
    rejectionReason?: string | null
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationStatus?: EnumDocumentVerificationStatusFieldUpdateOperationsInput | $Enums.DocumentVerificationStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationStatus?: EnumDocumentVerificationStatusFieldUpdateOperationsInput | $Enums.DocumentVerificationStatus
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
    appointment?: AppointmentCreateNestedOneWithoutNotificationsInput
    provider?: ProviderCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    appointmentId?: string | null
    providerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
    appointment?: AppointmentUpdateOneWithoutNotificationsNestedInput
    provider?: ProviderUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    appointmentId?: string | null
    providerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationCreateInput = {
    id?: string
    lastMessageAt?: Date | string | null
    lastMessageContent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user1: UserCreateNestedOneWithoutConversationsAsUser1Input
    user2: UserCreateNestedOneWithoutConversationsAsUser2Input
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateInput = {
    id?: string
    user1Id: string
    user2Id: string
    lastMessageAt?: Date | string | null
    lastMessageContent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageContent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user1?: UserUpdateOneRequiredWithoutConversationsAsUser1NestedInput
    user2?: UserUpdateOneRequiredWithoutConversationsAsUser2NestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user1Id?: StringFieldUpdateOperationsInput | string
    user2Id?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageContent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateManyInput = {
    id?: string
    user1Id: string
    user2Id: string
    lastMessageAt?: Date | string | null
    lastMessageContent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageContent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user1Id?: StringFieldUpdateOperationsInput | string
    user2Id?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageContent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    content: string
    status?: $Enums.MessageStatus
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    conversationId: string
    senderId: string
    content: string
    status?: $Enums.MessageStatus
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    conversationId: string
    senderId: string
    content: string
    status?: $Enums.MessageStatus
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateInput = {
    id?: string
    rating: number
    comment?: string | null
    isAnonymous?: boolean
    professionalismRating?: number | null
    cleanlinessRating?: number | null
    waitTimeRating?: number | null
    valueRating?: number | null
    providerResponse?: string | null
    respondedAt?: Date | string | null
    isEdited?: boolean
    editedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment: AppointmentCreateNestedOneWithoutReviewInput
    user: UserCreateNestedOneWithoutReviewsInput
    provider: ProviderCreateNestedOneWithoutReviewsInput
    likes?: ReviewLikeCreateNestedManyWithoutReviewInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    appointmentId: string
    userId: string
    providerId: string
    rating: number
    comment?: string | null
    isAnonymous?: boolean
    professionalismRating?: number | null
    cleanlinessRating?: number | null
    waitTimeRating?: number | null
    valueRating?: number | null
    providerResponse?: string | null
    respondedAt?: Date | string | null
    isEdited?: boolean
    editedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: ReviewLikeUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    professionalismRating?: NullableIntFieldUpdateOperationsInput | number | null
    cleanlinessRating?: NullableIntFieldUpdateOperationsInput | number | null
    waitTimeRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueRating?: NullableIntFieldUpdateOperationsInput | number | null
    providerResponse?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneRequiredWithoutReviewNestedInput
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    provider?: ProviderUpdateOneRequiredWithoutReviewsNestedInput
    likes?: ReviewLikeUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    professionalismRating?: NullableIntFieldUpdateOperationsInput | number | null
    cleanlinessRating?: NullableIntFieldUpdateOperationsInput | number | null
    waitTimeRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueRating?: NullableIntFieldUpdateOperationsInput | number | null
    providerResponse?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: ReviewLikeUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ReviewCreateManyInput = {
    id?: string
    appointmentId: string
    userId: string
    providerId: string
    rating: number
    comment?: string | null
    isAnonymous?: boolean
    professionalismRating?: number | null
    cleanlinessRating?: number | null
    waitTimeRating?: number | null
    valueRating?: number | null
    providerResponse?: string | null
    respondedAt?: Date | string | null
    isEdited?: boolean
    editedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    professionalismRating?: NullableIntFieldUpdateOperationsInput | number | null
    cleanlinessRating?: NullableIntFieldUpdateOperationsInput | number | null
    waitTimeRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueRating?: NullableIntFieldUpdateOperationsInput | number | null
    providerResponse?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    professionalismRating?: NullableIntFieldUpdateOperationsInput | number | null
    cleanlinessRating?: NullableIntFieldUpdateOperationsInput | number | null
    waitTimeRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueRating?: NullableIntFieldUpdateOperationsInput | number | null
    providerResponse?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewLikeCreateInput = {
    id?: string
    createdAt?: Date | string
    review: ReviewCreateNestedOneWithoutLikesInput
    user: UserCreateNestedOneWithoutReviewLikesInput
  }

  export type ReviewLikeUncheckedCreateInput = {
    id?: string
    reviewId: string
    userId: string
    createdAt?: Date | string
  }

  export type ReviewLikeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: ReviewUpdateOneRequiredWithoutLikesNestedInput
    user?: UserUpdateOneRequiredWithoutReviewLikesNestedInput
  }

  export type ReviewLikeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewLikeCreateManyInput = {
    id?: string
    reviewId: string
    userId: string
    createdAt?: Date | string
  }

  export type ReviewLikeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewLikeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    targetType: string
    targetId: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    admin: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    adminId: string
    action: string
    targetType: string
    targetId: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    adminId: string
    action: string
    targetType: string
    targetId: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProviderStatusHistoryCreateInput = {
    id?: string
    fromStatus: $Enums.ProviderStatus
    toStatus: $Enums.ProviderStatus
    reason?: string | null
    createdAt?: Date | string
    provider: ProviderCreateNestedOneWithoutStatusHistoryInput
    changedBy: UserCreateNestedOneWithoutProviderStatusChangesInput
  }

  export type ProviderStatusHistoryUncheckedCreateInput = {
    id?: string
    providerId: string
    fromStatus: $Enums.ProviderStatus
    toStatus: $Enums.ProviderStatus
    reason?: string | null
    changedById: string
    createdAt?: Date | string
  }

  export type ProviderStatusHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromStatus?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    toStatus?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: ProviderUpdateOneRequiredWithoutStatusHistoryNestedInput
    changedBy?: UserUpdateOneRequiredWithoutProviderStatusChangesNestedInput
  }

  export type ProviderStatusHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    fromStatus?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    toStatus?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    changedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProviderStatusHistoryCreateManyInput = {
    id?: string
    providerId: string
    fromStatus: $Enums.ProviderStatus
    toStatus: $Enums.ProviderStatus
    reason?: string | null
    changedById: string
    createdAt?: Date | string
  }

  export type ProviderStatusHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromStatus?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    toStatus?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProviderStatusHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    fromStatus?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    toStatus?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    changedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemFeedbackCreateInput = {
    id?: string
    category: $Enums.FeedbackCategory
    priority?: $Enums.FeedbackPriority | null
    title: string
    message: string
    satisfactionRating?: number | null
    adminResponse?: string | null
    respondedAt?: Date | string | null
    isRead?: boolean
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFeedbackSubmittedInput
    respondedBy?: UserCreateNestedOneWithoutFeedbackResponsesInput
  }

  export type SystemFeedbackUncheckedCreateInput = {
    id?: string
    userId: string
    category: $Enums.FeedbackCategory
    priority?: $Enums.FeedbackPriority | null
    title: string
    message: string
    satisfactionRating?: number | null
    adminResponse?: string | null
    respondedAt?: Date | string | null
    respondedById?: string | null
    isRead?: boolean
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemFeedbackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumFeedbackCategoryFieldUpdateOperationsInput | $Enums.FeedbackCategory
    priority?: NullableEnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    satisfactionRating?: NullableIntFieldUpdateOperationsInput | number | null
    adminResponse?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFeedbackSubmittedNestedInput
    respondedBy?: UserUpdateOneWithoutFeedbackResponsesNestedInput
  }

  export type SystemFeedbackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    category?: EnumFeedbackCategoryFieldUpdateOperationsInput | $Enums.FeedbackCategory
    priority?: NullableEnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    satisfactionRating?: NullableIntFieldUpdateOperationsInput | number | null
    adminResponse?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedById?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemFeedbackCreateManyInput = {
    id?: string
    userId: string
    category: $Enums.FeedbackCategory
    priority?: $Enums.FeedbackPriority | null
    title: string
    message: string
    satisfactionRating?: number | null
    adminResponse?: string | null
    respondedAt?: Date | string | null
    respondedById?: string | null
    isRead?: boolean
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemFeedbackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumFeedbackCategoryFieldUpdateOperationsInput | $Enums.FeedbackCategory
    priority?: NullableEnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    satisfactionRating?: NullableIntFieldUpdateOperationsInput | number | null
    adminResponse?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemFeedbackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    category?: EnumFeedbackCategoryFieldUpdateOperationsInput | $Enums.FeedbackCategory
    priority?: NullableEnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    satisfactionRating?: NullableIntFieldUpdateOperationsInput | number | null
    adminResponse?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedById?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type ProviderNullableScalarRelationFilter = {
    is?: ProviderWhereInput | null
    isNot?: ProviderWhereInput | null
  }

  export type ProviderListRelationFilter = {
    every?: ProviderWhereInput
    some?: ProviderWhereInput
    none?: ProviderWhereInput
  }

  export type AppointmentListRelationFilter = {
    every?: AppointmentWhereInput
    some?: AppointmentWhereInput
    none?: AppointmentWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type ConversationListRelationFilter = {
    every?: ConversationWhereInput
    some?: ConversationWhereInput
    none?: ConversationWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type ReviewLikeListRelationFilter = {
    every?: ReviewLikeWhereInput
    some?: ReviewLikeWhereInput
    none?: ReviewLikeWhereInput
  }

  export type SystemFeedbackListRelationFilter = {
    every?: SystemFeedbackWhereInput
    some?: SystemFeedbackWhereInput
    none?: SystemFeedbackWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type ProviderStatusHistoryListRelationFilter = {
    every?: ProviderStatusHistoryWhereInput
    some?: ProviderStatusHistoryWhereInput
    none?: ProviderStatusHistoryWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProviderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppointmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewLikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SystemFeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProviderStatusHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
    status?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    suspendedAt?: SortOrder
    suspendReason?: SortOrder
    suspendedById?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
    status?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    suspendedAt?: SortOrder
    suspendReason?: SortOrder
    suspendedById?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
    status?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    suspendedAt?: SortOrder
    suspendReason?: SortOrder
    suspendedById?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumProviderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProviderStatus | EnumProviderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProviderStatus[] | ListEnumProviderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProviderStatus[] | ListEnumProviderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProviderStatusFilter<$PrismaModel> | $Enums.ProviderStatus
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type CategoryNullableScalarRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput
    some?: ServiceWhereInput
    none?: ServiceWhereInput
  }

  export type OperatingHourListRelationFilter = {
    every?: OperatingHourWhereInput
    some?: OperatingHourWhereInput
    none?: OperatingHourWhereInput
  }

  export type BreakTimeListRelationFilter = {
    every?: BreakTimeWhereInput
    some?: BreakTimeWhereInput
    none?: BreakTimeWhereInput
  }

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OperatingHourOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BreakTimeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProviderCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrder
    verifiedBy?: SortOrder
    healthcareName?: SortOrder
    description?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    coverPhoto?: SortOrder
    status?: SortOrder
    address?: SortOrder
    city?: SortOrder
    province?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    slotDuration?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProviderAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    slotDuration?: SortOrder
  }

  export type ProviderMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrder
    verifiedBy?: SortOrder
    healthcareName?: SortOrder
    description?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    coverPhoto?: SortOrder
    status?: SortOrder
    address?: SortOrder
    city?: SortOrder
    province?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    slotDuration?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProviderMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrder
    verifiedBy?: SortOrder
    healthcareName?: SortOrder
    description?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    coverPhoto?: SortOrder
    status?: SortOrder
    address?: SortOrder
    city?: SortOrder
    province?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    slotDuration?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProviderSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    slotDuration?: SortOrder
  }

  export type EnumProviderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProviderStatus | EnumProviderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProviderStatus[] | ListEnumProviderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProviderStatus[] | ListEnumProviderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProviderStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProviderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProviderStatusFilter<$PrismaModel>
    _max?: NestedEnumProviderStatusFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumServiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeFilter<$PrismaModel> | $Enums.ServiceType
  }

  export type EnumPricingModelFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingModel | EnumPricingModelFieldRefInput<$PrismaModel>
    in?: $Enums.PricingModel[] | ListEnumPricingModelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PricingModel[] | ListEnumPricingModelFieldRefInput<$PrismaModel>
    not?: NestedEnumPricingModelFilter<$PrismaModel> | $Enums.PricingModel
  }

  export type ProviderScalarRelationFilter = {
    is?: ProviderWhereInput
    isNot?: ProviderWhereInput
  }

  export type AppointmentServiceListRelationFilter = {
    every?: AppointmentServiceWhereInput
    some?: AppointmentServiceWhereInput
    none?: AppointmentServiceWhereInput
  }

  export type ServicePackageListRelationFilter = {
    every?: ServicePackageWhereInput
    some?: ServicePackageWhereInput
    none?: ServicePackageWhereInput
  }

  export type ServiceInsuranceListRelationFilter = {
    every?: ServiceInsuranceWhereInput
    some?: ServiceInsuranceWhereInput
    none?: ServiceInsuranceWhereInput
  }

  export type AppointmentServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServicePackageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceInsuranceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    pricingModel?: SortOrder
    fixedPrice?: SortOrder
    priceMin?: SortOrder
    priceMax?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    fixedPrice?: SortOrder
    priceMin?: SortOrder
    priceMax?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    pricingModel?: SortOrder
    fixedPrice?: SortOrder
    priceMin?: SortOrder
    priceMax?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    pricingModel?: SortOrder
    fixedPrice?: SortOrder
    priceMin?: SortOrder
    priceMax?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    fixedPrice?: SortOrder
    priceMin?: SortOrder
    priceMax?: SortOrder
  }

  export type EnumServiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ServiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceTypeFilter<$PrismaModel>
    _max?: NestedEnumServiceTypeFilter<$PrismaModel>
  }

  export type EnumPricingModelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingModel | EnumPricingModelFieldRefInput<$PrismaModel>
    in?: $Enums.PricingModel[] | ListEnumPricingModelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PricingModel[] | ListEnumPricingModelFieldRefInput<$PrismaModel>
    not?: NestedEnumPricingModelWithAggregatesFilter<$PrismaModel> | $Enums.PricingModel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPricingModelFilter<$PrismaModel>
    _max?: NestedEnumPricingModelFilter<$PrismaModel>
  }

  export type ServiceScalarRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type ServicePackageParentPackageIdChildServiceIdCompoundUniqueInput = {
    parentPackageId: string
    childServiceId: string
  }

  export type ServicePackageCountOrderByAggregateInput = {
    parentPackageId?: SortOrder
    childServiceId?: SortOrder
    createdAt?: SortOrder
  }

  export type ServicePackageMaxOrderByAggregateInput = {
    parentPackageId?: SortOrder
    childServiceId?: SortOrder
    createdAt?: SortOrder
  }

  export type ServicePackageMinOrderByAggregateInput = {
    parentPackageId?: SortOrder
    childServiceId?: SortOrder
    createdAt?: SortOrder
  }

  export type InsuranceProviderCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
  }

  export type InsuranceProviderMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
  }

  export type InsuranceProviderMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
  }

  export type InsuranceProviderScalarRelationFilter = {
    is?: InsuranceProviderWhereInput
    isNot?: InsuranceProviderWhereInput
  }

  export type ServiceInsuranceServiceIdInsuranceProviderIdCompoundUniqueInput = {
    serviceId: string
    insuranceProviderId: string
  }

  export type ServiceInsuranceCountOrderByAggregateInput = {
    serviceId?: SortOrder
    insuranceProviderId?: SortOrder
  }

  export type ServiceInsuranceMaxOrderByAggregateInput = {
    serviceId?: SortOrder
    insuranceProviderId?: SortOrder
  }

  export type ServiceInsuranceMinOrderByAggregateInput = {
    serviceId?: SortOrder
    insuranceProviderId?: SortOrder
  }

  export type OperatingHourCountOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OperatingHourAvgOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type OperatingHourMaxOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OperatingHourMinOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OperatingHourSumOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type BreakTimeCountOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BreakTimeAvgOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type BreakTimeMaxOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BreakTimeMinOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BreakTimeSumOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type EnumAppointmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusFilter<$PrismaModel> | $Enums.AppointmentStatus
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type ReviewNullableScalarRelationFilter = {
    is?: ReviewWhereInput | null
    isNot?: ReviewWhereInput | null
  }

  export type AppointmentCountOrderByAggregateInput = {
    id?: SortOrder
    appointmentNumber?: SortOrder
    userId?: SortOrder
    providerId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    totalPrice?: SortOrder
    patientName?: SortOrder
    patientEmail?: SortOrder
    patientPhone?: SortOrder
    activityNotes?: SortOrder
    cancelledAt?: SortOrder
    cancellationReason?: SortOrder
    cancelledBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppointmentAvgOrderByAggregateInput = {
    totalPrice?: SortOrder
  }

  export type AppointmentMaxOrderByAggregateInput = {
    id?: SortOrder
    appointmentNumber?: SortOrder
    userId?: SortOrder
    providerId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    totalPrice?: SortOrder
    patientName?: SortOrder
    patientEmail?: SortOrder
    patientPhone?: SortOrder
    activityNotes?: SortOrder
    cancelledAt?: SortOrder
    cancellationReason?: SortOrder
    cancelledBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppointmentMinOrderByAggregateInput = {
    id?: SortOrder
    appointmentNumber?: SortOrder
    userId?: SortOrder
    providerId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    totalPrice?: SortOrder
    patientName?: SortOrder
    patientEmail?: SortOrder
    patientPhone?: SortOrder
    activityNotes?: SortOrder
    cancelledAt?: SortOrder
    cancellationReason?: SortOrder
    cancelledBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppointmentSumOrderByAggregateInput = {
    totalPrice?: SortOrder
  }

  export type EnumAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAppointmentStatusFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type AppointmentScalarRelationFilter = {
    is?: AppointmentWhereInput
    isNot?: AppointmentWhereInput
  }

  export type AppointmentServiceAppointmentIdServiceIdCompoundUniqueInput = {
    appointmentId: string
    serviceId: string
  }

  export type AppointmentServiceCountOrderByAggregateInput = {
    appointmentId?: SortOrder
    serviceId?: SortOrder
    priceAtBooking?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppointmentServiceAvgOrderByAggregateInput = {
    priceAtBooking?: SortOrder
  }

  export type AppointmentServiceMaxOrderByAggregateInput = {
    appointmentId?: SortOrder
    serviceId?: SortOrder
    priceAtBooking?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppointmentServiceMinOrderByAggregateInput = {
    appointmentId?: SortOrder
    serviceId?: SortOrder
    priceAtBooking?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppointmentServiceSumOrderByAggregateInput = {
    priceAtBooking?: SortOrder
  }

  export type EnumDocumentVerificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentVerificationStatus | EnumDocumentVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentVerificationStatus[] | ListEnumDocumentVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentVerificationStatus[] | ListEnumDocumentVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentVerificationStatusFilter<$PrismaModel> | $Enums.DocumentVerificationStatus
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    documentType?: SortOrder
    filePath?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    verificationStatus?: SortOrder
    verifiedById?: SortOrder
    rejectionReason?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    documentType?: SortOrder
    filePath?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    verificationStatus?: SortOrder
    verifiedById?: SortOrder
    rejectionReason?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    documentType?: SortOrder
    filePath?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    verificationStatus?: SortOrder
    verifiedById?: SortOrder
    rejectionReason?: SortOrder
  }

  export type EnumDocumentVerificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentVerificationStatus | EnumDocumentVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentVerificationStatus[] | ListEnumDocumentVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentVerificationStatus[] | ListEnumDocumentVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentVerificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.DocumentVerificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentVerificationStatusFilter<$PrismaModel>
    _max?: NestedEnumDocumentVerificationStatusFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AppointmentNullableScalarRelationFilter = {
    is?: AppointmentWhereInput | null
    isNot?: AppointmentWhereInput | null
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    appointmentId?: SortOrder
    providerId?: SortOrder
    metadata?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    appointmentId?: SortOrder
    providerId?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    appointmentId?: SortOrder
    providerId?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type ConversationUser1IdUser2IdCompoundUniqueInput = {
    user1Id: string
    user2Id: string
  }

  export type ConversationCountOrderByAggregateInput = {
    id?: SortOrder
    user1Id?: SortOrder
    user2Id?: SortOrder
    lastMessageAt?: SortOrder
    lastMessageContent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    user1Id?: SortOrder
    user2Id?: SortOrder
    lastMessageAt?: SortOrder
    lastMessageContent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMinOrderByAggregateInput = {
    id?: SortOrder
    user1Id?: SortOrder
    user2Id?: SortOrder
    lastMessageAt?: SortOrder
    lastMessageContent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMessageStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageStatusFilter<$PrismaModel> | $Enums.MessageStatus
  }

  export type ConversationScalarRelationFilter = {
    is?: ConversationWhereInput
    isNot?: ConversationWhereInput
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    status?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    status?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    status?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMessageStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageStatusWithAggregatesFilter<$PrismaModel> | $Enums.MessageStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageStatusFilter<$PrismaModel>
    _max?: NestedEnumMessageStatusFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    appointmentId?: SortOrder
    userId?: SortOrder
    providerId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    isAnonymous?: SortOrder
    professionalismRating?: SortOrder
    cleanlinessRating?: SortOrder
    waitTimeRating?: SortOrder
    valueRating?: SortOrder
    providerResponse?: SortOrder
    respondedAt?: SortOrder
    isEdited?: SortOrder
    editedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
    professionalismRating?: SortOrder
    cleanlinessRating?: SortOrder
    waitTimeRating?: SortOrder
    valueRating?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    appointmentId?: SortOrder
    userId?: SortOrder
    providerId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    isAnonymous?: SortOrder
    professionalismRating?: SortOrder
    cleanlinessRating?: SortOrder
    waitTimeRating?: SortOrder
    valueRating?: SortOrder
    providerResponse?: SortOrder
    respondedAt?: SortOrder
    isEdited?: SortOrder
    editedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    appointmentId?: SortOrder
    userId?: SortOrder
    providerId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    isAnonymous?: SortOrder
    professionalismRating?: SortOrder
    cleanlinessRating?: SortOrder
    waitTimeRating?: SortOrder
    valueRating?: SortOrder
    providerResponse?: SortOrder
    respondedAt?: SortOrder
    isEdited?: SortOrder
    editedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    rating?: SortOrder
    professionalismRating?: SortOrder
    cleanlinessRating?: SortOrder
    waitTimeRating?: SortOrder
    valueRating?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ReviewScalarRelationFilter = {
    is?: ReviewWhereInput
    isNot?: ReviewWhereInput
  }

  export type ReviewLikeReviewIdUserIdCompoundUniqueInput = {
    reviewId: string
    userId: string
  }

  export type ReviewLikeCountOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewLikeMaxOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewLikeMinOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    metadata?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type ProviderStatusHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    fromStatus?: SortOrder
    toStatus?: SortOrder
    reason?: SortOrder
    changedById?: SortOrder
    createdAt?: SortOrder
  }

  export type ProviderStatusHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    fromStatus?: SortOrder
    toStatus?: SortOrder
    reason?: SortOrder
    changedById?: SortOrder
    createdAt?: SortOrder
  }

  export type ProviderStatusHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    fromStatus?: SortOrder
    toStatus?: SortOrder
    reason?: SortOrder
    changedById?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumFeedbackCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackCategory | EnumFeedbackCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackCategory[] | ListEnumFeedbackCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackCategory[] | ListEnumFeedbackCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackCategoryFilter<$PrismaModel> | $Enums.FeedbackCategory
  }

  export type EnumFeedbackPriorityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackPriority | EnumFeedbackPriorityFieldRefInput<$PrismaModel> | null
    in?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFeedbackPriorityNullableFilter<$PrismaModel> | $Enums.FeedbackPriority | null
  }

  export type SystemFeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    message?: SortOrder
    satisfactionRating?: SortOrder
    adminResponse?: SortOrder
    respondedAt?: SortOrder
    respondedById?: SortOrder
    isRead?: SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemFeedbackAvgOrderByAggregateInput = {
    satisfactionRating?: SortOrder
  }

  export type SystemFeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    message?: SortOrder
    satisfactionRating?: SortOrder
    adminResponse?: SortOrder
    respondedAt?: SortOrder
    respondedById?: SortOrder
    isRead?: SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemFeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    message?: SortOrder
    satisfactionRating?: SortOrder
    adminResponse?: SortOrder
    respondedAt?: SortOrder
    respondedById?: SortOrder
    isRead?: SortOrder
    isResolved?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemFeedbackSumOrderByAggregateInput = {
    satisfactionRating?: SortOrder
  }

  export type EnumFeedbackCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackCategory | EnumFeedbackCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackCategory[] | ListEnumFeedbackCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackCategory[] | ListEnumFeedbackCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackCategoryWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackCategoryFilter<$PrismaModel>
    _max?: NestedEnumFeedbackCategoryFilter<$PrismaModel>
  }

  export type EnumFeedbackPriorityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackPriority | EnumFeedbackPriorityFieldRefInput<$PrismaModel> | null
    in?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFeedbackPriorityNullableWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackPriority | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumFeedbackPriorityNullableFilter<$PrismaModel>
    _max?: NestedEnumFeedbackPriorityNullableFilter<$PrismaModel>
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutSuspendedUsersInput = {
    create?: XOR<UserCreateWithoutSuspendedUsersInput, UserUncheckedCreateWithoutSuspendedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutSuspendedUsersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutSuspendedByInput = {
    create?: XOR<UserCreateWithoutSuspendedByInput, UserUncheckedCreateWithoutSuspendedByInput> | UserCreateWithoutSuspendedByInput[] | UserUncheckedCreateWithoutSuspendedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSuspendedByInput | UserCreateOrConnectWithoutSuspendedByInput[]
    createMany?: UserCreateManySuspendedByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ProviderCreateNestedOneWithoutUserInput = {
    create?: XOR<ProviderCreateWithoutUserInput, ProviderUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutUserInput
    connect?: ProviderWhereUniqueInput
  }

  export type ProviderCreateNestedManyWithoutVerifierInput = {
    create?: XOR<ProviderCreateWithoutVerifierInput, ProviderUncheckedCreateWithoutVerifierInput> | ProviderCreateWithoutVerifierInput[] | ProviderUncheckedCreateWithoutVerifierInput[]
    connectOrCreate?: ProviderCreateOrConnectWithoutVerifierInput | ProviderCreateOrConnectWithoutVerifierInput[]
    createMany?: ProviderCreateManyVerifierInputEnvelope
    connect?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutUserInput = {
    create?: XOR<AppointmentCreateWithoutUserInput, AppointmentUncheckedCreateWithoutUserInput> | AppointmentCreateWithoutUserInput[] | AppointmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutUserInput | AppointmentCreateOrConnectWithoutUserInput[]
    createMany?: AppointmentCreateManyUserInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutCancellerInput = {
    create?: XOR<AppointmentCreateWithoutCancellerInput, AppointmentUncheckedCreateWithoutCancellerInput> | AppointmentCreateWithoutCancellerInput[] | AppointmentUncheckedCreateWithoutCancellerInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutCancellerInput | AppointmentCreateOrConnectWithoutCancellerInput[]
    createMany?: AppointmentCreateManyCancellerInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutUser1Input = {
    create?: XOR<ConversationCreateWithoutUser1Input, ConversationUncheckedCreateWithoutUser1Input> | ConversationCreateWithoutUser1Input[] | ConversationUncheckedCreateWithoutUser1Input[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUser1Input | ConversationCreateOrConnectWithoutUser1Input[]
    createMany?: ConversationCreateManyUser1InputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutUser2Input = {
    create?: XOR<ConversationCreateWithoutUser2Input, ConversationUncheckedCreateWithoutUser2Input> | ConversationCreateWithoutUser2Input[] | ConversationUncheckedCreateWithoutUser2Input[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUser2Input | ConversationCreateOrConnectWithoutUser2Input[]
    createMany?: ConversationCreateManyUser2InputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ReviewLikeCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewLikeCreateWithoutUserInput, ReviewLikeUncheckedCreateWithoutUserInput> | ReviewLikeCreateWithoutUserInput[] | ReviewLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewLikeCreateOrConnectWithoutUserInput | ReviewLikeCreateOrConnectWithoutUserInput[]
    createMany?: ReviewLikeCreateManyUserInputEnvelope
    connect?: ReviewLikeWhereUniqueInput | ReviewLikeWhereUniqueInput[]
  }

  export type SystemFeedbackCreateNestedManyWithoutUserInput = {
    create?: XOR<SystemFeedbackCreateWithoutUserInput, SystemFeedbackUncheckedCreateWithoutUserInput> | SystemFeedbackCreateWithoutUserInput[] | SystemFeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SystemFeedbackCreateOrConnectWithoutUserInput | SystemFeedbackCreateOrConnectWithoutUserInput[]
    createMany?: SystemFeedbackCreateManyUserInputEnvelope
    connect?: SystemFeedbackWhereUniqueInput | SystemFeedbackWhereUniqueInput[]
  }

  export type SystemFeedbackCreateNestedManyWithoutRespondedByInput = {
    create?: XOR<SystemFeedbackCreateWithoutRespondedByInput, SystemFeedbackUncheckedCreateWithoutRespondedByInput> | SystemFeedbackCreateWithoutRespondedByInput[] | SystemFeedbackUncheckedCreateWithoutRespondedByInput[]
    connectOrCreate?: SystemFeedbackCreateOrConnectWithoutRespondedByInput | SystemFeedbackCreateOrConnectWithoutRespondedByInput[]
    createMany?: SystemFeedbackCreateManyRespondedByInputEnvelope
    connect?: SystemFeedbackWhereUniqueInput | SystemFeedbackWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutAdminInput = {
    create?: XOR<AuditLogCreateWithoutAdminInput, AuditLogUncheckedCreateWithoutAdminInput> | AuditLogCreateWithoutAdminInput[] | AuditLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutAdminInput | AuditLogCreateOrConnectWithoutAdminInput[]
    createMany?: AuditLogCreateManyAdminInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type ProviderStatusHistoryCreateNestedManyWithoutChangedByInput = {
    create?: XOR<ProviderStatusHistoryCreateWithoutChangedByInput, ProviderStatusHistoryUncheckedCreateWithoutChangedByInput> | ProviderStatusHistoryCreateWithoutChangedByInput[] | ProviderStatusHistoryUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: ProviderStatusHistoryCreateOrConnectWithoutChangedByInput | ProviderStatusHistoryCreateOrConnectWithoutChangedByInput[]
    createMany?: ProviderStatusHistoryCreateManyChangedByInputEnvelope
    connect?: ProviderStatusHistoryWhereUniqueInput | ProviderStatusHistoryWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutVerifiedByInput = {
    create?: XOR<DocumentCreateWithoutVerifiedByInput, DocumentUncheckedCreateWithoutVerifiedByInput> | DocumentCreateWithoutVerifiedByInput[] | DocumentUncheckedCreateWithoutVerifiedByInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutVerifiedByInput | DocumentCreateOrConnectWithoutVerifiedByInput[]
    createMany?: DocumentCreateManyVerifiedByInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutSuspendedByInput = {
    create?: XOR<UserCreateWithoutSuspendedByInput, UserUncheckedCreateWithoutSuspendedByInput> | UserCreateWithoutSuspendedByInput[] | UserUncheckedCreateWithoutSuspendedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSuspendedByInput | UserCreateOrConnectWithoutSuspendedByInput[]
    createMany?: UserCreateManySuspendedByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ProviderUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ProviderCreateWithoutUserInput, ProviderUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutUserInput
    connect?: ProviderWhereUniqueInput
  }

  export type ProviderUncheckedCreateNestedManyWithoutVerifierInput = {
    create?: XOR<ProviderCreateWithoutVerifierInput, ProviderUncheckedCreateWithoutVerifierInput> | ProviderCreateWithoutVerifierInput[] | ProviderUncheckedCreateWithoutVerifierInput[]
    connectOrCreate?: ProviderCreateOrConnectWithoutVerifierInput | ProviderCreateOrConnectWithoutVerifierInput[]
    createMany?: ProviderCreateManyVerifierInputEnvelope
    connect?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AppointmentCreateWithoutUserInput, AppointmentUncheckedCreateWithoutUserInput> | AppointmentCreateWithoutUserInput[] | AppointmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutUserInput | AppointmentCreateOrConnectWithoutUserInput[]
    createMany?: AppointmentCreateManyUserInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutCancellerInput = {
    create?: XOR<AppointmentCreateWithoutCancellerInput, AppointmentUncheckedCreateWithoutCancellerInput> | AppointmentCreateWithoutCancellerInput[] | AppointmentUncheckedCreateWithoutCancellerInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutCancellerInput | AppointmentCreateOrConnectWithoutCancellerInput[]
    createMany?: AppointmentCreateManyCancellerInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutUser1Input = {
    create?: XOR<ConversationCreateWithoutUser1Input, ConversationUncheckedCreateWithoutUser1Input> | ConversationCreateWithoutUser1Input[] | ConversationUncheckedCreateWithoutUser1Input[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUser1Input | ConversationCreateOrConnectWithoutUser1Input[]
    createMany?: ConversationCreateManyUser1InputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutUser2Input = {
    create?: XOR<ConversationCreateWithoutUser2Input, ConversationUncheckedCreateWithoutUser2Input> | ConversationCreateWithoutUser2Input[] | ConversationUncheckedCreateWithoutUser2Input[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUser2Input | ConversationCreateOrConnectWithoutUser2Input[]
    createMany?: ConversationCreateManyUser2InputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ReviewLikeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewLikeCreateWithoutUserInput, ReviewLikeUncheckedCreateWithoutUserInput> | ReviewLikeCreateWithoutUserInput[] | ReviewLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewLikeCreateOrConnectWithoutUserInput | ReviewLikeCreateOrConnectWithoutUserInput[]
    createMany?: ReviewLikeCreateManyUserInputEnvelope
    connect?: ReviewLikeWhereUniqueInput | ReviewLikeWhereUniqueInput[]
  }

  export type SystemFeedbackUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SystemFeedbackCreateWithoutUserInput, SystemFeedbackUncheckedCreateWithoutUserInput> | SystemFeedbackCreateWithoutUserInput[] | SystemFeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SystemFeedbackCreateOrConnectWithoutUserInput | SystemFeedbackCreateOrConnectWithoutUserInput[]
    createMany?: SystemFeedbackCreateManyUserInputEnvelope
    connect?: SystemFeedbackWhereUniqueInput | SystemFeedbackWhereUniqueInput[]
  }

  export type SystemFeedbackUncheckedCreateNestedManyWithoutRespondedByInput = {
    create?: XOR<SystemFeedbackCreateWithoutRespondedByInput, SystemFeedbackUncheckedCreateWithoutRespondedByInput> | SystemFeedbackCreateWithoutRespondedByInput[] | SystemFeedbackUncheckedCreateWithoutRespondedByInput[]
    connectOrCreate?: SystemFeedbackCreateOrConnectWithoutRespondedByInput | SystemFeedbackCreateOrConnectWithoutRespondedByInput[]
    createMany?: SystemFeedbackCreateManyRespondedByInputEnvelope
    connect?: SystemFeedbackWhereUniqueInput | SystemFeedbackWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AuditLogCreateWithoutAdminInput, AuditLogUncheckedCreateWithoutAdminInput> | AuditLogCreateWithoutAdminInput[] | AuditLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutAdminInput | AuditLogCreateOrConnectWithoutAdminInput[]
    createMany?: AuditLogCreateManyAdminInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type ProviderStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput = {
    create?: XOR<ProviderStatusHistoryCreateWithoutChangedByInput, ProviderStatusHistoryUncheckedCreateWithoutChangedByInput> | ProviderStatusHistoryCreateWithoutChangedByInput[] | ProviderStatusHistoryUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: ProviderStatusHistoryCreateOrConnectWithoutChangedByInput | ProviderStatusHistoryCreateOrConnectWithoutChangedByInput[]
    createMany?: ProviderStatusHistoryCreateManyChangedByInputEnvelope
    connect?: ProviderStatusHistoryWhereUniqueInput | ProviderStatusHistoryWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutVerifiedByInput = {
    create?: XOR<DocumentCreateWithoutVerifiedByInput, DocumentUncheckedCreateWithoutVerifiedByInput> | DocumentCreateWithoutVerifiedByInput[] | DocumentUncheckedCreateWithoutVerifiedByInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutVerifiedByInput | DocumentCreateOrConnectWithoutVerifiedByInput[]
    createMany?: DocumentCreateManyVerifiedByInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type UserUpdateOneWithoutSuspendedUsersNestedInput = {
    create?: XOR<UserCreateWithoutSuspendedUsersInput, UserUncheckedCreateWithoutSuspendedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutSuspendedUsersInput
    upsert?: UserUpsertWithoutSuspendedUsersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSuspendedUsersInput, UserUpdateWithoutSuspendedUsersInput>, UserUncheckedUpdateWithoutSuspendedUsersInput>
  }

  export type UserUpdateManyWithoutSuspendedByNestedInput = {
    create?: XOR<UserCreateWithoutSuspendedByInput, UserUncheckedCreateWithoutSuspendedByInput> | UserCreateWithoutSuspendedByInput[] | UserUncheckedCreateWithoutSuspendedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSuspendedByInput | UserCreateOrConnectWithoutSuspendedByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSuspendedByInput | UserUpsertWithWhereUniqueWithoutSuspendedByInput[]
    createMany?: UserCreateManySuspendedByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSuspendedByInput | UserUpdateWithWhereUniqueWithoutSuspendedByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSuspendedByInput | UserUpdateManyWithWhereWithoutSuspendedByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ProviderUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProviderCreateWithoutUserInput, ProviderUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutUserInput
    upsert?: ProviderUpsertWithoutUserInput
    disconnect?: ProviderWhereInput | boolean
    delete?: ProviderWhereInput | boolean
    connect?: ProviderWhereUniqueInput
    update?: XOR<XOR<ProviderUpdateToOneWithWhereWithoutUserInput, ProviderUpdateWithoutUserInput>, ProviderUncheckedUpdateWithoutUserInput>
  }

  export type ProviderUpdateManyWithoutVerifierNestedInput = {
    create?: XOR<ProviderCreateWithoutVerifierInput, ProviderUncheckedCreateWithoutVerifierInput> | ProviderCreateWithoutVerifierInput[] | ProviderUncheckedCreateWithoutVerifierInput[]
    connectOrCreate?: ProviderCreateOrConnectWithoutVerifierInput | ProviderCreateOrConnectWithoutVerifierInput[]
    upsert?: ProviderUpsertWithWhereUniqueWithoutVerifierInput | ProviderUpsertWithWhereUniqueWithoutVerifierInput[]
    createMany?: ProviderCreateManyVerifierInputEnvelope
    set?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[]
    disconnect?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[]
    delete?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[]
    connect?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[]
    update?: ProviderUpdateWithWhereUniqueWithoutVerifierInput | ProviderUpdateWithWhereUniqueWithoutVerifierInput[]
    updateMany?: ProviderUpdateManyWithWhereWithoutVerifierInput | ProviderUpdateManyWithWhereWithoutVerifierInput[]
    deleteMany?: ProviderScalarWhereInput | ProviderScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<AppointmentCreateWithoutUserInput, AppointmentUncheckedCreateWithoutUserInput> | AppointmentCreateWithoutUserInput[] | AppointmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutUserInput | AppointmentCreateOrConnectWithoutUserInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutUserInput | AppointmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AppointmentCreateManyUserInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutUserInput | AppointmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutUserInput | AppointmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutCancellerNestedInput = {
    create?: XOR<AppointmentCreateWithoutCancellerInput, AppointmentUncheckedCreateWithoutCancellerInput> | AppointmentCreateWithoutCancellerInput[] | AppointmentUncheckedCreateWithoutCancellerInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutCancellerInput | AppointmentCreateOrConnectWithoutCancellerInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutCancellerInput | AppointmentUpsertWithWhereUniqueWithoutCancellerInput[]
    createMany?: AppointmentCreateManyCancellerInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutCancellerInput | AppointmentUpdateWithWhereUniqueWithoutCancellerInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutCancellerInput | AppointmentUpdateManyWithWhereWithoutCancellerInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutUser1NestedInput = {
    create?: XOR<ConversationCreateWithoutUser1Input, ConversationUncheckedCreateWithoutUser1Input> | ConversationCreateWithoutUser1Input[] | ConversationUncheckedCreateWithoutUser1Input[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUser1Input | ConversationCreateOrConnectWithoutUser1Input[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutUser1Input | ConversationUpsertWithWhereUniqueWithoutUser1Input[]
    createMany?: ConversationCreateManyUser1InputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutUser1Input | ConversationUpdateWithWhereUniqueWithoutUser1Input[]
    updateMany?: ConversationUpdateManyWithWhereWithoutUser1Input | ConversationUpdateManyWithWhereWithoutUser1Input[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutUser2NestedInput = {
    create?: XOR<ConversationCreateWithoutUser2Input, ConversationUncheckedCreateWithoutUser2Input> | ConversationCreateWithoutUser2Input[] | ConversationUncheckedCreateWithoutUser2Input[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUser2Input | ConversationCreateOrConnectWithoutUser2Input[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutUser2Input | ConversationUpsertWithWhereUniqueWithoutUser2Input[]
    createMany?: ConversationCreateManyUser2InputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutUser2Input | ConversationUpdateWithWhereUniqueWithoutUser2Input[]
    updateMany?: ConversationUpdateManyWithWhereWithoutUser2Input | ConversationUpdateManyWithWhereWithoutUser2Input[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ReviewLikeUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewLikeCreateWithoutUserInput, ReviewLikeUncheckedCreateWithoutUserInput> | ReviewLikeCreateWithoutUserInput[] | ReviewLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewLikeCreateOrConnectWithoutUserInput | ReviewLikeCreateOrConnectWithoutUserInput[]
    upsert?: ReviewLikeUpsertWithWhereUniqueWithoutUserInput | ReviewLikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewLikeCreateManyUserInputEnvelope
    set?: ReviewLikeWhereUniqueInput | ReviewLikeWhereUniqueInput[]
    disconnect?: ReviewLikeWhereUniqueInput | ReviewLikeWhereUniqueInput[]
    delete?: ReviewLikeWhereUniqueInput | ReviewLikeWhereUniqueInput[]
    connect?: ReviewLikeWhereUniqueInput | ReviewLikeWhereUniqueInput[]
    update?: ReviewLikeUpdateWithWhereUniqueWithoutUserInput | ReviewLikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewLikeUpdateManyWithWhereWithoutUserInput | ReviewLikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewLikeScalarWhereInput | ReviewLikeScalarWhereInput[]
  }

  export type SystemFeedbackUpdateManyWithoutUserNestedInput = {
    create?: XOR<SystemFeedbackCreateWithoutUserInput, SystemFeedbackUncheckedCreateWithoutUserInput> | SystemFeedbackCreateWithoutUserInput[] | SystemFeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SystemFeedbackCreateOrConnectWithoutUserInput | SystemFeedbackCreateOrConnectWithoutUserInput[]
    upsert?: SystemFeedbackUpsertWithWhereUniqueWithoutUserInput | SystemFeedbackUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SystemFeedbackCreateManyUserInputEnvelope
    set?: SystemFeedbackWhereUniqueInput | SystemFeedbackWhereUniqueInput[]
    disconnect?: SystemFeedbackWhereUniqueInput | SystemFeedbackWhereUniqueInput[]
    delete?: SystemFeedbackWhereUniqueInput | SystemFeedbackWhereUniqueInput[]
    connect?: SystemFeedbackWhereUniqueInput | SystemFeedbackWhereUniqueInput[]
    update?: SystemFeedbackUpdateWithWhereUniqueWithoutUserInput | SystemFeedbackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SystemFeedbackUpdateManyWithWhereWithoutUserInput | SystemFeedbackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SystemFeedbackScalarWhereInput | SystemFeedbackScalarWhereInput[]
  }

  export type SystemFeedbackUpdateManyWithoutRespondedByNestedInput = {
    create?: XOR<SystemFeedbackCreateWithoutRespondedByInput, SystemFeedbackUncheckedCreateWithoutRespondedByInput> | SystemFeedbackCreateWithoutRespondedByInput[] | SystemFeedbackUncheckedCreateWithoutRespondedByInput[]
    connectOrCreate?: SystemFeedbackCreateOrConnectWithoutRespondedByInput | SystemFeedbackCreateOrConnectWithoutRespondedByInput[]
    upsert?: SystemFeedbackUpsertWithWhereUniqueWithoutRespondedByInput | SystemFeedbackUpsertWithWhereUniqueWithoutRespondedByInput[]
    createMany?: SystemFeedbackCreateManyRespondedByInputEnvelope
    set?: SystemFeedbackWhereUniqueInput | SystemFeedbackWhereUniqueInput[]
    disconnect?: SystemFeedbackWhereUniqueInput | SystemFeedbackWhereUniqueInput[]
    delete?: SystemFeedbackWhereUniqueInput | SystemFeedbackWhereUniqueInput[]
    connect?: SystemFeedbackWhereUniqueInput | SystemFeedbackWhereUniqueInput[]
    update?: SystemFeedbackUpdateWithWhereUniqueWithoutRespondedByInput | SystemFeedbackUpdateWithWhereUniqueWithoutRespondedByInput[]
    updateMany?: SystemFeedbackUpdateManyWithWhereWithoutRespondedByInput | SystemFeedbackUpdateManyWithWhereWithoutRespondedByInput[]
    deleteMany?: SystemFeedbackScalarWhereInput | SystemFeedbackScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AuditLogCreateWithoutAdminInput, AuditLogUncheckedCreateWithoutAdminInput> | AuditLogCreateWithoutAdminInput[] | AuditLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutAdminInput | AuditLogCreateOrConnectWithoutAdminInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutAdminInput | AuditLogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AuditLogCreateManyAdminInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutAdminInput | AuditLogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutAdminInput | AuditLogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type ProviderStatusHistoryUpdateManyWithoutChangedByNestedInput = {
    create?: XOR<ProviderStatusHistoryCreateWithoutChangedByInput, ProviderStatusHistoryUncheckedCreateWithoutChangedByInput> | ProviderStatusHistoryCreateWithoutChangedByInput[] | ProviderStatusHistoryUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: ProviderStatusHistoryCreateOrConnectWithoutChangedByInput | ProviderStatusHistoryCreateOrConnectWithoutChangedByInput[]
    upsert?: ProviderStatusHistoryUpsertWithWhereUniqueWithoutChangedByInput | ProviderStatusHistoryUpsertWithWhereUniqueWithoutChangedByInput[]
    createMany?: ProviderStatusHistoryCreateManyChangedByInputEnvelope
    set?: ProviderStatusHistoryWhereUniqueInput | ProviderStatusHistoryWhereUniqueInput[]
    disconnect?: ProviderStatusHistoryWhereUniqueInput | ProviderStatusHistoryWhereUniqueInput[]
    delete?: ProviderStatusHistoryWhereUniqueInput | ProviderStatusHistoryWhereUniqueInput[]
    connect?: ProviderStatusHistoryWhereUniqueInput | ProviderStatusHistoryWhereUniqueInput[]
    update?: ProviderStatusHistoryUpdateWithWhereUniqueWithoutChangedByInput | ProviderStatusHistoryUpdateWithWhereUniqueWithoutChangedByInput[]
    updateMany?: ProviderStatusHistoryUpdateManyWithWhereWithoutChangedByInput | ProviderStatusHistoryUpdateManyWithWhereWithoutChangedByInput[]
    deleteMany?: ProviderStatusHistoryScalarWhereInput | ProviderStatusHistoryScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutVerifiedByNestedInput = {
    create?: XOR<DocumentCreateWithoutVerifiedByInput, DocumentUncheckedCreateWithoutVerifiedByInput> | DocumentCreateWithoutVerifiedByInput[] | DocumentUncheckedCreateWithoutVerifiedByInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutVerifiedByInput | DocumentCreateOrConnectWithoutVerifiedByInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutVerifiedByInput | DocumentUpsertWithWhereUniqueWithoutVerifiedByInput[]
    createMany?: DocumentCreateManyVerifiedByInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutVerifiedByInput | DocumentUpdateWithWhereUniqueWithoutVerifiedByInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutVerifiedByInput | DocumentUpdateManyWithWhereWithoutVerifiedByInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutSuspendedByNestedInput = {
    create?: XOR<UserCreateWithoutSuspendedByInput, UserUncheckedCreateWithoutSuspendedByInput> | UserCreateWithoutSuspendedByInput[] | UserUncheckedCreateWithoutSuspendedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSuspendedByInput | UserCreateOrConnectWithoutSuspendedByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSuspendedByInput | UserUpsertWithWhereUniqueWithoutSuspendedByInput[]
    createMany?: UserCreateManySuspendedByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSuspendedByInput | UserUpdateWithWhereUniqueWithoutSuspendedByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSuspendedByInput | UserUpdateManyWithWhereWithoutSuspendedByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ProviderUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProviderCreateWithoutUserInput, ProviderUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutUserInput
    upsert?: ProviderUpsertWithoutUserInput
    disconnect?: ProviderWhereInput | boolean
    delete?: ProviderWhereInput | boolean
    connect?: ProviderWhereUniqueInput
    update?: XOR<XOR<ProviderUpdateToOneWithWhereWithoutUserInput, ProviderUpdateWithoutUserInput>, ProviderUncheckedUpdateWithoutUserInput>
  }

  export type ProviderUncheckedUpdateManyWithoutVerifierNestedInput = {
    create?: XOR<ProviderCreateWithoutVerifierInput, ProviderUncheckedCreateWithoutVerifierInput> | ProviderCreateWithoutVerifierInput[] | ProviderUncheckedCreateWithoutVerifierInput[]
    connectOrCreate?: ProviderCreateOrConnectWithoutVerifierInput | ProviderCreateOrConnectWithoutVerifierInput[]
    upsert?: ProviderUpsertWithWhereUniqueWithoutVerifierInput | ProviderUpsertWithWhereUniqueWithoutVerifierInput[]
    createMany?: ProviderCreateManyVerifierInputEnvelope
    set?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[]
    disconnect?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[]
    delete?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[]
    connect?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[]
    update?: ProviderUpdateWithWhereUniqueWithoutVerifierInput | ProviderUpdateWithWhereUniqueWithoutVerifierInput[]
    updateMany?: ProviderUpdateManyWithWhereWithoutVerifierInput | ProviderUpdateManyWithWhereWithoutVerifierInput[]
    deleteMany?: ProviderScalarWhereInput | ProviderScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AppointmentCreateWithoutUserInput, AppointmentUncheckedCreateWithoutUserInput> | AppointmentCreateWithoutUserInput[] | AppointmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutUserInput | AppointmentCreateOrConnectWithoutUserInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutUserInput | AppointmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AppointmentCreateManyUserInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutUserInput | AppointmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutUserInput | AppointmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutCancellerNestedInput = {
    create?: XOR<AppointmentCreateWithoutCancellerInput, AppointmentUncheckedCreateWithoutCancellerInput> | AppointmentCreateWithoutCancellerInput[] | AppointmentUncheckedCreateWithoutCancellerInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutCancellerInput | AppointmentCreateOrConnectWithoutCancellerInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutCancellerInput | AppointmentUpsertWithWhereUniqueWithoutCancellerInput[]
    createMany?: AppointmentCreateManyCancellerInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutCancellerInput | AppointmentUpdateWithWhereUniqueWithoutCancellerInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutCancellerInput | AppointmentUpdateManyWithWhereWithoutCancellerInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutUser1NestedInput = {
    create?: XOR<ConversationCreateWithoutUser1Input, ConversationUncheckedCreateWithoutUser1Input> | ConversationCreateWithoutUser1Input[] | ConversationUncheckedCreateWithoutUser1Input[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUser1Input | ConversationCreateOrConnectWithoutUser1Input[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutUser1Input | ConversationUpsertWithWhereUniqueWithoutUser1Input[]
    createMany?: ConversationCreateManyUser1InputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutUser1Input | ConversationUpdateWithWhereUniqueWithoutUser1Input[]
    updateMany?: ConversationUpdateManyWithWhereWithoutUser1Input | ConversationUpdateManyWithWhereWithoutUser1Input[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutUser2NestedInput = {
    create?: XOR<ConversationCreateWithoutUser2Input, ConversationUncheckedCreateWithoutUser2Input> | ConversationCreateWithoutUser2Input[] | ConversationUncheckedCreateWithoutUser2Input[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUser2Input | ConversationCreateOrConnectWithoutUser2Input[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutUser2Input | ConversationUpsertWithWhereUniqueWithoutUser2Input[]
    createMany?: ConversationCreateManyUser2InputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutUser2Input | ConversationUpdateWithWhereUniqueWithoutUser2Input[]
    updateMany?: ConversationUpdateManyWithWhereWithoutUser2Input | ConversationUpdateManyWithWhereWithoutUser2Input[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ReviewLikeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewLikeCreateWithoutUserInput, ReviewLikeUncheckedCreateWithoutUserInput> | ReviewLikeCreateWithoutUserInput[] | ReviewLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewLikeCreateOrConnectWithoutUserInput | ReviewLikeCreateOrConnectWithoutUserInput[]
    upsert?: ReviewLikeUpsertWithWhereUniqueWithoutUserInput | ReviewLikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewLikeCreateManyUserInputEnvelope
    set?: ReviewLikeWhereUniqueInput | ReviewLikeWhereUniqueInput[]
    disconnect?: ReviewLikeWhereUniqueInput | ReviewLikeWhereUniqueInput[]
    delete?: ReviewLikeWhereUniqueInput | ReviewLikeWhereUniqueInput[]
    connect?: ReviewLikeWhereUniqueInput | ReviewLikeWhereUniqueInput[]
    update?: ReviewLikeUpdateWithWhereUniqueWithoutUserInput | ReviewLikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewLikeUpdateManyWithWhereWithoutUserInput | ReviewLikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewLikeScalarWhereInput | ReviewLikeScalarWhereInput[]
  }

  export type SystemFeedbackUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SystemFeedbackCreateWithoutUserInput, SystemFeedbackUncheckedCreateWithoutUserInput> | SystemFeedbackCreateWithoutUserInput[] | SystemFeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SystemFeedbackCreateOrConnectWithoutUserInput | SystemFeedbackCreateOrConnectWithoutUserInput[]
    upsert?: SystemFeedbackUpsertWithWhereUniqueWithoutUserInput | SystemFeedbackUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SystemFeedbackCreateManyUserInputEnvelope
    set?: SystemFeedbackWhereUniqueInput | SystemFeedbackWhereUniqueInput[]
    disconnect?: SystemFeedbackWhereUniqueInput | SystemFeedbackWhereUniqueInput[]
    delete?: SystemFeedbackWhereUniqueInput | SystemFeedbackWhereUniqueInput[]
    connect?: SystemFeedbackWhereUniqueInput | SystemFeedbackWhereUniqueInput[]
    update?: SystemFeedbackUpdateWithWhereUniqueWithoutUserInput | SystemFeedbackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SystemFeedbackUpdateManyWithWhereWithoutUserInput | SystemFeedbackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SystemFeedbackScalarWhereInput | SystemFeedbackScalarWhereInput[]
  }

  export type SystemFeedbackUncheckedUpdateManyWithoutRespondedByNestedInput = {
    create?: XOR<SystemFeedbackCreateWithoutRespondedByInput, SystemFeedbackUncheckedCreateWithoutRespondedByInput> | SystemFeedbackCreateWithoutRespondedByInput[] | SystemFeedbackUncheckedCreateWithoutRespondedByInput[]
    connectOrCreate?: SystemFeedbackCreateOrConnectWithoutRespondedByInput | SystemFeedbackCreateOrConnectWithoutRespondedByInput[]
    upsert?: SystemFeedbackUpsertWithWhereUniqueWithoutRespondedByInput | SystemFeedbackUpsertWithWhereUniqueWithoutRespondedByInput[]
    createMany?: SystemFeedbackCreateManyRespondedByInputEnvelope
    set?: SystemFeedbackWhereUniqueInput | SystemFeedbackWhereUniqueInput[]
    disconnect?: SystemFeedbackWhereUniqueInput | SystemFeedbackWhereUniqueInput[]
    delete?: SystemFeedbackWhereUniqueInput | SystemFeedbackWhereUniqueInput[]
    connect?: SystemFeedbackWhereUniqueInput | SystemFeedbackWhereUniqueInput[]
    update?: SystemFeedbackUpdateWithWhereUniqueWithoutRespondedByInput | SystemFeedbackUpdateWithWhereUniqueWithoutRespondedByInput[]
    updateMany?: SystemFeedbackUpdateManyWithWhereWithoutRespondedByInput | SystemFeedbackUpdateManyWithWhereWithoutRespondedByInput[]
    deleteMany?: SystemFeedbackScalarWhereInput | SystemFeedbackScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AuditLogCreateWithoutAdminInput, AuditLogUncheckedCreateWithoutAdminInput> | AuditLogCreateWithoutAdminInput[] | AuditLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutAdminInput | AuditLogCreateOrConnectWithoutAdminInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutAdminInput | AuditLogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AuditLogCreateManyAdminInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutAdminInput | AuditLogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutAdminInput | AuditLogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type ProviderStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput = {
    create?: XOR<ProviderStatusHistoryCreateWithoutChangedByInput, ProviderStatusHistoryUncheckedCreateWithoutChangedByInput> | ProviderStatusHistoryCreateWithoutChangedByInput[] | ProviderStatusHistoryUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: ProviderStatusHistoryCreateOrConnectWithoutChangedByInput | ProviderStatusHistoryCreateOrConnectWithoutChangedByInput[]
    upsert?: ProviderStatusHistoryUpsertWithWhereUniqueWithoutChangedByInput | ProviderStatusHistoryUpsertWithWhereUniqueWithoutChangedByInput[]
    createMany?: ProviderStatusHistoryCreateManyChangedByInputEnvelope
    set?: ProviderStatusHistoryWhereUniqueInput | ProviderStatusHistoryWhereUniqueInput[]
    disconnect?: ProviderStatusHistoryWhereUniqueInput | ProviderStatusHistoryWhereUniqueInput[]
    delete?: ProviderStatusHistoryWhereUniqueInput | ProviderStatusHistoryWhereUniqueInput[]
    connect?: ProviderStatusHistoryWhereUniqueInput | ProviderStatusHistoryWhereUniqueInput[]
    update?: ProviderStatusHistoryUpdateWithWhereUniqueWithoutChangedByInput | ProviderStatusHistoryUpdateWithWhereUniqueWithoutChangedByInput[]
    updateMany?: ProviderStatusHistoryUpdateManyWithWhereWithoutChangedByInput | ProviderStatusHistoryUpdateManyWithWhereWithoutChangedByInput[]
    deleteMany?: ProviderStatusHistoryScalarWhereInput | ProviderStatusHistoryScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutVerifiedByNestedInput = {
    create?: XOR<DocumentCreateWithoutVerifiedByInput, DocumentUncheckedCreateWithoutVerifiedByInput> | DocumentCreateWithoutVerifiedByInput[] | DocumentUncheckedCreateWithoutVerifiedByInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutVerifiedByInput | DocumentCreateOrConnectWithoutVerifiedByInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutVerifiedByInput | DocumentUpsertWithWhereUniqueWithoutVerifiedByInput[]
    createMany?: DocumentCreateManyVerifiedByInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutVerifiedByInput | DocumentUpdateWithWhereUniqueWithoutVerifiedByInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutVerifiedByInput | DocumentUpdateManyWithWhereWithoutVerifiedByInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type ProviderCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProviderCreateWithoutCategoryInput, ProviderUncheckedCreateWithoutCategoryInput> | ProviderCreateWithoutCategoryInput[] | ProviderUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProviderCreateOrConnectWithoutCategoryInput | ProviderCreateOrConnectWithoutCategoryInput[]
    createMany?: ProviderCreateManyCategoryInputEnvelope
    connect?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[]
  }

  export type ProviderUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProviderCreateWithoutCategoryInput, ProviderUncheckedCreateWithoutCategoryInput> | ProviderCreateWithoutCategoryInput[] | ProviderUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProviderCreateOrConnectWithoutCategoryInput | ProviderCreateOrConnectWithoutCategoryInput[]
    createMany?: ProviderCreateManyCategoryInputEnvelope
    connect?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProviderUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProviderCreateWithoutCategoryInput, ProviderUncheckedCreateWithoutCategoryInput> | ProviderCreateWithoutCategoryInput[] | ProviderUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProviderCreateOrConnectWithoutCategoryInput | ProviderCreateOrConnectWithoutCategoryInput[]
    upsert?: ProviderUpsertWithWhereUniqueWithoutCategoryInput | ProviderUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProviderCreateManyCategoryInputEnvelope
    set?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[]
    disconnect?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[]
    delete?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[]
    connect?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[]
    update?: ProviderUpdateWithWhereUniqueWithoutCategoryInput | ProviderUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProviderUpdateManyWithWhereWithoutCategoryInput | ProviderUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProviderScalarWhereInput | ProviderScalarWhereInput[]
  }

  export type ProviderUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProviderCreateWithoutCategoryInput, ProviderUncheckedCreateWithoutCategoryInput> | ProviderCreateWithoutCategoryInput[] | ProviderUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProviderCreateOrConnectWithoutCategoryInput | ProviderCreateOrConnectWithoutCategoryInput[]
    upsert?: ProviderUpsertWithWhereUniqueWithoutCategoryInput | ProviderUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProviderCreateManyCategoryInputEnvelope
    set?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[]
    disconnect?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[]
    delete?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[]
    connect?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[]
    update?: ProviderUpdateWithWhereUniqueWithoutCategoryInput | ProviderUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProviderUpdateManyWithWhereWithoutCategoryInput | ProviderUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProviderScalarWhereInput | ProviderScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutProviderInput = {
    create?: XOR<UserCreateWithoutProviderInput, UserUncheckedCreateWithoutProviderInput>
    connectOrCreate?: UserCreateOrConnectWithoutProviderInput
    connect?: UserWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutProvidersInput = {
    create?: XOR<CategoryCreateWithoutProvidersInput, CategoryUncheckedCreateWithoutProvidersInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProvidersInput
    connect?: CategoryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVerifiedProvidersInput = {
    create?: XOR<UserCreateWithoutVerifiedProvidersInput, UserUncheckedCreateWithoutVerifiedProvidersInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerifiedProvidersInput
    connect?: UserWhereUniqueInput
  }

  export type ServiceCreateNestedManyWithoutProviderInput = {
    create?: XOR<ServiceCreateWithoutProviderInput, ServiceUncheckedCreateWithoutProviderInput> | ServiceCreateWithoutProviderInput[] | ServiceUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutProviderInput | ServiceCreateOrConnectWithoutProviderInput[]
    createMany?: ServiceCreateManyProviderInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type OperatingHourCreateNestedManyWithoutProviderInput = {
    create?: XOR<OperatingHourCreateWithoutProviderInput, OperatingHourUncheckedCreateWithoutProviderInput> | OperatingHourCreateWithoutProviderInput[] | OperatingHourUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: OperatingHourCreateOrConnectWithoutProviderInput | OperatingHourCreateOrConnectWithoutProviderInput[]
    createMany?: OperatingHourCreateManyProviderInputEnvelope
    connect?: OperatingHourWhereUniqueInput | OperatingHourWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutProviderInput = {
    create?: XOR<AppointmentCreateWithoutProviderInput, AppointmentUncheckedCreateWithoutProviderInput> | AppointmentCreateWithoutProviderInput[] | AppointmentUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutProviderInput | AppointmentCreateOrConnectWithoutProviderInput[]
    createMany?: AppointmentCreateManyProviderInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutProviderInput = {
    create?: XOR<DocumentCreateWithoutProviderInput, DocumentUncheckedCreateWithoutProviderInput> | DocumentCreateWithoutProviderInput[] | DocumentUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutProviderInput | DocumentCreateOrConnectWithoutProviderInput[]
    createMany?: DocumentCreateManyProviderInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type BreakTimeCreateNestedManyWithoutProviderInput = {
    create?: XOR<BreakTimeCreateWithoutProviderInput, BreakTimeUncheckedCreateWithoutProviderInput> | BreakTimeCreateWithoutProviderInput[] | BreakTimeUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: BreakTimeCreateOrConnectWithoutProviderInput | BreakTimeCreateOrConnectWithoutProviderInput[]
    createMany?: BreakTimeCreateManyProviderInputEnvelope
    connect?: BreakTimeWhereUniqueInput | BreakTimeWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutProviderInput = {
    create?: XOR<NotificationCreateWithoutProviderInput, NotificationUncheckedCreateWithoutProviderInput> | NotificationCreateWithoutProviderInput[] | NotificationUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutProviderInput | NotificationCreateOrConnectWithoutProviderInput[]
    createMany?: NotificationCreateManyProviderInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutProviderInput = {
    create?: XOR<ReviewCreateWithoutProviderInput, ReviewUncheckedCreateWithoutProviderInput> | ReviewCreateWithoutProviderInput[] | ReviewUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProviderInput | ReviewCreateOrConnectWithoutProviderInput[]
    createMany?: ReviewCreateManyProviderInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ProviderStatusHistoryCreateNestedManyWithoutProviderInput = {
    create?: XOR<ProviderStatusHistoryCreateWithoutProviderInput, ProviderStatusHistoryUncheckedCreateWithoutProviderInput> | ProviderStatusHistoryCreateWithoutProviderInput[] | ProviderStatusHistoryUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ProviderStatusHistoryCreateOrConnectWithoutProviderInput | ProviderStatusHistoryCreateOrConnectWithoutProviderInput[]
    createMany?: ProviderStatusHistoryCreateManyProviderInputEnvelope
    connect?: ProviderStatusHistoryWhereUniqueInput | ProviderStatusHistoryWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<ServiceCreateWithoutProviderInput, ServiceUncheckedCreateWithoutProviderInput> | ServiceCreateWithoutProviderInput[] | ServiceUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutProviderInput | ServiceCreateOrConnectWithoutProviderInput[]
    createMany?: ServiceCreateManyProviderInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type OperatingHourUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<OperatingHourCreateWithoutProviderInput, OperatingHourUncheckedCreateWithoutProviderInput> | OperatingHourCreateWithoutProviderInput[] | OperatingHourUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: OperatingHourCreateOrConnectWithoutProviderInput | OperatingHourCreateOrConnectWithoutProviderInput[]
    createMany?: OperatingHourCreateManyProviderInputEnvelope
    connect?: OperatingHourWhereUniqueInput | OperatingHourWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<AppointmentCreateWithoutProviderInput, AppointmentUncheckedCreateWithoutProviderInput> | AppointmentCreateWithoutProviderInput[] | AppointmentUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutProviderInput | AppointmentCreateOrConnectWithoutProviderInput[]
    createMany?: AppointmentCreateManyProviderInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<DocumentCreateWithoutProviderInput, DocumentUncheckedCreateWithoutProviderInput> | DocumentCreateWithoutProviderInput[] | DocumentUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutProviderInput | DocumentCreateOrConnectWithoutProviderInput[]
    createMany?: DocumentCreateManyProviderInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type BreakTimeUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<BreakTimeCreateWithoutProviderInput, BreakTimeUncheckedCreateWithoutProviderInput> | BreakTimeCreateWithoutProviderInput[] | BreakTimeUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: BreakTimeCreateOrConnectWithoutProviderInput | BreakTimeCreateOrConnectWithoutProviderInput[]
    createMany?: BreakTimeCreateManyProviderInputEnvelope
    connect?: BreakTimeWhereUniqueInput | BreakTimeWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<NotificationCreateWithoutProviderInput, NotificationUncheckedCreateWithoutProviderInput> | NotificationCreateWithoutProviderInput[] | NotificationUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutProviderInput | NotificationCreateOrConnectWithoutProviderInput[]
    createMany?: NotificationCreateManyProviderInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<ReviewCreateWithoutProviderInput, ReviewUncheckedCreateWithoutProviderInput> | ReviewCreateWithoutProviderInput[] | ReviewUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProviderInput | ReviewCreateOrConnectWithoutProviderInput[]
    createMany?: ReviewCreateManyProviderInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ProviderStatusHistoryUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<ProviderStatusHistoryCreateWithoutProviderInput, ProviderStatusHistoryUncheckedCreateWithoutProviderInput> | ProviderStatusHistoryCreateWithoutProviderInput[] | ProviderStatusHistoryUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ProviderStatusHistoryCreateOrConnectWithoutProviderInput | ProviderStatusHistoryCreateOrConnectWithoutProviderInput[]
    createMany?: ProviderStatusHistoryCreateManyProviderInputEnvelope
    connect?: ProviderStatusHistoryWhereUniqueInput | ProviderStatusHistoryWhereUniqueInput[]
  }

  export type EnumProviderStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProviderStatus
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutProviderNestedInput = {
    create?: XOR<UserCreateWithoutProviderInput, UserUncheckedCreateWithoutProviderInput>
    connectOrCreate?: UserCreateOrConnectWithoutProviderInput
    upsert?: UserUpsertWithoutProviderInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProviderInput, UserUpdateWithoutProviderInput>, UserUncheckedUpdateWithoutProviderInput>
  }

  export type CategoryUpdateOneWithoutProvidersNestedInput = {
    create?: XOR<CategoryCreateWithoutProvidersInput, CategoryUncheckedCreateWithoutProvidersInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProvidersInput
    upsert?: CategoryUpsertWithoutProvidersInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutProvidersInput, CategoryUpdateWithoutProvidersInput>, CategoryUncheckedUpdateWithoutProvidersInput>
  }

  export type UserUpdateOneWithoutVerifiedProvidersNestedInput = {
    create?: XOR<UserCreateWithoutVerifiedProvidersInput, UserUncheckedCreateWithoutVerifiedProvidersInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerifiedProvidersInput
    upsert?: UserUpsertWithoutVerifiedProvidersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVerifiedProvidersInput, UserUpdateWithoutVerifiedProvidersInput>, UserUncheckedUpdateWithoutVerifiedProvidersInput>
  }

  export type ServiceUpdateManyWithoutProviderNestedInput = {
    create?: XOR<ServiceCreateWithoutProviderInput, ServiceUncheckedCreateWithoutProviderInput> | ServiceCreateWithoutProviderInput[] | ServiceUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutProviderInput | ServiceCreateOrConnectWithoutProviderInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutProviderInput | ServiceUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: ServiceCreateManyProviderInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutProviderInput | ServiceUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutProviderInput | ServiceUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type OperatingHourUpdateManyWithoutProviderNestedInput = {
    create?: XOR<OperatingHourCreateWithoutProviderInput, OperatingHourUncheckedCreateWithoutProviderInput> | OperatingHourCreateWithoutProviderInput[] | OperatingHourUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: OperatingHourCreateOrConnectWithoutProviderInput | OperatingHourCreateOrConnectWithoutProviderInput[]
    upsert?: OperatingHourUpsertWithWhereUniqueWithoutProviderInput | OperatingHourUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: OperatingHourCreateManyProviderInputEnvelope
    set?: OperatingHourWhereUniqueInput | OperatingHourWhereUniqueInput[]
    disconnect?: OperatingHourWhereUniqueInput | OperatingHourWhereUniqueInput[]
    delete?: OperatingHourWhereUniqueInput | OperatingHourWhereUniqueInput[]
    connect?: OperatingHourWhereUniqueInput | OperatingHourWhereUniqueInput[]
    update?: OperatingHourUpdateWithWhereUniqueWithoutProviderInput | OperatingHourUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: OperatingHourUpdateManyWithWhereWithoutProviderInput | OperatingHourUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: OperatingHourScalarWhereInput | OperatingHourScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutProviderNestedInput = {
    create?: XOR<AppointmentCreateWithoutProviderInput, AppointmentUncheckedCreateWithoutProviderInput> | AppointmentCreateWithoutProviderInput[] | AppointmentUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutProviderInput | AppointmentCreateOrConnectWithoutProviderInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutProviderInput | AppointmentUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: AppointmentCreateManyProviderInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutProviderInput | AppointmentUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutProviderInput | AppointmentUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutProviderNestedInput = {
    create?: XOR<DocumentCreateWithoutProviderInput, DocumentUncheckedCreateWithoutProviderInput> | DocumentCreateWithoutProviderInput[] | DocumentUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutProviderInput | DocumentCreateOrConnectWithoutProviderInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutProviderInput | DocumentUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: DocumentCreateManyProviderInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutProviderInput | DocumentUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutProviderInput | DocumentUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type BreakTimeUpdateManyWithoutProviderNestedInput = {
    create?: XOR<BreakTimeCreateWithoutProviderInput, BreakTimeUncheckedCreateWithoutProviderInput> | BreakTimeCreateWithoutProviderInput[] | BreakTimeUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: BreakTimeCreateOrConnectWithoutProviderInput | BreakTimeCreateOrConnectWithoutProviderInput[]
    upsert?: BreakTimeUpsertWithWhereUniqueWithoutProviderInput | BreakTimeUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: BreakTimeCreateManyProviderInputEnvelope
    set?: BreakTimeWhereUniqueInput | BreakTimeWhereUniqueInput[]
    disconnect?: BreakTimeWhereUniqueInput | BreakTimeWhereUniqueInput[]
    delete?: BreakTimeWhereUniqueInput | BreakTimeWhereUniqueInput[]
    connect?: BreakTimeWhereUniqueInput | BreakTimeWhereUniqueInput[]
    update?: BreakTimeUpdateWithWhereUniqueWithoutProviderInput | BreakTimeUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: BreakTimeUpdateManyWithWhereWithoutProviderInput | BreakTimeUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: BreakTimeScalarWhereInput | BreakTimeScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutProviderNestedInput = {
    create?: XOR<NotificationCreateWithoutProviderInput, NotificationUncheckedCreateWithoutProviderInput> | NotificationCreateWithoutProviderInput[] | NotificationUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutProviderInput | NotificationCreateOrConnectWithoutProviderInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutProviderInput | NotificationUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: NotificationCreateManyProviderInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutProviderInput | NotificationUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutProviderInput | NotificationUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutProviderNestedInput = {
    create?: XOR<ReviewCreateWithoutProviderInput, ReviewUncheckedCreateWithoutProviderInput> | ReviewCreateWithoutProviderInput[] | ReviewUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProviderInput | ReviewCreateOrConnectWithoutProviderInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutProviderInput | ReviewUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: ReviewCreateManyProviderInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutProviderInput | ReviewUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutProviderInput | ReviewUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ProviderStatusHistoryUpdateManyWithoutProviderNestedInput = {
    create?: XOR<ProviderStatusHistoryCreateWithoutProviderInput, ProviderStatusHistoryUncheckedCreateWithoutProviderInput> | ProviderStatusHistoryCreateWithoutProviderInput[] | ProviderStatusHistoryUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ProviderStatusHistoryCreateOrConnectWithoutProviderInput | ProviderStatusHistoryCreateOrConnectWithoutProviderInput[]
    upsert?: ProviderStatusHistoryUpsertWithWhereUniqueWithoutProviderInput | ProviderStatusHistoryUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: ProviderStatusHistoryCreateManyProviderInputEnvelope
    set?: ProviderStatusHistoryWhereUniqueInput | ProviderStatusHistoryWhereUniqueInput[]
    disconnect?: ProviderStatusHistoryWhereUniqueInput | ProviderStatusHistoryWhereUniqueInput[]
    delete?: ProviderStatusHistoryWhereUniqueInput | ProviderStatusHistoryWhereUniqueInput[]
    connect?: ProviderStatusHistoryWhereUniqueInput | ProviderStatusHistoryWhereUniqueInput[]
    update?: ProviderStatusHistoryUpdateWithWhereUniqueWithoutProviderInput | ProviderStatusHistoryUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: ProviderStatusHistoryUpdateManyWithWhereWithoutProviderInput | ProviderStatusHistoryUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: ProviderStatusHistoryScalarWhereInput | ProviderStatusHistoryScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<ServiceCreateWithoutProviderInput, ServiceUncheckedCreateWithoutProviderInput> | ServiceCreateWithoutProviderInput[] | ServiceUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutProviderInput | ServiceCreateOrConnectWithoutProviderInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutProviderInput | ServiceUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: ServiceCreateManyProviderInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutProviderInput | ServiceUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutProviderInput | ServiceUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type OperatingHourUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<OperatingHourCreateWithoutProviderInput, OperatingHourUncheckedCreateWithoutProviderInput> | OperatingHourCreateWithoutProviderInput[] | OperatingHourUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: OperatingHourCreateOrConnectWithoutProviderInput | OperatingHourCreateOrConnectWithoutProviderInput[]
    upsert?: OperatingHourUpsertWithWhereUniqueWithoutProviderInput | OperatingHourUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: OperatingHourCreateManyProviderInputEnvelope
    set?: OperatingHourWhereUniqueInput | OperatingHourWhereUniqueInput[]
    disconnect?: OperatingHourWhereUniqueInput | OperatingHourWhereUniqueInput[]
    delete?: OperatingHourWhereUniqueInput | OperatingHourWhereUniqueInput[]
    connect?: OperatingHourWhereUniqueInput | OperatingHourWhereUniqueInput[]
    update?: OperatingHourUpdateWithWhereUniqueWithoutProviderInput | OperatingHourUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: OperatingHourUpdateManyWithWhereWithoutProviderInput | OperatingHourUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: OperatingHourScalarWhereInput | OperatingHourScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<AppointmentCreateWithoutProviderInput, AppointmentUncheckedCreateWithoutProviderInput> | AppointmentCreateWithoutProviderInput[] | AppointmentUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutProviderInput | AppointmentCreateOrConnectWithoutProviderInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutProviderInput | AppointmentUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: AppointmentCreateManyProviderInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutProviderInput | AppointmentUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutProviderInput | AppointmentUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<DocumentCreateWithoutProviderInput, DocumentUncheckedCreateWithoutProviderInput> | DocumentCreateWithoutProviderInput[] | DocumentUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutProviderInput | DocumentCreateOrConnectWithoutProviderInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutProviderInput | DocumentUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: DocumentCreateManyProviderInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutProviderInput | DocumentUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutProviderInput | DocumentUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type BreakTimeUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<BreakTimeCreateWithoutProviderInput, BreakTimeUncheckedCreateWithoutProviderInput> | BreakTimeCreateWithoutProviderInput[] | BreakTimeUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: BreakTimeCreateOrConnectWithoutProviderInput | BreakTimeCreateOrConnectWithoutProviderInput[]
    upsert?: BreakTimeUpsertWithWhereUniqueWithoutProviderInput | BreakTimeUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: BreakTimeCreateManyProviderInputEnvelope
    set?: BreakTimeWhereUniqueInput | BreakTimeWhereUniqueInput[]
    disconnect?: BreakTimeWhereUniqueInput | BreakTimeWhereUniqueInput[]
    delete?: BreakTimeWhereUniqueInput | BreakTimeWhereUniqueInput[]
    connect?: BreakTimeWhereUniqueInput | BreakTimeWhereUniqueInput[]
    update?: BreakTimeUpdateWithWhereUniqueWithoutProviderInput | BreakTimeUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: BreakTimeUpdateManyWithWhereWithoutProviderInput | BreakTimeUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: BreakTimeScalarWhereInput | BreakTimeScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<NotificationCreateWithoutProviderInput, NotificationUncheckedCreateWithoutProviderInput> | NotificationCreateWithoutProviderInput[] | NotificationUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutProviderInput | NotificationCreateOrConnectWithoutProviderInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutProviderInput | NotificationUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: NotificationCreateManyProviderInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutProviderInput | NotificationUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutProviderInput | NotificationUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<ReviewCreateWithoutProviderInput, ReviewUncheckedCreateWithoutProviderInput> | ReviewCreateWithoutProviderInput[] | ReviewUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProviderInput | ReviewCreateOrConnectWithoutProviderInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutProviderInput | ReviewUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: ReviewCreateManyProviderInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutProviderInput | ReviewUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutProviderInput | ReviewUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ProviderStatusHistoryUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<ProviderStatusHistoryCreateWithoutProviderInput, ProviderStatusHistoryUncheckedCreateWithoutProviderInput> | ProviderStatusHistoryCreateWithoutProviderInput[] | ProviderStatusHistoryUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ProviderStatusHistoryCreateOrConnectWithoutProviderInput | ProviderStatusHistoryCreateOrConnectWithoutProviderInput[]
    upsert?: ProviderStatusHistoryUpsertWithWhereUniqueWithoutProviderInput | ProviderStatusHistoryUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: ProviderStatusHistoryCreateManyProviderInputEnvelope
    set?: ProviderStatusHistoryWhereUniqueInput | ProviderStatusHistoryWhereUniqueInput[]
    disconnect?: ProviderStatusHistoryWhereUniqueInput | ProviderStatusHistoryWhereUniqueInput[]
    delete?: ProviderStatusHistoryWhereUniqueInput | ProviderStatusHistoryWhereUniqueInput[]
    connect?: ProviderStatusHistoryWhereUniqueInput | ProviderStatusHistoryWhereUniqueInput[]
    update?: ProviderStatusHistoryUpdateWithWhereUniqueWithoutProviderInput | ProviderStatusHistoryUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: ProviderStatusHistoryUpdateManyWithWhereWithoutProviderInput | ProviderStatusHistoryUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: ProviderStatusHistoryScalarWhereInput | ProviderStatusHistoryScalarWhereInput[]
  }

  export type ProviderCreateNestedOneWithoutServicesInput = {
    create?: XOR<ProviderCreateWithoutServicesInput, ProviderUncheckedCreateWithoutServicesInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutServicesInput
    connect?: ProviderWhereUniqueInput
  }

  export type AppointmentServiceCreateNestedManyWithoutServiceInput = {
    create?: XOR<AppointmentServiceCreateWithoutServiceInput, AppointmentServiceUncheckedCreateWithoutServiceInput> | AppointmentServiceCreateWithoutServiceInput[] | AppointmentServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: AppointmentServiceCreateOrConnectWithoutServiceInput | AppointmentServiceCreateOrConnectWithoutServiceInput[]
    createMany?: AppointmentServiceCreateManyServiceInputEnvelope
    connect?: AppointmentServiceWhereUniqueInput | AppointmentServiceWhereUniqueInput[]
  }

  export type ServicePackageCreateNestedManyWithoutParentPackageInput = {
    create?: XOR<ServicePackageCreateWithoutParentPackageInput, ServicePackageUncheckedCreateWithoutParentPackageInput> | ServicePackageCreateWithoutParentPackageInput[] | ServicePackageUncheckedCreateWithoutParentPackageInput[]
    connectOrCreate?: ServicePackageCreateOrConnectWithoutParentPackageInput | ServicePackageCreateOrConnectWithoutParentPackageInput[]
    createMany?: ServicePackageCreateManyParentPackageInputEnvelope
    connect?: ServicePackageWhereUniqueInput | ServicePackageWhereUniqueInput[]
  }

  export type ServicePackageCreateNestedManyWithoutChildServiceInput = {
    create?: XOR<ServicePackageCreateWithoutChildServiceInput, ServicePackageUncheckedCreateWithoutChildServiceInput> | ServicePackageCreateWithoutChildServiceInput[] | ServicePackageUncheckedCreateWithoutChildServiceInput[]
    connectOrCreate?: ServicePackageCreateOrConnectWithoutChildServiceInput | ServicePackageCreateOrConnectWithoutChildServiceInput[]
    createMany?: ServicePackageCreateManyChildServiceInputEnvelope
    connect?: ServicePackageWhereUniqueInput | ServicePackageWhereUniqueInput[]
  }

  export type ServiceInsuranceCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceInsuranceCreateWithoutServiceInput, ServiceInsuranceUncheckedCreateWithoutServiceInput> | ServiceInsuranceCreateWithoutServiceInput[] | ServiceInsuranceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceInsuranceCreateOrConnectWithoutServiceInput | ServiceInsuranceCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceInsuranceCreateManyServiceInputEnvelope
    connect?: ServiceInsuranceWhereUniqueInput | ServiceInsuranceWhereUniqueInput[]
  }

  export type AppointmentServiceUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<AppointmentServiceCreateWithoutServiceInput, AppointmentServiceUncheckedCreateWithoutServiceInput> | AppointmentServiceCreateWithoutServiceInput[] | AppointmentServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: AppointmentServiceCreateOrConnectWithoutServiceInput | AppointmentServiceCreateOrConnectWithoutServiceInput[]
    createMany?: AppointmentServiceCreateManyServiceInputEnvelope
    connect?: AppointmentServiceWhereUniqueInput | AppointmentServiceWhereUniqueInput[]
  }

  export type ServicePackageUncheckedCreateNestedManyWithoutParentPackageInput = {
    create?: XOR<ServicePackageCreateWithoutParentPackageInput, ServicePackageUncheckedCreateWithoutParentPackageInput> | ServicePackageCreateWithoutParentPackageInput[] | ServicePackageUncheckedCreateWithoutParentPackageInput[]
    connectOrCreate?: ServicePackageCreateOrConnectWithoutParentPackageInput | ServicePackageCreateOrConnectWithoutParentPackageInput[]
    createMany?: ServicePackageCreateManyParentPackageInputEnvelope
    connect?: ServicePackageWhereUniqueInput | ServicePackageWhereUniqueInput[]
  }

  export type ServicePackageUncheckedCreateNestedManyWithoutChildServiceInput = {
    create?: XOR<ServicePackageCreateWithoutChildServiceInput, ServicePackageUncheckedCreateWithoutChildServiceInput> | ServicePackageCreateWithoutChildServiceInput[] | ServicePackageUncheckedCreateWithoutChildServiceInput[]
    connectOrCreate?: ServicePackageCreateOrConnectWithoutChildServiceInput | ServicePackageCreateOrConnectWithoutChildServiceInput[]
    createMany?: ServicePackageCreateManyChildServiceInputEnvelope
    connect?: ServicePackageWhereUniqueInput | ServicePackageWhereUniqueInput[]
  }

  export type ServiceInsuranceUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceInsuranceCreateWithoutServiceInput, ServiceInsuranceUncheckedCreateWithoutServiceInput> | ServiceInsuranceCreateWithoutServiceInput[] | ServiceInsuranceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceInsuranceCreateOrConnectWithoutServiceInput | ServiceInsuranceCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceInsuranceCreateManyServiceInputEnvelope
    connect?: ServiceInsuranceWhereUniqueInput | ServiceInsuranceWhereUniqueInput[]
  }

  export type EnumServiceTypeFieldUpdateOperationsInput = {
    set?: $Enums.ServiceType
  }

  export type EnumPricingModelFieldUpdateOperationsInput = {
    set?: $Enums.PricingModel
  }

  export type ProviderUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<ProviderCreateWithoutServicesInput, ProviderUncheckedCreateWithoutServicesInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutServicesInput
    upsert?: ProviderUpsertWithoutServicesInput
    connect?: ProviderWhereUniqueInput
    update?: XOR<XOR<ProviderUpdateToOneWithWhereWithoutServicesInput, ProviderUpdateWithoutServicesInput>, ProviderUncheckedUpdateWithoutServicesInput>
  }

  export type AppointmentServiceUpdateManyWithoutServiceNestedInput = {
    create?: XOR<AppointmentServiceCreateWithoutServiceInput, AppointmentServiceUncheckedCreateWithoutServiceInput> | AppointmentServiceCreateWithoutServiceInput[] | AppointmentServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: AppointmentServiceCreateOrConnectWithoutServiceInput | AppointmentServiceCreateOrConnectWithoutServiceInput[]
    upsert?: AppointmentServiceUpsertWithWhereUniqueWithoutServiceInput | AppointmentServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: AppointmentServiceCreateManyServiceInputEnvelope
    set?: AppointmentServiceWhereUniqueInput | AppointmentServiceWhereUniqueInput[]
    disconnect?: AppointmentServiceWhereUniqueInput | AppointmentServiceWhereUniqueInput[]
    delete?: AppointmentServiceWhereUniqueInput | AppointmentServiceWhereUniqueInput[]
    connect?: AppointmentServiceWhereUniqueInput | AppointmentServiceWhereUniqueInput[]
    update?: AppointmentServiceUpdateWithWhereUniqueWithoutServiceInput | AppointmentServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: AppointmentServiceUpdateManyWithWhereWithoutServiceInput | AppointmentServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: AppointmentServiceScalarWhereInput | AppointmentServiceScalarWhereInput[]
  }

  export type ServicePackageUpdateManyWithoutParentPackageNestedInput = {
    create?: XOR<ServicePackageCreateWithoutParentPackageInput, ServicePackageUncheckedCreateWithoutParentPackageInput> | ServicePackageCreateWithoutParentPackageInput[] | ServicePackageUncheckedCreateWithoutParentPackageInput[]
    connectOrCreate?: ServicePackageCreateOrConnectWithoutParentPackageInput | ServicePackageCreateOrConnectWithoutParentPackageInput[]
    upsert?: ServicePackageUpsertWithWhereUniqueWithoutParentPackageInput | ServicePackageUpsertWithWhereUniqueWithoutParentPackageInput[]
    createMany?: ServicePackageCreateManyParentPackageInputEnvelope
    set?: ServicePackageWhereUniqueInput | ServicePackageWhereUniqueInput[]
    disconnect?: ServicePackageWhereUniqueInput | ServicePackageWhereUniqueInput[]
    delete?: ServicePackageWhereUniqueInput | ServicePackageWhereUniqueInput[]
    connect?: ServicePackageWhereUniqueInput | ServicePackageWhereUniqueInput[]
    update?: ServicePackageUpdateWithWhereUniqueWithoutParentPackageInput | ServicePackageUpdateWithWhereUniqueWithoutParentPackageInput[]
    updateMany?: ServicePackageUpdateManyWithWhereWithoutParentPackageInput | ServicePackageUpdateManyWithWhereWithoutParentPackageInput[]
    deleteMany?: ServicePackageScalarWhereInput | ServicePackageScalarWhereInput[]
  }

  export type ServicePackageUpdateManyWithoutChildServiceNestedInput = {
    create?: XOR<ServicePackageCreateWithoutChildServiceInput, ServicePackageUncheckedCreateWithoutChildServiceInput> | ServicePackageCreateWithoutChildServiceInput[] | ServicePackageUncheckedCreateWithoutChildServiceInput[]
    connectOrCreate?: ServicePackageCreateOrConnectWithoutChildServiceInput | ServicePackageCreateOrConnectWithoutChildServiceInput[]
    upsert?: ServicePackageUpsertWithWhereUniqueWithoutChildServiceInput | ServicePackageUpsertWithWhereUniqueWithoutChildServiceInput[]
    createMany?: ServicePackageCreateManyChildServiceInputEnvelope
    set?: ServicePackageWhereUniqueInput | ServicePackageWhereUniqueInput[]
    disconnect?: ServicePackageWhereUniqueInput | ServicePackageWhereUniqueInput[]
    delete?: ServicePackageWhereUniqueInput | ServicePackageWhereUniqueInput[]
    connect?: ServicePackageWhereUniqueInput | ServicePackageWhereUniqueInput[]
    update?: ServicePackageUpdateWithWhereUniqueWithoutChildServiceInput | ServicePackageUpdateWithWhereUniqueWithoutChildServiceInput[]
    updateMany?: ServicePackageUpdateManyWithWhereWithoutChildServiceInput | ServicePackageUpdateManyWithWhereWithoutChildServiceInput[]
    deleteMany?: ServicePackageScalarWhereInput | ServicePackageScalarWhereInput[]
  }

  export type ServiceInsuranceUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceInsuranceCreateWithoutServiceInput, ServiceInsuranceUncheckedCreateWithoutServiceInput> | ServiceInsuranceCreateWithoutServiceInput[] | ServiceInsuranceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceInsuranceCreateOrConnectWithoutServiceInput | ServiceInsuranceCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceInsuranceUpsertWithWhereUniqueWithoutServiceInput | ServiceInsuranceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceInsuranceCreateManyServiceInputEnvelope
    set?: ServiceInsuranceWhereUniqueInput | ServiceInsuranceWhereUniqueInput[]
    disconnect?: ServiceInsuranceWhereUniqueInput | ServiceInsuranceWhereUniqueInput[]
    delete?: ServiceInsuranceWhereUniqueInput | ServiceInsuranceWhereUniqueInput[]
    connect?: ServiceInsuranceWhereUniqueInput | ServiceInsuranceWhereUniqueInput[]
    update?: ServiceInsuranceUpdateWithWhereUniqueWithoutServiceInput | ServiceInsuranceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceInsuranceUpdateManyWithWhereWithoutServiceInput | ServiceInsuranceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceInsuranceScalarWhereInput | ServiceInsuranceScalarWhereInput[]
  }

  export type AppointmentServiceUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<AppointmentServiceCreateWithoutServiceInput, AppointmentServiceUncheckedCreateWithoutServiceInput> | AppointmentServiceCreateWithoutServiceInput[] | AppointmentServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: AppointmentServiceCreateOrConnectWithoutServiceInput | AppointmentServiceCreateOrConnectWithoutServiceInput[]
    upsert?: AppointmentServiceUpsertWithWhereUniqueWithoutServiceInput | AppointmentServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: AppointmentServiceCreateManyServiceInputEnvelope
    set?: AppointmentServiceWhereUniqueInput | AppointmentServiceWhereUniqueInput[]
    disconnect?: AppointmentServiceWhereUniqueInput | AppointmentServiceWhereUniqueInput[]
    delete?: AppointmentServiceWhereUniqueInput | AppointmentServiceWhereUniqueInput[]
    connect?: AppointmentServiceWhereUniqueInput | AppointmentServiceWhereUniqueInput[]
    update?: AppointmentServiceUpdateWithWhereUniqueWithoutServiceInput | AppointmentServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: AppointmentServiceUpdateManyWithWhereWithoutServiceInput | AppointmentServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: AppointmentServiceScalarWhereInput | AppointmentServiceScalarWhereInput[]
  }

  export type ServicePackageUncheckedUpdateManyWithoutParentPackageNestedInput = {
    create?: XOR<ServicePackageCreateWithoutParentPackageInput, ServicePackageUncheckedCreateWithoutParentPackageInput> | ServicePackageCreateWithoutParentPackageInput[] | ServicePackageUncheckedCreateWithoutParentPackageInput[]
    connectOrCreate?: ServicePackageCreateOrConnectWithoutParentPackageInput | ServicePackageCreateOrConnectWithoutParentPackageInput[]
    upsert?: ServicePackageUpsertWithWhereUniqueWithoutParentPackageInput | ServicePackageUpsertWithWhereUniqueWithoutParentPackageInput[]
    createMany?: ServicePackageCreateManyParentPackageInputEnvelope
    set?: ServicePackageWhereUniqueInput | ServicePackageWhereUniqueInput[]
    disconnect?: ServicePackageWhereUniqueInput | ServicePackageWhereUniqueInput[]
    delete?: ServicePackageWhereUniqueInput | ServicePackageWhereUniqueInput[]
    connect?: ServicePackageWhereUniqueInput | ServicePackageWhereUniqueInput[]
    update?: ServicePackageUpdateWithWhereUniqueWithoutParentPackageInput | ServicePackageUpdateWithWhereUniqueWithoutParentPackageInput[]
    updateMany?: ServicePackageUpdateManyWithWhereWithoutParentPackageInput | ServicePackageUpdateManyWithWhereWithoutParentPackageInput[]
    deleteMany?: ServicePackageScalarWhereInput | ServicePackageScalarWhereInput[]
  }

  export type ServicePackageUncheckedUpdateManyWithoutChildServiceNestedInput = {
    create?: XOR<ServicePackageCreateWithoutChildServiceInput, ServicePackageUncheckedCreateWithoutChildServiceInput> | ServicePackageCreateWithoutChildServiceInput[] | ServicePackageUncheckedCreateWithoutChildServiceInput[]
    connectOrCreate?: ServicePackageCreateOrConnectWithoutChildServiceInput | ServicePackageCreateOrConnectWithoutChildServiceInput[]
    upsert?: ServicePackageUpsertWithWhereUniqueWithoutChildServiceInput | ServicePackageUpsertWithWhereUniqueWithoutChildServiceInput[]
    createMany?: ServicePackageCreateManyChildServiceInputEnvelope
    set?: ServicePackageWhereUniqueInput | ServicePackageWhereUniqueInput[]
    disconnect?: ServicePackageWhereUniqueInput | ServicePackageWhereUniqueInput[]
    delete?: ServicePackageWhereUniqueInput | ServicePackageWhereUniqueInput[]
    connect?: ServicePackageWhereUniqueInput | ServicePackageWhereUniqueInput[]
    update?: ServicePackageUpdateWithWhereUniqueWithoutChildServiceInput | ServicePackageUpdateWithWhereUniqueWithoutChildServiceInput[]
    updateMany?: ServicePackageUpdateManyWithWhereWithoutChildServiceInput | ServicePackageUpdateManyWithWhereWithoutChildServiceInput[]
    deleteMany?: ServicePackageScalarWhereInput | ServicePackageScalarWhereInput[]
  }

  export type ServiceInsuranceUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceInsuranceCreateWithoutServiceInput, ServiceInsuranceUncheckedCreateWithoutServiceInput> | ServiceInsuranceCreateWithoutServiceInput[] | ServiceInsuranceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceInsuranceCreateOrConnectWithoutServiceInput | ServiceInsuranceCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceInsuranceUpsertWithWhereUniqueWithoutServiceInput | ServiceInsuranceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceInsuranceCreateManyServiceInputEnvelope
    set?: ServiceInsuranceWhereUniqueInput | ServiceInsuranceWhereUniqueInput[]
    disconnect?: ServiceInsuranceWhereUniqueInput | ServiceInsuranceWhereUniqueInput[]
    delete?: ServiceInsuranceWhereUniqueInput | ServiceInsuranceWhereUniqueInput[]
    connect?: ServiceInsuranceWhereUniqueInput | ServiceInsuranceWhereUniqueInput[]
    update?: ServiceInsuranceUpdateWithWhereUniqueWithoutServiceInput | ServiceInsuranceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceInsuranceUpdateManyWithWhereWithoutServiceInput | ServiceInsuranceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceInsuranceScalarWhereInput | ServiceInsuranceScalarWhereInput[]
  }

  export type ServiceCreateNestedOneWithoutIncludedServicesInput = {
    create?: XOR<ServiceCreateWithoutIncludedServicesInput, ServiceUncheckedCreateWithoutIncludedServicesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutIncludedServicesInput
    connect?: ServiceWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutPartOfPackagesInput = {
    create?: XOR<ServiceCreateWithoutPartOfPackagesInput, ServiceUncheckedCreateWithoutPartOfPackagesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutPartOfPackagesInput
    connect?: ServiceWhereUniqueInput
  }

  export type ServiceUpdateOneRequiredWithoutIncludedServicesNestedInput = {
    create?: XOR<ServiceCreateWithoutIncludedServicesInput, ServiceUncheckedCreateWithoutIncludedServicesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutIncludedServicesInput
    upsert?: ServiceUpsertWithoutIncludedServicesInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutIncludedServicesInput, ServiceUpdateWithoutIncludedServicesInput>, ServiceUncheckedUpdateWithoutIncludedServicesInput>
  }

  export type ServiceUpdateOneRequiredWithoutPartOfPackagesNestedInput = {
    create?: XOR<ServiceCreateWithoutPartOfPackagesInput, ServiceUncheckedCreateWithoutPartOfPackagesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutPartOfPackagesInput
    upsert?: ServiceUpsertWithoutPartOfPackagesInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutPartOfPackagesInput, ServiceUpdateWithoutPartOfPackagesInput>, ServiceUncheckedUpdateWithoutPartOfPackagesInput>
  }

  export type ServiceInsuranceCreateNestedManyWithoutInsuranceProviderInput = {
    create?: XOR<ServiceInsuranceCreateWithoutInsuranceProviderInput, ServiceInsuranceUncheckedCreateWithoutInsuranceProviderInput> | ServiceInsuranceCreateWithoutInsuranceProviderInput[] | ServiceInsuranceUncheckedCreateWithoutInsuranceProviderInput[]
    connectOrCreate?: ServiceInsuranceCreateOrConnectWithoutInsuranceProviderInput | ServiceInsuranceCreateOrConnectWithoutInsuranceProviderInput[]
    createMany?: ServiceInsuranceCreateManyInsuranceProviderInputEnvelope
    connect?: ServiceInsuranceWhereUniqueInput | ServiceInsuranceWhereUniqueInput[]
  }

  export type ServiceInsuranceUncheckedCreateNestedManyWithoutInsuranceProviderInput = {
    create?: XOR<ServiceInsuranceCreateWithoutInsuranceProviderInput, ServiceInsuranceUncheckedCreateWithoutInsuranceProviderInput> | ServiceInsuranceCreateWithoutInsuranceProviderInput[] | ServiceInsuranceUncheckedCreateWithoutInsuranceProviderInput[]
    connectOrCreate?: ServiceInsuranceCreateOrConnectWithoutInsuranceProviderInput | ServiceInsuranceCreateOrConnectWithoutInsuranceProviderInput[]
    createMany?: ServiceInsuranceCreateManyInsuranceProviderInputEnvelope
    connect?: ServiceInsuranceWhereUniqueInput | ServiceInsuranceWhereUniqueInput[]
  }

  export type ServiceInsuranceUpdateManyWithoutInsuranceProviderNestedInput = {
    create?: XOR<ServiceInsuranceCreateWithoutInsuranceProviderInput, ServiceInsuranceUncheckedCreateWithoutInsuranceProviderInput> | ServiceInsuranceCreateWithoutInsuranceProviderInput[] | ServiceInsuranceUncheckedCreateWithoutInsuranceProviderInput[]
    connectOrCreate?: ServiceInsuranceCreateOrConnectWithoutInsuranceProviderInput | ServiceInsuranceCreateOrConnectWithoutInsuranceProviderInput[]
    upsert?: ServiceInsuranceUpsertWithWhereUniqueWithoutInsuranceProviderInput | ServiceInsuranceUpsertWithWhereUniqueWithoutInsuranceProviderInput[]
    createMany?: ServiceInsuranceCreateManyInsuranceProviderInputEnvelope
    set?: ServiceInsuranceWhereUniqueInput | ServiceInsuranceWhereUniqueInput[]
    disconnect?: ServiceInsuranceWhereUniqueInput | ServiceInsuranceWhereUniqueInput[]
    delete?: ServiceInsuranceWhereUniqueInput | ServiceInsuranceWhereUniqueInput[]
    connect?: ServiceInsuranceWhereUniqueInput | ServiceInsuranceWhereUniqueInput[]
    update?: ServiceInsuranceUpdateWithWhereUniqueWithoutInsuranceProviderInput | ServiceInsuranceUpdateWithWhereUniqueWithoutInsuranceProviderInput[]
    updateMany?: ServiceInsuranceUpdateManyWithWhereWithoutInsuranceProviderInput | ServiceInsuranceUpdateManyWithWhereWithoutInsuranceProviderInput[]
    deleteMany?: ServiceInsuranceScalarWhereInput | ServiceInsuranceScalarWhereInput[]
  }

  export type ServiceInsuranceUncheckedUpdateManyWithoutInsuranceProviderNestedInput = {
    create?: XOR<ServiceInsuranceCreateWithoutInsuranceProviderInput, ServiceInsuranceUncheckedCreateWithoutInsuranceProviderInput> | ServiceInsuranceCreateWithoutInsuranceProviderInput[] | ServiceInsuranceUncheckedCreateWithoutInsuranceProviderInput[]
    connectOrCreate?: ServiceInsuranceCreateOrConnectWithoutInsuranceProviderInput | ServiceInsuranceCreateOrConnectWithoutInsuranceProviderInput[]
    upsert?: ServiceInsuranceUpsertWithWhereUniqueWithoutInsuranceProviderInput | ServiceInsuranceUpsertWithWhereUniqueWithoutInsuranceProviderInput[]
    createMany?: ServiceInsuranceCreateManyInsuranceProviderInputEnvelope
    set?: ServiceInsuranceWhereUniqueInput | ServiceInsuranceWhereUniqueInput[]
    disconnect?: ServiceInsuranceWhereUniqueInput | ServiceInsuranceWhereUniqueInput[]
    delete?: ServiceInsuranceWhereUniqueInput | ServiceInsuranceWhereUniqueInput[]
    connect?: ServiceInsuranceWhereUniqueInput | ServiceInsuranceWhereUniqueInput[]
    update?: ServiceInsuranceUpdateWithWhereUniqueWithoutInsuranceProviderInput | ServiceInsuranceUpdateWithWhereUniqueWithoutInsuranceProviderInput[]
    updateMany?: ServiceInsuranceUpdateManyWithWhereWithoutInsuranceProviderInput | ServiceInsuranceUpdateManyWithWhereWithoutInsuranceProviderInput[]
    deleteMany?: ServiceInsuranceScalarWhereInput | ServiceInsuranceScalarWhereInput[]
  }

  export type ServiceCreateNestedOneWithoutAcceptedInsurancesInput = {
    create?: XOR<ServiceCreateWithoutAcceptedInsurancesInput, ServiceUncheckedCreateWithoutAcceptedInsurancesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutAcceptedInsurancesInput
    connect?: ServiceWhereUniqueInput
  }

  export type InsuranceProviderCreateNestedOneWithoutServicesInput = {
    create?: XOR<InsuranceProviderCreateWithoutServicesInput, InsuranceProviderUncheckedCreateWithoutServicesInput>
    connectOrCreate?: InsuranceProviderCreateOrConnectWithoutServicesInput
    connect?: InsuranceProviderWhereUniqueInput
  }

  export type ServiceUpdateOneRequiredWithoutAcceptedInsurancesNestedInput = {
    create?: XOR<ServiceCreateWithoutAcceptedInsurancesInput, ServiceUncheckedCreateWithoutAcceptedInsurancesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutAcceptedInsurancesInput
    upsert?: ServiceUpsertWithoutAcceptedInsurancesInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutAcceptedInsurancesInput, ServiceUpdateWithoutAcceptedInsurancesInput>, ServiceUncheckedUpdateWithoutAcceptedInsurancesInput>
  }

  export type InsuranceProviderUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<InsuranceProviderCreateWithoutServicesInput, InsuranceProviderUncheckedCreateWithoutServicesInput>
    connectOrCreate?: InsuranceProviderCreateOrConnectWithoutServicesInput
    upsert?: InsuranceProviderUpsertWithoutServicesInput
    connect?: InsuranceProviderWhereUniqueInput
    update?: XOR<XOR<InsuranceProviderUpdateToOneWithWhereWithoutServicesInput, InsuranceProviderUpdateWithoutServicesInput>, InsuranceProviderUncheckedUpdateWithoutServicesInput>
  }

  export type ProviderCreateNestedOneWithoutOperatingHoursInput = {
    create?: XOR<ProviderCreateWithoutOperatingHoursInput, ProviderUncheckedCreateWithoutOperatingHoursInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutOperatingHoursInput
    connect?: ProviderWhereUniqueInput
  }

  export type ProviderUpdateOneRequiredWithoutOperatingHoursNestedInput = {
    create?: XOR<ProviderCreateWithoutOperatingHoursInput, ProviderUncheckedCreateWithoutOperatingHoursInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutOperatingHoursInput
    upsert?: ProviderUpsertWithoutOperatingHoursInput
    connect?: ProviderWhereUniqueInput
    update?: XOR<XOR<ProviderUpdateToOneWithWhereWithoutOperatingHoursInput, ProviderUpdateWithoutOperatingHoursInput>, ProviderUncheckedUpdateWithoutOperatingHoursInput>
  }

  export type ProviderCreateNestedOneWithoutBreakTimesInput = {
    create?: XOR<ProviderCreateWithoutBreakTimesInput, ProviderUncheckedCreateWithoutBreakTimesInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutBreakTimesInput
    connect?: ProviderWhereUniqueInput
  }

  export type ProviderUpdateOneRequiredWithoutBreakTimesNestedInput = {
    create?: XOR<ProviderCreateWithoutBreakTimesInput, ProviderUncheckedCreateWithoutBreakTimesInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutBreakTimesInput
    upsert?: ProviderUpsertWithoutBreakTimesInput
    connect?: ProviderWhereUniqueInput
    update?: XOR<XOR<ProviderUpdateToOneWithWhereWithoutBreakTimesInput, ProviderUpdateWithoutBreakTimesInput>, ProviderUncheckedUpdateWithoutBreakTimesInput>
  }

  export type UserCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<UserCreateWithoutAppointmentsInput, UserUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAppointmentsInput
    connect?: UserWhereUniqueInput
  }

  export type ProviderCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<ProviderCreateWithoutAppointmentsInput, ProviderUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutAppointmentsInput
    connect?: ProviderWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCancelledAppointmentsInput = {
    create?: XOR<UserCreateWithoutCancelledAppointmentsInput, UserUncheckedCreateWithoutCancelledAppointmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCancelledAppointmentsInput
    connect?: UserWhereUniqueInput
  }

  export type AppointmentServiceCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<AppointmentServiceCreateWithoutAppointmentInput, AppointmentServiceUncheckedCreateWithoutAppointmentInput> | AppointmentServiceCreateWithoutAppointmentInput[] | AppointmentServiceUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: AppointmentServiceCreateOrConnectWithoutAppointmentInput | AppointmentServiceCreateOrConnectWithoutAppointmentInput[]
    createMany?: AppointmentServiceCreateManyAppointmentInputEnvelope
    connect?: AppointmentServiceWhereUniqueInput | AppointmentServiceWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<NotificationCreateWithoutAppointmentInput, NotificationUncheckedCreateWithoutAppointmentInput> | NotificationCreateWithoutAppointmentInput[] | NotificationUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutAppointmentInput | NotificationCreateOrConnectWithoutAppointmentInput[]
    createMany?: NotificationCreateManyAppointmentInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ReviewCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<ReviewCreateWithoutAppointmentInput, ReviewUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutAppointmentInput
    connect?: ReviewWhereUniqueInput
  }

  export type AppointmentServiceUncheckedCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<AppointmentServiceCreateWithoutAppointmentInput, AppointmentServiceUncheckedCreateWithoutAppointmentInput> | AppointmentServiceCreateWithoutAppointmentInput[] | AppointmentServiceUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: AppointmentServiceCreateOrConnectWithoutAppointmentInput | AppointmentServiceCreateOrConnectWithoutAppointmentInput[]
    createMany?: AppointmentServiceCreateManyAppointmentInputEnvelope
    connect?: AppointmentServiceWhereUniqueInput | AppointmentServiceWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<NotificationCreateWithoutAppointmentInput, NotificationUncheckedCreateWithoutAppointmentInput> | NotificationCreateWithoutAppointmentInput[] | NotificationUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutAppointmentInput | NotificationCreateOrConnectWithoutAppointmentInput[]
    createMany?: NotificationCreateManyAppointmentInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<ReviewCreateWithoutAppointmentInput, ReviewUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutAppointmentInput
    connect?: ReviewWhereUniqueInput
  }

  export type EnumAppointmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.AppointmentStatus
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<UserCreateWithoutAppointmentsInput, UserUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAppointmentsInput
    upsert?: UserUpsertWithoutAppointmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAppointmentsInput, UserUpdateWithoutAppointmentsInput>, UserUncheckedUpdateWithoutAppointmentsInput>
  }

  export type ProviderUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<ProviderCreateWithoutAppointmentsInput, ProviderUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutAppointmentsInput
    upsert?: ProviderUpsertWithoutAppointmentsInput
    connect?: ProviderWhereUniqueInput
    update?: XOR<XOR<ProviderUpdateToOneWithWhereWithoutAppointmentsInput, ProviderUpdateWithoutAppointmentsInput>, ProviderUncheckedUpdateWithoutAppointmentsInput>
  }

  export type UserUpdateOneWithoutCancelledAppointmentsNestedInput = {
    create?: XOR<UserCreateWithoutCancelledAppointmentsInput, UserUncheckedCreateWithoutCancelledAppointmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCancelledAppointmentsInput
    upsert?: UserUpsertWithoutCancelledAppointmentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCancelledAppointmentsInput, UserUpdateWithoutCancelledAppointmentsInput>, UserUncheckedUpdateWithoutCancelledAppointmentsInput>
  }

  export type AppointmentServiceUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<AppointmentServiceCreateWithoutAppointmentInput, AppointmentServiceUncheckedCreateWithoutAppointmentInput> | AppointmentServiceCreateWithoutAppointmentInput[] | AppointmentServiceUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: AppointmentServiceCreateOrConnectWithoutAppointmentInput | AppointmentServiceCreateOrConnectWithoutAppointmentInput[]
    upsert?: AppointmentServiceUpsertWithWhereUniqueWithoutAppointmentInput | AppointmentServiceUpsertWithWhereUniqueWithoutAppointmentInput[]
    createMany?: AppointmentServiceCreateManyAppointmentInputEnvelope
    set?: AppointmentServiceWhereUniqueInput | AppointmentServiceWhereUniqueInput[]
    disconnect?: AppointmentServiceWhereUniqueInput | AppointmentServiceWhereUniqueInput[]
    delete?: AppointmentServiceWhereUniqueInput | AppointmentServiceWhereUniqueInput[]
    connect?: AppointmentServiceWhereUniqueInput | AppointmentServiceWhereUniqueInput[]
    update?: AppointmentServiceUpdateWithWhereUniqueWithoutAppointmentInput | AppointmentServiceUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: AppointmentServiceUpdateManyWithWhereWithoutAppointmentInput | AppointmentServiceUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: AppointmentServiceScalarWhereInput | AppointmentServiceScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<NotificationCreateWithoutAppointmentInput, NotificationUncheckedCreateWithoutAppointmentInput> | NotificationCreateWithoutAppointmentInput[] | NotificationUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutAppointmentInput | NotificationCreateOrConnectWithoutAppointmentInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutAppointmentInput | NotificationUpsertWithWhereUniqueWithoutAppointmentInput[]
    createMany?: NotificationCreateManyAppointmentInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutAppointmentInput | NotificationUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutAppointmentInput | NotificationUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ReviewUpdateOneWithoutAppointmentNestedInput = {
    create?: XOR<ReviewCreateWithoutAppointmentInput, ReviewUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutAppointmentInput
    upsert?: ReviewUpsertWithoutAppointmentInput
    disconnect?: ReviewWhereInput | boolean
    delete?: ReviewWhereInput | boolean
    connect?: ReviewWhereUniqueInput
    update?: XOR<XOR<ReviewUpdateToOneWithWhereWithoutAppointmentInput, ReviewUpdateWithoutAppointmentInput>, ReviewUncheckedUpdateWithoutAppointmentInput>
  }

  export type AppointmentServiceUncheckedUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<AppointmentServiceCreateWithoutAppointmentInput, AppointmentServiceUncheckedCreateWithoutAppointmentInput> | AppointmentServiceCreateWithoutAppointmentInput[] | AppointmentServiceUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: AppointmentServiceCreateOrConnectWithoutAppointmentInput | AppointmentServiceCreateOrConnectWithoutAppointmentInput[]
    upsert?: AppointmentServiceUpsertWithWhereUniqueWithoutAppointmentInput | AppointmentServiceUpsertWithWhereUniqueWithoutAppointmentInput[]
    createMany?: AppointmentServiceCreateManyAppointmentInputEnvelope
    set?: AppointmentServiceWhereUniqueInput | AppointmentServiceWhereUniqueInput[]
    disconnect?: AppointmentServiceWhereUniqueInput | AppointmentServiceWhereUniqueInput[]
    delete?: AppointmentServiceWhereUniqueInput | AppointmentServiceWhereUniqueInput[]
    connect?: AppointmentServiceWhereUniqueInput | AppointmentServiceWhereUniqueInput[]
    update?: AppointmentServiceUpdateWithWhereUniqueWithoutAppointmentInput | AppointmentServiceUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: AppointmentServiceUpdateManyWithWhereWithoutAppointmentInput | AppointmentServiceUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: AppointmentServiceScalarWhereInput | AppointmentServiceScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<NotificationCreateWithoutAppointmentInput, NotificationUncheckedCreateWithoutAppointmentInput> | NotificationCreateWithoutAppointmentInput[] | NotificationUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutAppointmentInput | NotificationCreateOrConnectWithoutAppointmentInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutAppointmentInput | NotificationUpsertWithWhereUniqueWithoutAppointmentInput[]
    createMany?: NotificationCreateManyAppointmentInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutAppointmentInput | NotificationUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutAppointmentInput | NotificationUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateOneWithoutAppointmentNestedInput = {
    create?: XOR<ReviewCreateWithoutAppointmentInput, ReviewUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutAppointmentInput
    upsert?: ReviewUpsertWithoutAppointmentInput
    disconnect?: ReviewWhereInput | boolean
    delete?: ReviewWhereInput | boolean
    connect?: ReviewWhereUniqueInput
    update?: XOR<XOR<ReviewUpdateToOneWithWhereWithoutAppointmentInput, ReviewUpdateWithoutAppointmentInput>, ReviewUncheckedUpdateWithoutAppointmentInput>
  }

  export type AppointmentCreateNestedOneWithoutServicesInput = {
    create?: XOR<AppointmentCreateWithoutServicesInput, AppointmentUncheckedCreateWithoutServicesInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutServicesInput
    connect?: AppointmentWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<ServiceCreateWithoutAppointmentsInput, ServiceUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutAppointmentsInput
    connect?: ServiceWhereUniqueInput
  }

  export type AppointmentUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<AppointmentCreateWithoutServicesInput, AppointmentUncheckedCreateWithoutServicesInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutServicesInput
    upsert?: AppointmentUpsertWithoutServicesInput
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutServicesInput, AppointmentUpdateWithoutServicesInput>, AppointmentUncheckedUpdateWithoutServicesInput>
  }

  export type ServiceUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<ServiceCreateWithoutAppointmentsInput, ServiceUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutAppointmentsInput
    upsert?: ServiceUpsertWithoutAppointmentsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutAppointmentsInput, ServiceUpdateWithoutAppointmentsInput>, ServiceUncheckedUpdateWithoutAppointmentsInput>
  }

  export type UserCreateNestedOneWithoutVerifiedDocumentsInput = {
    create?: XOR<UserCreateWithoutVerifiedDocumentsInput, UserUncheckedCreateWithoutVerifiedDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerifiedDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type ProviderCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<ProviderCreateWithoutDocumentsInput, ProviderUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutDocumentsInput
    connect?: ProviderWhereUniqueInput
  }

  export type EnumDocumentVerificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.DocumentVerificationStatus
  }

  export type UserUpdateOneWithoutVerifiedDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutVerifiedDocumentsInput, UserUncheckedCreateWithoutVerifiedDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerifiedDocumentsInput
    upsert?: UserUpsertWithoutVerifiedDocumentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVerifiedDocumentsInput, UserUpdateWithoutVerifiedDocumentsInput>, UserUncheckedUpdateWithoutVerifiedDocumentsInput>
  }

  export type ProviderUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<ProviderCreateWithoutDocumentsInput, ProviderUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutDocumentsInput
    upsert?: ProviderUpsertWithoutDocumentsInput
    connect?: ProviderWhereUniqueInput
    update?: XOR<XOR<ProviderUpdateToOneWithWhereWithoutDocumentsInput, ProviderUpdateWithoutDocumentsInput>, ProviderUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type AppointmentCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<AppointmentCreateWithoutNotificationsInput, AppointmentUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutNotificationsInput
    connect?: AppointmentWhereUniqueInput
  }

  export type ProviderCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<ProviderCreateWithoutNotificationsInput, ProviderUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutNotificationsInput
    connect?: ProviderWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type AppointmentUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<AppointmentCreateWithoutNotificationsInput, AppointmentUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutNotificationsInput
    upsert?: AppointmentUpsertWithoutNotificationsInput
    disconnect?: AppointmentWhereInput | boolean
    delete?: AppointmentWhereInput | boolean
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutNotificationsInput, AppointmentUpdateWithoutNotificationsInput>, AppointmentUncheckedUpdateWithoutNotificationsInput>
  }

  export type ProviderUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<ProviderCreateWithoutNotificationsInput, ProviderUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutNotificationsInput
    upsert?: ProviderUpsertWithoutNotificationsInput
    disconnect?: ProviderWhereInput | boolean
    delete?: ProviderWhereInput | boolean
    connect?: ProviderWhereUniqueInput
    update?: XOR<XOR<ProviderUpdateToOneWithWhereWithoutNotificationsInput, ProviderUpdateWithoutNotificationsInput>, ProviderUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutConversationsAsUser1Input = {
    create?: XOR<UserCreateWithoutConversationsAsUser1Input, UserUncheckedCreateWithoutConversationsAsUser1Input>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsAsUser1Input
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutConversationsAsUser2Input = {
    create?: XOR<UserCreateWithoutConversationsAsUser2Input, UserUncheckedCreateWithoutConversationsAsUser2Input>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsAsUser2Input
    connect?: UserWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutConversationsAsUser1NestedInput = {
    create?: XOR<UserCreateWithoutConversationsAsUser1Input, UserUncheckedCreateWithoutConversationsAsUser1Input>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsAsUser1Input
    upsert?: UserUpsertWithoutConversationsAsUser1Input
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConversationsAsUser1Input, UserUpdateWithoutConversationsAsUser1Input>, UserUncheckedUpdateWithoutConversationsAsUser1Input>
  }

  export type UserUpdateOneRequiredWithoutConversationsAsUser2NestedInput = {
    create?: XOR<UserCreateWithoutConversationsAsUser2Input, UserUncheckedCreateWithoutConversationsAsUser2Input>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsAsUser2Input
    upsert?: UserUpsertWithoutConversationsAsUser2Input
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConversationsAsUser2Input, UserUpdateWithoutConversationsAsUser2Input>, UserUncheckedUpdateWithoutConversationsAsUser2Input>
  }

  export type MessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumMessageStatusFieldUpdateOperationsInput = {
    set?: $Enums.MessageStatus
  }

  export type ConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    upsert?: ConversationUpsertWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutMessagesInput, ConversationUpdateWithoutMessagesInput>, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutSentMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    upsert?: UserUpsertWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentMessagesInput, UserUpdateWithoutSentMessagesInput>, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type AppointmentCreateNestedOneWithoutReviewInput = {
    create?: XOR<AppointmentCreateWithoutReviewInput, AppointmentUncheckedCreateWithoutReviewInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutReviewInput
    connect?: AppointmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type ProviderCreateNestedOneWithoutReviewsInput = {
    create?: XOR<ProviderCreateWithoutReviewsInput, ProviderUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutReviewsInput
    connect?: ProviderWhereUniqueInput
  }

  export type ReviewLikeCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReviewLikeCreateWithoutReviewInput, ReviewLikeUncheckedCreateWithoutReviewInput> | ReviewLikeCreateWithoutReviewInput[] | ReviewLikeUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewLikeCreateOrConnectWithoutReviewInput | ReviewLikeCreateOrConnectWithoutReviewInput[]
    createMany?: ReviewLikeCreateManyReviewInputEnvelope
    connect?: ReviewLikeWhereUniqueInput | ReviewLikeWhereUniqueInput[]
  }

  export type ReviewLikeUncheckedCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReviewLikeCreateWithoutReviewInput, ReviewLikeUncheckedCreateWithoutReviewInput> | ReviewLikeCreateWithoutReviewInput[] | ReviewLikeUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewLikeCreateOrConnectWithoutReviewInput | ReviewLikeCreateOrConnectWithoutReviewInput[]
    createMany?: ReviewLikeCreateManyReviewInputEnvelope
    connect?: ReviewLikeWhereUniqueInput | ReviewLikeWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AppointmentUpdateOneRequiredWithoutReviewNestedInput = {
    create?: XOR<AppointmentCreateWithoutReviewInput, AppointmentUncheckedCreateWithoutReviewInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutReviewInput
    upsert?: AppointmentUpsertWithoutReviewInput
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutReviewInput, AppointmentUpdateWithoutReviewInput>, AppointmentUncheckedUpdateWithoutReviewInput>
  }

  export type UserUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    upsert?: UserUpsertWithoutReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsInput, UserUpdateWithoutReviewsInput>, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type ProviderUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<ProviderCreateWithoutReviewsInput, ProviderUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutReviewsInput
    upsert?: ProviderUpsertWithoutReviewsInput
    connect?: ProviderWhereUniqueInput
    update?: XOR<XOR<ProviderUpdateToOneWithWhereWithoutReviewsInput, ProviderUpdateWithoutReviewsInput>, ProviderUncheckedUpdateWithoutReviewsInput>
  }

  export type ReviewLikeUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReviewLikeCreateWithoutReviewInput, ReviewLikeUncheckedCreateWithoutReviewInput> | ReviewLikeCreateWithoutReviewInput[] | ReviewLikeUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewLikeCreateOrConnectWithoutReviewInput | ReviewLikeCreateOrConnectWithoutReviewInput[]
    upsert?: ReviewLikeUpsertWithWhereUniqueWithoutReviewInput | ReviewLikeUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReviewLikeCreateManyReviewInputEnvelope
    set?: ReviewLikeWhereUniqueInput | ReviewLikeWhereUniqueInput[]
    disconnect?: ReviewLikeWhereUniqueInput | ReviewLikeWhereUniqueInput[]
    delete?: ReviewLikeWhereUniqueInput | ReviewLikeWhereUniqueInput[]
    connect?: ReviewLikeWhereUniqueInput | ReviewLikeWhereUniqueInput[]
    update?: ReviewLikeUpdateWithWhereUniqueWithoutReviewInput | ReviewLikeUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReviewLikeUpdateManyWithWhereWithoutReviewInput | ReviewLikeUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReviewLikeScalarWhereInput | ReviewLikeScalarWhereInput[]
  }

  export type ReviewLikeUncheckedUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReviewLikeCreateWithoutReviewInput, ReviewLikeUncheckedCreateWithoutReviewInput> | ReviewLikeCreateWithoutReviewInput[] | ReviewLikeUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewLikeCreateOrConnectWithoutReviewInput | ReviewLikeCreateOrConnectWithoutReviewInput[]
    upsert?: ReviewLikeUpsertWithWhereUniqueWithoutReviewInput | ReviewLikeUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReviewLikeCreateManyReviewInputEnvelope
    set?: ReviewLikeWhereUniqueInput | ReviewLikeWhereUniqueInput[]
    disconnect?: ReviewLikeWhereUniqueInput | ReviewLikeWhereUniqueInput[]
    delete?: ReviewLikeWhereUniqueInput | ReviewLikeWhereUniqueInput[]
    connect?: ReviewLikeWhereUniqueInput | ReviewLikeWhereUniqueInput[]
    update?: ReviewLikeUpdateWithWhereUniqueWithoutReviewInput | ReviewLikeUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReviewLikeUpdateManyWithWhereWithoutReviewInput | ReviewLikeUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReviewLikeScalarWhereInput | ReviewLikeScalarWhereInput[]
  }

  export type ReviewCreateNestedOneWithoutLikesInput = {
    create?: XOR<ReviewCreateWithoutLikesInput, ReviewUncheckedCreateWithoutLikesInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutLikesInput
    connect?: ReviewWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewLikesInput = {
    create?: XOR<UserCreateWithoutReviewLikesInput, UserUncheckedCreateWithoutReviewLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewLikesInput
    connect?: UserWhereUniqueInput
  }

  export type ReviewUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<ReviewCreateWithoutLikesInput, ReviewUncheckedCreateWithoutLikesInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutLikesInput
    upsert?: ReviewUpsertWithoutLikesInput
    connect?: ReviewWhereUniqueInput
    update?: XOR<XOR<ReviewUpdateToOneWithWhereWithoutLikesInput, ReviewUpdateWithoutLikesInput>, ReviewUncheckedUpdateWithoutLikesInput>
  }

  export type UserUpdateOneRequiredWithoutReviewLikesNestedInput = {
    create?: XOR<UserCreateWithoutReviewLikesInput, UserUncheckedCreateWithoutReviewLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewLikesInput
    upsert?: UserUpsertWithoutReviewLikesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewLikesInput, UserUpdateWithoutReviewLikesInput>, UserUncheckedUpdateWithoutReviewLikesInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type ProviderCreateNestedOneWithoutStatusHistoryInput = {
    create?: XOR<ProviderCreateWithoutStatusHistoryInput, ProviderUncheckedCreateWithoutStatusHistoryInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutStatusHistoryInput
    connect?: ProviderWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProviderStatusChangesInput = {
    create?: XOR<UserCreateWithoutProviderStatusChangesInput, UserUncheckedCreateWithoutProviderStatusChangesInput>
    connectOrCreate?: UserCreateOrConnectWithoutProviderStatusChangesInput
    connect?: UserWhereUniqueInput
  }

  export type ProviderUpdateOneRequiredWithoutStatusHistoryNestedInput = {
    create?: XOR<ProviderCreateWithoutStatusHistoryInput, ProviderUncheckedCreateWithoutStatusHistoryInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutStatusHistoryInput
    upsert?: ProviderUpsertWithoutStatusHistoryInput
    connect?: ProviderWhereUniqueInput
    update?: XOR<XOR<ProviderUpdateToOneWithWhereWithoutStatusHistoryInput, ProviderUpdateWithoutStatusHistoryInput>, ProviderUncheckedUpdateWithoutStatusHistoryInput>
  }

  export type UserUpdateOneRequiredWithoutProviderStatusChangesNestedInput = {
    create?: XOR<UserCreateWithoutProviderStatusChangesInput, UserUncheckedCreateWithoutProviderStatusChangesInput>
    connectOrCreate?: UserCreateOrConnectWithoutProviderStatusChangesInput
    upsert?: UserUpsertWithoutProviderStatusChangesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProviderStatusChangesInput, UserUpdateWithoutProviderStatusChangesInput>, UserUncheckedUpdateWithoutProviderStatusChangesInput>
  }

  export type UserCreateNestedOneWithoutFeedbackSubmittedInput = {
    create?: XOR<UserCreateWithoutFeedbackSubmittedInput, UserUncheckedCreateWithoutFeedbackSubmittedInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbackSubmittedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFeedbackResponsesInput = {
    create?: XOR<UserCreateWithoutFeedbackResponsesInput, UserUncheckedCreateWithoutFeedbackResponsesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbackResponsesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumFeedbackCategoryFieldUpdateOperationsInput = {
    set?: $Enums.FeedbackCategory
  }

  export type NullableEnumFeedbackPriorityFieldUpdateOperationsInput = {
    set?: $Enums.FeedbackPriority | null
  }

  export type UserUpdateOneRequiredWithoutFeedbackSubmittedNestedInput = {
    create?: XOR<UserCreateWithoutFeedbackSubmittedInput, UserUncheckedCreateWithoutFeedbackSubmittedInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbackSubmittedInput
    upsert?: UserUpsertWithoutFeedbackSubmittedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFeedbackSubmittedInput, UserUpdateWithoutFeedbackSubmittedInput>, UserUncheckedUpdateWithoutFeedbackSubmittedInput>
  }

  export type UserUpdateOneWithoutFeedbackResponsesNestedInput = {
    create?: XOR<UserCreateWithoutFeedbackResponsesInput, UserUncheckedCreateWithoutFeedbackResponsesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbackResponsesInput
    upsert?: UserUpsertWithoutFeedbackResponsesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFeedbackResponsesInput, UserUpdateWithoutFeedbackResponsesInput>, UserUncheckedUpdateWithoutFeedbackResponsesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumProviderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProviderStatus | EnumProviderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProviderStatus[] | ListEnumProviderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProviderStatus[] | ListEnumProviderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProviderStatusFilter<$PrismaModel> | $Enums.ProviderStatus
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumProviderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProviderStatus | EnumProviderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProviderStatus[] | ListEnumProviderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProviderStatus[] | ListEnumProviderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProviderStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProviderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProviderStatusFilter<$PrismaModel>
    _max?: NestedEnumProviderStatusFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumServiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeFilter<$PrismaModel> | $Enums.ServiceType
  }

  export type NestedEnumPricingModelFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingModel | EnumPricingModelFieldRefInput<$PrismaModel>
    in?: $Enums.PricingModel[] | ListEnumPricingModelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PricingModel[] | ListEnumPricingModelFieldRefInput<$PrismaModel>
    not?: NestedEnumPricingModelFilter<$PrismaModel> | $Enums.PricingModel
  }

  export type NestedEnumServiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ServiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceTypeFilter<$PrismaModel>
    _max?: NestedEnumServiceTypeFilter<$PrismaModel>
  }

  export type NestedEnumPricingModelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingModel | EnumPricingModelFieldRefInput<$PrismaModel>
    in?: $Enums.PricingModel[] | ListEnumPricingModelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PricingModel[] | ListEnumPricingModelFieldRefInput<$PrismaModel>
    not?: NestedEnumPricingModelWithAggregatesFilter<$PrismaModel> | $Enums.PricingModel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPricingModelFilter<$PrismaModel>
    _max?: NestedEnumPricingModelFilter<$PrismaModel>
  }

  export type NestedEnumAppointmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusFilter<$PrismaModel> | $Enums.AppointmentStatus
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAppointmentStatusFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumDocumentVerificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentVerificationStatus | EnumDocumentVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentVerificationStatus[] | ListEnumDocumentVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentVerificationStatus[] | ListEnumDocumentVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentVerificationStatusFilter<$PrismaModel> | $Enums.DocumentVerificationStatus
  }

  export type NestedEnumDocumentVerificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentVerificationStatus | EnumDocumentVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentVerificationStatus[] | ListEnumDocumentVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentVerificationStatus[] | ListEnumDocumentVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentVerificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.DocumentVerificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentVerificationStatusFilter<$PrismaModel>
    _max?: NestedEnumDocumentVerificationStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumMessageStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageStatusFilter<$PrismaModel> | $Enums.MessageStatus
  }

  export type NestedEnumMessageStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageStatusWithAggregatesFilter<$PrismaModel> | $Enums.MessageStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageStatusFilter<$PrismaModel>
    _max?: NestedEnumMessageStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumFeedbackCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackCategory | EnumFeedbackCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackCategory[] | ListEnumFeedbackCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackCategory[] | ListEnumFeedbackCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackCategoryFilter<$PrismaModel> | $Enums.FeedbackCategory
  }

  export type NestedEnumFeedbackPriorityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackPriority | EnumFeedbackPriorityFieldRefInput<$PrismaModel> | null
    in?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFeedbackPriorityNullableFilter<$PrismaModel> | $Enums.FeedbackPriority | null
  }

  export type NestedEnumFeedbackCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackCategory | EnumFeedbackCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackCategory[] | ListEnumFeedbackCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackCategory[] | ListEnumFeedbackCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackCategoryWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackCategoryFilter<$PrismaModel>
    _max?: NestedEnumFeedbackCategoryFilter<$PrismaModel>
  }

  export type NestedEnumFeedbackPriorityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackPriority | EnumFeedbackPriorityFieldRefInput<$PrismaModel> | null
    in?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFeedbackPriorityNullableWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackPriority | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumFeedbackPriorityNullableFilter<$PrismaModel>
    _max?: NestedEnumFeedbackPriorityNullableFilter<$PrismaModel>
  }

  export type SessionCreateWithoutUserInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutSuspendedUsersInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    suspendedBy?: UserCreateNestedOneWithoutSuspendedUsersInput
    provider?: ProviderCreateNestedOneWithoutUserInput
    verifiedProviders?: ProviderCreateNestedManyWithoutVerifierInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    cancelledAppointments?: AppointmentCreateNestedManyWithoutCancellerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    conversationsAsUser1?: ConversationCreateNestedManyWithoutUser1Input
    conversationsAsUser2?: ConversationCreateNestedManyWithoutUser2Input
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewLikes?: ReviewLikeCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackCreateNestedManyWithoutRespondedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutAdminInput
    providerStatusChanges?: ProviderStatusHistoryCreateNestedManyWithoutChangedByInput
    verifiedDocuments?: DocumentCreateNestedManyWithoutVerifiedByInput
  }

  export type UserUncheckedCreateWithoutSuspendedUsersInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    suspendedById?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    provider?: ProviderUncheckedCreateNestedOneWithoutUserInput
    verifiedProviders?: ProviderUncheckedCreateNestedManyWithoutVerifierInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    cancelledAppointments?: AppointmentUncheckedCreateNestedManyWithoutCancellerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conversationsAsUser1?: ConversationUncheckedCreateNestedManyWithoutUser1Input
    conversationsAsUser2?: ConversationUncheckedCreateNestedManyWithoutUser2Input
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewLikes?: ReviewLikeUncheckedCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackUncheckedCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackUncheckedCreateNestedManyWithoutRespondedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    verifiedDocuments?: DocumentUncheckedCreateNestedManyWithoutVerifiedByInput
  }

  export type UserCreateOrConnectWithoutSuspendedUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSuspendedUsersInput, UserUncheckedCreateWithoutSuspendedUsersInput>
  }

  export type UserCreateWithoutSuspendedByInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    suspendedUsers?: UserCreateNestedManyWithoutSuspendedByInput
    provider?: ProviderCreateNestedOneWithoutUserInput
    verifiedProviders?: ProviderCreateNestedManyWithoutVerifierInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    cancelledAppointments?: AppointmentCreateNestedManyWithoutCancellerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    conversationsAsUser1?: ConversationCreateNestedManyWithoutUser1Input
    conversationsAsUser2?: ConversationCreateNestedManyWithoutUser2Input
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewLikes?: ReviewLikeCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackCreateNestedManyWithoutRespondedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutAdminInput
    providerStatusChanges?: ProviderStatusHistoryCreateNestedManyWithoutChangedByInput
    verifiedDocuments?: DocumentCreateNestedManyWithoutVerifiedByInput
  }

  export type UserUncheckedCreateWithoutSuspendedByInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    suspendedUsers?: UserUncheckedCreateNestedManyWithoutSuspendedByInput
    provider?: ProviderUncheckedCreateNestedOneWithoutUserInput
    verifiedProviders?: ProviderUncheckedCreateNestedManyWithoutVerifierInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    cancelledAppointments?: AppointmentUncheckedCreateNestedManyWithoutCancellerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conversationsAsUser1?: ConversationUncheckedCreateNestedManyWithoutUser1Input
    conversationsAsUser2?: ConversationUncheckedCreateNestedManyWithoutUser2Input
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewLikes?: ReviewLikeUncheckedCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackUncheckedCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackUncheckedCreateNestedManyWithoutRespondedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    verifiedDocuments?: DocumentUncheckedCreateNestedManyWithoutVerifiedByInput
  }

  export type UserCreateOrConnectWithoutSuspendedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSuspendedByInput, UserUncheckedCreateWithoutSuspendedByInput>
  }

  export type UserCreateManySuspendedByInputEnvelope = {
    data: UserCreateManySuspendedByInput | UserCreateManySuspendedByInput[]
    skipDuplicates?: boolean
  }

  export type ProviderCreateWithoutUserInput = {
    id?: string
    healthcareName: string
    description?: string | null
    phoneNumber?: string | null
    email?: string | null
    coverPhoto?: string | null
    status?: $Enums.ProviderStatus
    address: string
    city?: string
    province?: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    slotDuration?: number
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutProvidersInput
    verifier?: UserCreateNestedOneWithoutVerifiedProvidersInput
    services?: ServiceCreateNestedManyWithoutProviderInput
    operatingHours?: OperatingHourCreateNestedManyWithoutProviderInput
    appointments?: AppointmentCreateNestedManyWithoutProviderInput
    documents?: DocumentCreateNestedManyWithoutProviderInput
    breakTimes?: BreakTimeCreateNestedManyWithoutProviderInput
    notifications?: NotificationCreateNestedManyWithoutProviderInput
    reviews?: ReviewCreateNestedManyWithoutProviderInput
    statusHistory?: ProviderStatusHistoryCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateWithoutUserInput = {
    id?: string
    categoryId?: string | null
    verifiedBy?: string | null
    healthcareName: string
    description?: string | null
    phoneNumber?: string | null
    email?: string | null
    coverPhoto?: string | null
    status?: $Enums.ProviderStatus
    address: string
    city?: string
    province?: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    slotDuration?: number
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutProviderInput
    operatingHours?: OperatingHourUncheckedCreateNestedManyWithoutProviderInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutProviderInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProviderInput
    breakTimes?: BreakTimeUncheckedCreateNestedManyWithoutProviderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutProviderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProviderInput
    statusHistory?: ProviderStatusHistoryUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderCreateOrConnectWithoutUserInput = {
    where: ProviderWhereUniqueInput
    create: XOR<ProviderCreateWithoutUserInput, ProviderUncheckedCreateWithoutUserInput>
  }

  export type ProviderCreateWithoutVerifierInput = {
    id?: string
    healthcareName: string
    description?: string | null
    phoneNumber?: string | null
    email?: string | null
    coverPhoto?: string | null
    status?: $Enums.ProviderStatus
    address: string
    city?: string
    province?: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    slotDuration?: number
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProviderInput
    category?: CategoryCreateNestedOneWithoutProvidersInput
    services?: ServiceCreateNestedManyWithoutProviderInput
    operatingHours?: OperatingHourCreateNestedManyWithoutProviderInput
    appointments?: AppointmentCreateNestedManyWithoutProviderInput
    documents?: DocumentCreateNestedManyWithoutProviderInput
    breakTimes?: BreakTimeCreateNestedManyWithoutProviderInput
    notifications?: NotificationCreateNestedManyWithoutProviderInput
    reviews?: ReviewCreateNestedManyWithoutProviderInput
    statusHistory?: ProviderStatusHistoryCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateWithoutVerifierInput = {
    id?: string
    userId: string
    categoryId?: string | null
    healthcareName: string
    description?: string | null
    phoneNumber?: string | null
    email?: string | null
    coverPhoto?: string | null
    status?: $Enums.ProviderStatus
    address: string
    city?: string
    province?: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    slotDuration?: number
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutProviderInput
    operatingHours?: OperatingHourUncheckedCreateNestedManyWithoutProviderInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutProviderInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProviderInput
    breakTimes?: BreakTimeUncheckedCreateNestedManyWithoutProviderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutProviderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProviderInput
    statusHistory?: ProviderStatusHistoryUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderCreateOrConnectWithoutVerifierInput = {
    where: ProviderWhereUniqueInput
    create: XOR<ProviderCreateWithoutVerifierInput, ProviderUncheckedCreateWithoutVerifierInput>
  }

  export type ProviderCreateManyVerifierInputEnvelope = {
    data: ProviderCreateManyVerifierInput | ProviderCreateManyVerifierInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutUserInput = {
    id?: string
    appointmentNumber: string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.AppointmentStatus
    notes?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    patientName: string
    patientEmail: string
    patientPhone?: string | null
    activityNotes?: string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: ProviderCreateNestedOneWithoutAppointmentsInput
    canceller?: UserCreateNestedOneWithoutCancelledAppointmentsInput
    services?: AppointmentServiceCreateNestedManyWithoutAppointmentInput
    notifications?: NotificationCreateNestedManyWithoutAppointmentInput
    review?: ReviewCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutUserInput = {
    id?: string
    appointmentNumber: string
    providerId: string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.AppointmentStatus
    notes?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    patientName: string
    patientEmail: string
    patientPhone?: string | null
    activityNotes?: string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    cancelledBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: AppointmentServiceUncheckedCreateNestedManyWithoutAppointmentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutAppointmentInput
    review?: ReviewUncheckedCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutUserInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutUserInput, AppointmentUncheckedCreateWithoutUserInput>
  }

  export type AppointmentCreateManyUserInputEnvelope = {
    data: AppointmentCreateManyUserInput | AppointmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutCancellerInput = {
    id?: string
    appointmentNumber: string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.AppointmentStatus
    notes?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    patientName: string
    patientEmail: string
    patientPhone?: string | null
    activityNotes?: string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAppointmentsInput
    provider: ProviderCreateNestedOneWithoutAppointmentsInput
    services?: AppointmentServiceCreateNestedManyWithoutAppointmentInput
    notifications?: NotificationCreateNestedManyWithoutAppointmentInput
    review?: ReviewCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutCancellerInput = {
    id?: string
    appointmentNumber: string
    userId: string
    providerId: string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.AppointmentStatus
    notes?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    patientName: string
    patientEmail: string
    patientPhone?: string | null
    activityNotes?: string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: AppointmentServiceUncheckedCreateNestedManyWithoutAppointmentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutAppointmentInput
    review?: ReviewUncheckedCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutCancellerInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutCancellerInput, AppointmentUncheckedCreateWithoutCancellerInput>
  }

  export type AppointmentCreateManyCancellerInputEnvelope = {
    data: AppointmentCreateManyCancellerInput | AppointmentCreateManyCancellerInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment?: AppointmentCreateNestedOneWithoutNotificationsInput
    provider?: ProviderCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    appointmentId?: string | null
    providerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutUser1Input = {
    id?: string
    lastMessageAt?: Date | string | null
    lastMessageContent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user2: UserCreateNestedOneWithoutConversationsAsUser2Input
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutUser1Input = {
    id?: string
    user2Id: string
    lastMessageAt?: Date | string | null
    lastMessageContent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutUser1Input = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutUser1Input, ConversationUncheckedCreateWithoutUser1Input>
  }

  export type ConversationCreateManyUser1InputEnvelope = {
    data: ConversationCreateManyUser1Input | ConversationCreateManyUser1Input[]
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutUser2Input = {
    id?: string
    lastMessageAt?: Date | string | null
    lastMessageContent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user1: UserCreateNestedOneWithoutConversationsAsUser1Input
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutUser2Input = {
    id?: string
    user1Id: string
    lastMessageAt?: Date | string | null
    lastMessageContent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutUser2Input = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutUser2Input, ConversationUncheckedCreateWithoutUser2Input>
  }

  export type ConversationCreateManyUser2InputEnvelope = {
    data: ConversationCreateManyUser2Input | ConversationCreateManyUser2Input[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    content: string
    status?: $Enums.MessageStatus
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    conversationId: string
    content: string
    status?: $Enums.MessageStatus
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutUserInput = {
    id?: string
    rating: number
    comment?: string | null
    isAnonymous?: boolean
    professionalismRating?: number | null
    cleanlinessRating?: number | null
    waitTimeRating?: number | null
    valueRating?: number | null
    providerResponse?: string | null
    respondedAt?: Date | string | null
    isEdited?: boolean
    editedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment: AppointmentCreateNestedOneWithoutReviewInput
    provider: ProviderCreateNestedOneWithoutReviewsInput
    likes?: ReviewLikeCreateNestedManyWithoutReviewInput
  }

  export type ReviewUncheckedCreateWithoutUserInput = {
    id?: string
    appointmentId: string
    providerId: string
    rating: number
    comment?: string | null
    isAnonymous?: boolean
    professionalismRating?: number | null
    cleanlinessRating?: number | null
    waitTimeRating?: number | null
    valueRating?: number | null
    providerResponse?: string | null
    respondedAt?: Date | string | null
    isEdited?: boolean
    editedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: ReviewLikeUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewCreateOrConnectWithoutUserInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewCreateManyUserInputEnvelope = {
    data: ReviewCreateManyUserInput | ReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReviewLikeCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    review: ReviewCreateNestedOneWithoutLikesInput
  }

  export type ReviewLikeUncheckedCreateWithoutUserInput = {
    id?: string
    reviewId: string
    createdAt?: Date | string
  }

  export type ReviewLikeCreateOrConnectWithoutUserInput = {
    where: ReviewLikeWhereUniqueInput
    create: XOR<ReviewLikeCreateWithoutUserInput, ReviewLikeUncheckedCreateWithoutUserInput>
  }

  export type ReviewLikeCreateManyUserInputEnvelope = {
    data: ReviewLikeCreateManyUserInput | ReviewLikeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SystemFeedbackCreateWithoutUserInput = {
    id?: string
    category: $Enums.FeedbackCategory
    priority?: $Enums.FeedbackPriority | null
    title: string
    message: string
    satisfactionRating?: number | null
    adminResponse?: string | null
    respondedAt?: Date | string | null
    isRead?: boolean
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    respondedBy?: UserCreateNestedOneWithoutFeedbackResponsesInput
  }

  export type SystemFeedbackUncheckedCreateWithoutUserInput = {
    id?: string
    category: $Enums.FeedbackCategory
    priority?: $Enums.FeedbackPriority | null
    title: string
    message: string
    satisfactionRating?: number | null
    adminResponse?: string | null
    respondedAt?: Date | string | null
    respondedById?: string | null
    isRead?: boolean
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemFeedbackCreateOrConnectWithoutUserInput = {
    where: SystemFeedbackWhereUniqueInput
    create: XOR<SystemFeedbackCreateWithoutUserInput, SystemFeedbackUncheckedCreateWithoutUserInput>
  }

  export type SystemFeedbackCreateManyUserInputEnvelope = {
    data: SystemFeedbackCreateManyUserInput | SystemFeedbackCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SystemFeedbackCreateWithoutRespondedByInput = {
    id?: string
    category: $Enums.FeedbackCategory
    priority?: $Enums.FeedbackPriority | null
    title: string
    message: string
    satisfactionRating?: number | null
    adminResponse?: string | null
    respondedAt?: Date | string | null
    isRead?: boolean
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFeedbackSubmittedInput
  }

  export type SystemFeedbackUncheckedCreateWithoutRespondedByInput = {
    id?: string
    userId: string
    category: $Enums.FeedbackCategory
    priority?: $Enums.FeedbackPriority | null
    title: string
    message: string
    satisfactionRating?: number | null
    adminResponse?: string | null
    respondedAt?: Date | string | null
    isRead?: boolean
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemFeedbackCreateOrConnectWithoutRespondedByInput = {
    where: SystemFeedbackWhereUniqueInput
    create: XOR<SystemFeedbackCreateWithoutRespondedByInput, SystemFeedbackUncheckedCreateWithoutRespondedByInput>
  }

  export type SystemFeedbackCreateManyRespondedByInputEnvelope = {
    data: SystemFeedbackCreateManyRespondedByInput | SystemFeedbackCreateManyRespondedByInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutAdminInput = {
    id?: string
    action: string
    targetType: string
    targetId: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutAdminInput = {
    id?: string
    action: string
    targetType: string
    targetId: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutAdminInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutAdminInput, AuditLogUncheckedCreateWithoutAdminInput>
  }

  export type AuditLogCreateManyAdminInputEnvelope = {
    data: AuditLogCreateManyAdminInput | AuditLogCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type ProviderStatusHistoryCreateWithoutChangedByInput = {
    id?: string
    fromStatus: $Enums.ProviderStatus
    toStatus: $Enums.ProviderStatus
    reason?: string | null
    createdAt?: Date | string
    provider: ProviderCreateNestedOneWithoutStatusHistoryInput
  }

  export type ProviderStatusHistoryUncheckedCreateWithoutChangedByInput = {
    id?: string
    providerId: string
    fromStatus: $Enums.ProviderStatus
    toStatus: $Enums.ProviderStatus
    reason?: string | null
    createdAt?: Date | string
  }

  export type ProviderStatusHistoryCreateOrConnectWithoutChangedByInput = {
    where: ProviderStatusHistoryWhereUniqueInput
    create: XOR<ProviderStatusHistoryCreateWithoutChangedByInput, ProviderStatusHistoryUncheckedCreateWithoutChangedByInput>
  }

  export type ProviderStatusHistoryCreateManyChangedByInputEnvelope = {
    data: ProviderStatusHistoryCreateManyChangedByInput | ProviderStatusHistoryCreateManyChangedByInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutVerifiedByInput = {
    id?: string
    documentType: string
    filePath: string
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    verificationStatus?: $Enums.DocumentVerificationStatus
    rejectionReason?: string | null
    provider: ProviderCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutVerifiedByInput = {
    id?: string
    providerId: string
    documentType: string
    filePath: string
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    verificationStatus?: $Enums.DocumentVerificationStatus
    rejectionReason?: string | null
  }

  export type DocumentCreateOrConnectWithoutVerifiedByInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutVerifiedByInput, DocumentUncheckedCreateWithoutVerifiedByInput>
  }

  export type DocumentCreateManyVerifiedByInputEnvelope = {
    data: DocumentCreateManyVerifiedByInput | DocumentCreateManyVerifiedByInput[]
    skipDuplicates?: boolean
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type UserUpsertWithoutSuspendedUsersInput = {
    update: XOR<UserUpdateWithoutSuspendedUsersInput, UserUncheckedUpdateWithoutSuspendedUsersInput>
    create: XOR<UserCreateWithoutSuspendedUsersInput, UserUncheckedCreateWithoutSuspendedUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSuspendedUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSuspendedUsersInput, UserUncheckedUpdateWithoutSuspendedUsersInput>
  }

  export type UserUpdateWithoutSuspendedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    suspendedBy?: UserUpdateOneWithoutSuspendedUsersNestedInput
    provider?: ProviderUpdateOneWithoutUserNestedInput
    verifiedProviders?: ProviderUpdateManyWithoutVerifierNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    cancelledAppointments?: AppointmentUpdateManyWithoutCancellerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    conversationsAsUser1?: ConversationUpdateManyWithoutUser1NestedInput
    conversationsAsUser2?: ConversationUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewLikes?: ReviewLikeUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUpdateManyWithoutRespondedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutAdminNestedInput
    providerStatusChanges?: ProviderStatusHistoryUpdateManyWithoutChangedByNestedInput
    verifiedDocuments?: DocumentUpdateManyWithoutVerifiedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSuspendedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedById?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    provider?: ProviderUncheckedUpdateOneWithoutUserNestedInput
    verifiedProviders?: ProviderUncheckedUpdateManyWithoutVerifierNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    cancelledAppointments?: AppointmentUncheckedUpdateManyWithoutCancellerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conversationsAsUser1?: ConversationUncheckedUpdateManyWithoutUser1NestedInput
    conversationsAsUser2?: ConversationUncheckedUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewLikes?: ReviewLikeUncheckedUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUncheckedUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUncheckedUpdateManyWithoutRespondedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminNestedInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    verifiedDocuments?: DocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutSuspendedByInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutSuspendedByInput, UserUncheckedUpdateWithoutSuspendedByInput>
    create: XOR<UserCreateWithoutSuspendedByInput, UserUncheckedCreateWithoutSuspendedByInput>
  }

  export type UserUpdateWithWhereUniqueWithoutSuspendedByInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutSuspendedByInput, UserUncheckedUpdateWithoutSuspendedByInput>
  }

  export type UserUpdateManyWithWhereWithoutSuspendedByInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutSuspendedByInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    suspendedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    suspendReason?: StringNullableFilter<"User"> | string | null
    suspendedById?: StringNullableFilter<"User"> | string | null
  }

  export type ProviderUpsertWithoutUserInput = {
    update: XOR<ProviderUpdateWithoutUserInput, ProviderUncheckedUpdateWithoutUserInput>
    create: XOR<ProviderCreateWithoutUserInput, ProviderUncheckedCreateWithoutUserInput>
    where?: ProviderWhereInput
  }

  export type ProviderUpdateToOneWithWhereWithoutUserInput = {
    where?: ProviderWhereInput
    data: XOR<ProviderUpdateWithoutUserInput, ProviderUncheckedUpdateWithoutUserInput>
  }

  export type ProviderUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    healthcareName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    slotDuration?: IntFieldUpdateOperationsInput | number
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneWithoutProvidersNestedInput
    verifier?: UserUpdateOneWithoutVerifiedProvidersNestedInput
    services?: ServiceUpdateManyWithoutProviderNestedInput
    operatingHours?: OperatingHourUpdateManyWithoutProviderNestedInput
    appointments?: AppointmentUpdateManyWithoutProviderNestedInput
    documents?: DocumentUpdateManyWithoutProviderNestedInput
    breakTimes?: BreakTimeUpdateManyWithoutProviderNestedInput
    notifications?: NotificationUpdateManyWithoutProviderNestedInput
    reviews?: ReviewUpdateManyWithoutProviderNestedInput
    statusHistory?: ProviderStatusHistoryUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    healthcareName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    slotDuration?: IntFieldUpdateOperationsInput | number
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutProviderNestedInput
    operatingHours?: OperatingHourUncheckedUpdateManyWithoutProviderNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutProviderNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProviderNestedInput
    breakTimes?: BreakTimeUncheckedUpdateManyWithoutProviderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutProviderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProviderNestedInput
    statusHistory?: ProviderStatusHistoryUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUpsertWithWhereUniqueWithoutVerifierInput = {
    where: ProviderWhereUniqueInput
    update: XOR<ProviderUpdateWithoutVerifierInput, ProviderUncheckedUpdateWithoutVerifierInput>
    create: XOR<ProviderCreateWithoutVerifierInput, ProviderUncheckedCreateWithoutVerifierInput>
  }

  export type ProviderUpdateWithWhereUniqueWithoutVerifierInput = {
    where: ProviderWhereUniqueInput
    data: XOR<ProviderUpdateWithoutVerifierInput, ProviderUncheckedUpdateWithoutVerifierInput>
  }

  export type ProviderUpdateManyWithWhereWithoutVerifierInput = {
    where: ProviderScalarWhereInput
    data: XOR<ProviderUpdateManyMutationInput, ProviderUncheckedUpdateManyWithoutVerifierInput>
  }

  export type ProviderScalarWhereInput = {
    AND?: ProviderScalarWhereInput | ProviderScalarWhereInput[]
    OR?: ProviderScalarWhereInput[]
    NOT?: ProviderScalarWhereInput | ProviderScalarWhereInput[]
    id?: StringFilter<"Provider"> | string
    userId?: StringFilter<"Provider"> | string
    categoryId?: StringNullableFilter<"Provider"> | string | null
    verifiedBy?: StringNullableFilter<"Provider"> | string | null
    healthcareName?: StringFilter<"Provider"> | string
    description?: StringNullableFilter<"Provider"> | string | null
    phoneNumber?: StringNullableFilter<"Provider"> | string | null
    email?: StringNullableFilter<"Provider"> | string | null
    coverPhoto?: StringNullableFilter<"Provider"> | string | null
    status?: EnumProviderStatusFilter<"Provider"> | $Enums.ProviderStatus
    address?: StringFilter<"Provider"> | string
    city?: StringFilter<"Provider"> | string
    province?: StringFilter<"Provider"> | string
    latitude?: DecimalNullableFilter<"Provider"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Provider"> | Decimal | DecimalJsLike | number | string | null
    slotDuration?: IntFilter<"Provider"> | number
    verifiedAt?: DateTimeNullableFilter<"Provider"> | Date | string | null
    createdAt?: DateTimeFilter<"Provider"> | Date | string
    updatedAt?: DateTimeFilter<"Provider"> | Date | string
  }

  export type AppointmentUpsertWithWhereUniqueWithoutUserInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutUserInput, AppointmentUncheckedUpdateWithoutUserInput>
    create: XOR<AppointmentCreateWithoutUserInput, AppointmentUncheckedCreateWithoutUserInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutUserInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutUserInput, AppointmentUncheckedUpdateWithoutUserInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutUserInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutUserInput>
  }

  export type AppointmentScalarWhereInput = {
    AND?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    OR?: AppointmentScalarWhereInput[]
    NOT?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    id?: StringFilter<"Appointment"> | string
    appointmentNumber?: StringFilter<"Appointment"> | string
    userId?: StringFilter<"Appointment"> | string
    providerId?: StringFilter<"Appointment"> | string
    startTime?: DateTimeFilter<"Appointment"> | Date | string
    endTime?: DateTimeFilter<"Appointment"> | Date | string
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    notes?: StringNullableFilter<"Appointment"> | string | null
    totalPrice?: DecimalFilter<"Appointment"> | Decimal | DecimalJsLike | number | string
    patientName?: StringFilter<"Appointment"> | string
    patientEmail?: StringFilter<"Appointment"> | string
    patientPhone?: StringNullableFilter<"Appointment"> | string | null
    activityNotes?: StringNullableFilter<"Appointment"> | string | null
    cancelledAt?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    cancellationReason?: StringNullableFilter<"Appointment"> | string | null
    cancelledBy?: StringNullableFilter<"Appointment"> | string | null
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
  }

  export type AppointmentUpsertWithWhereUniqueWithoutCancellerInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutCancellerInput, AppointmentUncheckedUpdateWithoutCancellerInput>
    create: XOR<AppointmentCreateWithoutCancellerInput, AppointmentUncheckedCreateWithoutCancellerInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutCancellerInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutCancellerInput, AppointmentUncheckedUpdateWithoutCancellerInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutCancellerInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutCancellerInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    appointmentId?: StringNullableFilter<"Notification"> | string | null
    providerId?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type ConversationUpsertWithWhereUniqueWithoutUser1Input = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutUser1Input, ConversationUncheckedUpdateWithoutUser1Input>
    create: XOR<ConversationCreateWithoutUser1Input, ConversationUncheckedCreateWithoutUser1Input>
  }

  export type ConversationUpdateWithWhereUniqueWithoutUser1Input = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutUser1Input, ConversationUncheckedUpdateWithoutUser1Input>
  }

  export type ConversationUpdateManyWithWhereWithoutUser1Input = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutUser1Input>
  }

  export type ConversationScalarWhereInput = {
    AND?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    OR?: ConversationScalarWhereInput[]
    NOT?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    id?: StringFilter<"Conversation"> | string
    user1Id?: StringFilter<"Conversation"> | string
    user2Id?: StringFilter<"Conversation"> | string
    lastMessageAt?: DateTimeNullableFilter<"Conversation"> | Date | string | null
    lastMessageContent?: StringNullableFilter<"Conversation"> | string | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
  }

  export type ConversationUpsertWithWhereUniqueWithoutUser2Input = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutUser2Input, ConversationUncheckedUpdateWithoutUser2Input>
    create: XOR<ConversationCreateWithoutUser2Input, ConversationUncheckedCreateWithoutUser2Input>
  }

  export type ConversationUpdateWithWhereUniqueWithoutUser2Input = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutUser2Input, ConversationUncheckedUpdateWithoutUser2Input>
  }

  export type ConversationUpdateManyWithWhereWithoutUser2Input = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutUser2Input>
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    status?: EnumMessageStatusFilter<"Message"> | $Enums.MessageStatus
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUpdateManyWithWhereWithoutUserInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: StringFilter<"Review"> | string
    appointmentId?: StringFilter<"Review"> | string
    userId?: StringFilter<"Review"> | string
    providerId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    isAnonymous?: BoolFilter<"Review"> | boolean
    professionalismRating?: IntNullableFilter<"Review"> | number | null
    cleanlinessRating?: IntNullableFilter<"Review"> | number | null
    waitTimeRating?: IntNullableFilter<"Review"> | number | null
    valueRating?: IntNullableFilter<"Review"> | number | null
    providerResponse?: StringNullableFilter<"Review"> | string | null
    respondedAt?: DateTimeNullableFilter<"Review"> | Date | string | null
    isEdited?: BoolFilter<"Review"> | boolean
    editedAt?: DateTimeNullableFilter<"Review"> | Date | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
  }

  export type ReviewLikeUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewLikeWhereUniqueInput
    update: XOR<ReviewLikeUpdateWithoutUserInput, ReviewLikeUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewLikeCreateWithoutUserInput, ReviewLikeUncheckedCreateWithoutUserInput>
  }

  export type ReviewLikeUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewLikeWhereUniqueInput
    data: XOR<ReviewLikeUpdateWithoutUserInput, ReviewLikeUncheckedUpdateWithoutUserInput>
  }

  export type ReviewLikeUpdateManyWithWhereWithoutUserInput = {
    where: ReviewLikeScalarWhereInput
    data: XOR<ReviewLikeUpdateManyMutationInput, ReviewLikeUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewLikeScalarWhereInput = {
    AND?: ReviewLikeScalarWhereInput | ReviewLikeScalarWhereInput[]
    OR?: ReviewLikeScalarWhereInput[]
    NOT?: ReviewLikeScalarWhereInput | ReviewLikeScalarWhereInput[]
    id?: StringFilter<"ReviewLike"> | string
    reviewId?: StringFilter<"ReviewLike"> | string
    userId?: StringFilter<"ReviewLike"> | string
    createdAt?: DateTimeFilter<"ReviewLike"> | Date | string
  }

  export type SystemFeedbackUpsertWithWhereUniqueWithoutUserInput = {
    where: SystemFeedbackWhereUniqueInput
    update: XOR<SystemFeedbackUpdateWithoutUserInput, SystemFeedbackUncheckedUpdateWithoutUserInput>
    create: XOR<SystemFeedbackCreateWithoutUserInput, SystemFeedbackUncheckedCreateWithoutUserInput>
  }

  export type SystemFeedbackUpdateWithWhereUniqueWithoutUserInput = {
    where: SystemFeedbackWhereUniqueInput
    data: XOR<SystemFeedbackUpdateWithoutUserInput, SystemFeedbackUncheckedUpdateWithoutUserInput>
  }

  export type SystemFeedbackUpdateManyWithWhereWithoutUserInput = {
    where: SystemFeedbackScalarWhereInput
    data: XOR<SystemFeedbackUpdateManyMutationInput, SystemFeedbackUncheckedUpdateManyWithoutUserInput>
  }

  export type SystemFeedbackScalarWhereInput = {
    AND?: SystemFeedbackScalarWhereInput | SystemFeedbackScalarWhereInput[]
    OR?: SystemFeedbackScalarWhereInput[]
    NOT?: SystemFeedbackScalarWhereInput | SystemFeedbackScalarWhereInput[]
    id?: StringFilter<"SystemFeedback"> | string
    userId?: StringFilter<"SystemFeedback"> | string
    category?: EnumFeedbackCategoryFilter<"SystemFeedback"> | $Enums.FeedbackCategory
    priority?: EnumFeedbackPriorityNullableFilter<"SystemFeedback"> | $Enums.FeedbackPriority | null
    title?: StringFilter<"SystemFeedback"> | string
    message?: StringFilter<"SystemFeedback"> | string
    satisfactionRating?: IntNullableFilter<"SystemFeedback"> | number | null
    adminResponse?: StringNullableFilter<"SystemFeedback"> | string | null
    respondedAt?: DateTimeNullableFilter<"SystemFeedback"> | Date | string | null
    respondedById?: StringNullableFilter<"SystemFeedback"> | string | null
    isRead?: BoolFilter<"SystemFeedback"> | boolean
    isResolved?: BoolFilter<"SystemFeedback"> | boolean
    resolvedAt?: DateTimeNullableFilter<"SystemFeedback"> | Date | string | null
    createdAt?: DateTimeFilter<"SystemFeedback"> | Date | string
    updatedAt?: DateTimeFilter<"SystemFeedback"> | Date | string
  }

  export type SystemFeedbackUpsertWithWhereUniqueWithoutRespondedByInput = {
    where: SystemFeedbackWhereUniqueInput
    update: XOR<SystemFeedbackUpdateWithoutRespondedByInput, SystemFeedbackUncheckedUpdateWithoutRespondedByInput>
    create: XOR<SystemFeedbackCreateWithoutRespondedByInput, SystemFeedbackUncheckedCreateWithoutRespondedByInput>
  }

  export type SystemFeedbackUpdateWithWhereUniqueWithoutRespondedByInput = {
    where: SystemFeedbackWhereUniqueInput
    data: XOR<SystemFeedbackUpdateWithoutRespondedByInput, SystemFeedbackUncheckedUpdateWithoutRespondedByInput>
  }

  export type SystemFeedbackUpdateManyWithWhereWithoutRespondedByInput = {
    where: SystemFeedbackScalarWhereInput
    data: XOR<SystemFeedbackUpdateManyMutationInput, SystemFeedbackUncheckedUpdateManyWithoutRespondedByInput>
  }

  export type AuditLogUpsertWithWhereUniqueWithoutAdminInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutAdminInput, AuditLogUncheckedUpdateWithoutAdminInput>
    create: XOR<AuditLogCreateWithoutAdminInput, AuditLogUncheckedCreateWithoutAdminInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutAdminInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutAdminInput, AuditLogUncheckedUpdateWithoutAdminInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutAdminInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutAdminInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    adminId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    targetType?: StringFilter<"AuditLog"> | string
    targetId?: StringFilter<"AuditLog"> | string
    oldValue?: JsonNullableFilter<"AuditLog">
    newValue?: JsonNullableFilter<"AuditLog">
    metadata?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type ProviderStatusHistoryUpsertWithWhereUniqueWithoutChangedByInput = {
    where: ProviderStatusHistoryWhereUniqueInput
    update: XOR<ProviderStatusHistoryUpdateWithoutChangedByInput, ProviderStatusHistoryUncheckedUpdateWithoutChangedByInput>
    create: XOR<ProviderStatusHistoryCreateWithoutChangedByInput, ProviderStatusHistoryUncheckedCreateWithoutChangedByInput>
  }

  export type ProviderStatusHistoryUpdateWithWhereUniqueWithoutChangedByInput = {
    where: ProviderStatusHistoryWhereUniqueInput
    data: XOR<ProviderStatusHistoryUpdateWithoutChangedByInput, ProviderStatusHistoryUncheckedUpdateWithoutChangedByInput>
  }

  export type ProviderStatusHistoryUpdateManyWithWhereWithoutChangedByInput = {
    where: ProviderStatusHistoryScalarWhereInput
    data: XOR<ProviderStatusHistoryUpdateManyMutationInput, ProviderStatusHistoryUncheckedUpdateManyWithoutChangedByInput>
  }

  export type ProviderStatusHistoryScalarWhereInput = {
    AND?: ProviderStatusHistoryScalarWhereInput | ProviderStatusHistoryScalarWhereInput[]
    OR?: ProviderStatusHistoryScalarWhereInput[]
    NOT?: ProviderStatusHistoryScalarWhereInput | ProviderStatusHistoryScalarWhereInput[]
    id?: StringFilter<"ProviderStatusHistory"> | string
    providerId?: StringFilter<"ProviderStatusHistory"> | string
    fromStatus?: EnumProviderStatusFilter<"ProviderStatusHistory"> | $Enums.ProviderStatus
    toStatus?: EnumProviderStatusFilter<"ProviderStatusHistory"> | $Enums.ProviderStatus
    reason?: StringNullableFilter<"ProviderStatusHistory"> | string | null
    changedById?: StringFilter<"ProviderStatusHistory"> | string
    createdAt?: DateTimeFilter<"ProviderStatusHistory"> | Date | string
  }

  export type DocumentUpsertWithWhereUniqueWithoutVerifiedByInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutVerifiedByInput, DocumentUncheckedUpdateWithoutVerifiedByInput>
    create: XOR<DocumentCreateWithoutVerifiedByInput, DocumentUncheckedCreateWithoutVerifiedByInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutVerifiedByInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutVerifiedByInput, DocumentUncheckedUpdateWithoutVerifiedByInput>
  }

  export type DocumentUpdateManyWithWhereWithoutVerifiedByInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutVerifiedByInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    providerId?: StringFilter<"Document"> | string
    documentType?: StringFilter<"Document"> | string
    filePath?: StringFilter<"Document"> | string
    verifiedAt?: DateTimeNullableFilter<"Document"> | Date | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    verificationStatus?: EnumDocumentVerificationStatusFilter<"Document"> | $Enums.DocumentVerificationStatus
    verifiedById?: StringNullableFilter<"Document"> | string | null
    rejectionReason?: StringNullableFilter<"Document"> | string | null
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    suspendedBy?: UserCreateNestedOneWithoutSuspendedUsersInput
    suspendedUsers?: UserCreateNestedManyWithoutSuspendedByInput
    provider?: ProviderCreateNestedOneWithoutUserInput
    verifiedProviders?: ProviderCreateNestedManyWithoutVerifierInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    cancelledAppointments?: AppointmentCreateNestedManyWithoutCancellerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    conversationsAsUser1?: ConversationCreateNestedManyWithoutUser1Input
    conversationsAsUser2?: ConversationCreateNestedManyWithoutUser2Input
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewLikes?: ReviewLikeCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackCreateNestedManyWithoutRespondedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutAdminInput
    providerStatusChanges?: ProviderStatusHistoryCreateNestedManyWithoutChangedByInput
    verifiedDocuments?: DocumentCreateNestedManyWithoutVerifiedByInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    suspendedById?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    suspendedUsers?: UserUncheckedCreateNestedManyWithoutSuspendedByInput
    provider?: ProviderUncheckedCreateNestedOneWithoutUserInput
    verifiedProviders?: ProviderUncheckedCreateNestedManyWithoutVerifierInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    cancelledAppointments?: AppointmentUncheckedCreateNestedManyWithoutCancellerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conversationsAsUser1?: ConversationUncheckedCreateNestedManyWithoutUser1Input
    conversationsAsUser2?: ConversationUncheckedCreateNestedManyWithoutUser2Input
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewLikes?: ReviewLikeUncheckedCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackUncheckedCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackUncheckedCreateNestedManyWithoutRespondedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    verifiedDocuments?: DocumentUncheckedCreateNestedManyWithoutVerifiedByInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    suspendedBy?: UserUpdateOneWithoutSuspendedUsersNestedInput
    suspendedUsers?: UserUpdateManyWithoutSuspendedByNestedInput
    provider?: ProviderUpdateOneWithoutUserNestedInput
    verifiedProviders?: ProviderUpdateManyWithoutVerifierNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    cancelledAppointments?: AppointmentUpdateManyWithoutCancellerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    conversationsAsUser1?: ConversationUpdateManyWithoutUser1NestedInput
    conversationsAsUser2?: ConversationUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewLikes?: ReviewLikeUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUpdateManyWithoutRespondedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutAdminNestedInput
    providerStatusChanges?: ProviderStatusHistoryUpdateManyWithoutChangedByNestedInput
    verifiedDocuments?: DocumentUpdateManyWithoutVerifiedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedById?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    suspendedUsers?: UserUncheckedUpdateManyWithoutSuspendedByNestedInput
    provider?: ProviderUncheckedUpdateOneWithoutUserNestedInput
    verifiedProviders?: ProviderUncheckedUpdateManyWithoutVerifierNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    cancelledAppointments?: AppointmentUncheckedUpdateManyWithoutCancellerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conversationsAsUser1?: ConversationUncheckedUpdateManyWithoutUser1NestedInput
    conversationsAsUser2?: ConversationUncheckedUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewLikes?: ReviewLikeUncheckedUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUncheckedUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUncheckedUpdateManyWithoutRespondedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminNestedInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    verifiedDocuments?: DocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    suspendedBy?: UserCreateNestedOneWithoutSuspendedUsersInput
    suspendedUsers?: UserCreateNestedManyWithoutSuspendedByInput
    provider?: ProviderCreateNestedOneWithoutUserInput
    verifiedProviders?: ProviderCreateNestedManyWithoutVerifierInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    cancelledAppointments?: AppointmentCreateNestedManyWithoutCancellerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    conversationsAsUser1?: ConversationCreateNestedManyWithoutUser1Input
    conversationsAsUser2?: ConversationCreateNestedManyWithoutUser2Input
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewLikes?: ReviewLikeCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackCreateNestedManyWithoutRespondedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutAdminInput
    providerStatusChanges?: ProviderStatusHistoryCreateNestedManyWithoutChangedByInput
    verifiedDocuments?: DocumentCreateNestedManyWithoutVerifiedByInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    suspendedById?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    suspendedUsers?: UserUncheckedCreateNestedManyWithoutSuspendedByInput
    provider?: ProviderUncheckedCreateNestedOneWithoutUserInput
    verifiedProviders?: ProviderUncheckedCreateNestedManyWithoutVerifierInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    cancelledAppointments?: AppointmentUncheckedCreateNestedManyWithoutCancellerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conversationsAsUser1?: ConversationUncheckedCreateNestedManyWithoutUser1Input
    conversationsAsUser2?: ConversationUncheckedCreateNestedManyWithoutUser2Input
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewLikes?: ReviewLikeUncheckedCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackUncheckedCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackUncheckedCreateNestedManyWithoutRespondedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    verifiedDocuments?: DocumentUncheckedCreateNestedManyWithoutVerifiedByInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    suspendedBy?: UserUpdateOneWithoutSuspendedUsersNestedInput
    suspendedUsers?: UserUpdateManyWithoutSuspendedByNestedInput
    provider?: ProviderUpdateOneWithoutUserNestedInput
    verifiedProviders?: ProviderUpdateManyWithoutVerifierNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    cancelledAppointments?: AppointmentUpdateManyWithoutCancellerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    conversationsAsUser1?: ConversationUpdateManyWithoutUser1NestedInput
    conversationsAsUser2?: ConversationUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewLikes?: ReviewLikeUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUpdateManyWithoutRespondedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutAdminNestedInput
    providerStatusChanges?: ProviderStatusHistoryUpdateManyWithoutChangedByNestedInput
    verifiedDocuments?: DocumentUpdateManyWithoutVerifiedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedById?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    suspendedUsers?: UserUncheckedUpdateManyWithoutSuspendedByNestedInput
    provider?: ProviderUncheckedUpdateOneWithoutUserNestedInput
    verifiedProviders?: ProviderUncheckedUpdateManyWithoutVerifierNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    cancelledAppointments?: AppointmentUncheckedUpdateManyWithoutCancellerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conversationsAsUser1?: ConversationUncheckedUpdateManyWithoutUser1NestedInput
    conversationsAsUser2?: ConversationUncheckedUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewLikes?: ReviewLikeUncheckedUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUncheckedUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUncheckedUpdateManyWithoutRespondedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminNestedInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    verifiedDocuments?: DocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
  }

  export type ProviderCreateWithoutCategoryInput = {
    id?: string
    healthcareName: string
    description?: string | null
    phoneNumber?: string | null
    email?: string | null
    coverPhoto?: string | null
    status?: $Enums.ProviderStatus
    address: string
    city?: string
    province?: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    slotDuration?: number
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProviderInput
    verifier?: UserCreateNestedOneWithoutVerifiedProvidersInput
    services?: ServiceCreateNestedManyWithoutProviderInput
    operatingHours?: OperatingHourCreateNestedManyWithoutProviderInput
    appointments?: AppointmentCreateNestedManyWithoutProviderInput
    documents?: DocumentCreateNestedManyWithoutProviderInput
    breakTimes?: BreakTimeCreateNestedManyWithoutProviderInput
    notifications?: NotificationCreateNestedManyWithoutProviderInput
    reviews?: ReviewCreateNestedManyWithoutProviderInput
    statusHistory?: ProviderStatusHistoryCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateWithoutCategoryInput = {
    id?: string
    userId: string
    verifiedBy?: string | null
    healthcareName: string
    description?: string | null
    phoneNumber?: string | null
    email?: string | null
    coverPhoto?: string | null
    status?: $Enums.ProviderStatus
    address: string
    city?: string
    province?: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    slotDuration?: number
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutProviderInput
    operatingHours?: OperatingHourUncheckedCreateNestedManyWithoutProviderInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutProviderInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProviderInput
    breakTimes?: BreakTimeUncheckedCreateNestedManyWithoutProviderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutProviderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProviderInput
    statusHistory?: ProviderStatusHistoryUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderCreateOrConnectWithoutCategoryInput = {
    where: ProviderWhereUniqueInput
    create: XOR<ProviderCreateWithoutCategoryInput, ProviderUncheckedCreateWithoutCategoryInput>
  }

  export type ProviderCreateManyCategoryInputEnvelope = {
    data: ProviderCreateManyCategoryInput | ProviderCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ProviderUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProviderWhereUniqueInput
    update: XOR<ProviderUpdateWithoutCategoryInput, ProviderUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProviderCreateWithoutCategoryInput, ProviderUncheckedCreateWithoutCategoryInput>
  }

  export type ProviderUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProviderWhereUniqueInput
    data: XOR<ProviderUpdateWithoutCategoryInput, ProviderUncheckedUpdateWithoutCategoryInput>
  }

  export type ProviderUpdateManyWithWhereWithoutCategoryInput = {
    where: ProviderScalarWhereInput
    data: XOR<ProviderUpdateManyMutationInput, ProviderUncheckedUpdateManyWithoutCategoryInput>
  }

  export type UserCreateWithoutProviderInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    suspendedBy?: UserCreateNestedOneWithoutSuspendedUsersInput
    suspendedUsers?: UserCreateNestedManyWithoutSuspendedByInput
    verifiedProviders?: ProviderCreateNestedManyWithoutVerifierInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    cancelledAppointments?: AppointmentCreateNestedManyWithoutCancellerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    conversationsAsUser1?: ConversationCreateNestedManyWithoutUser1Input
    conversationsAsUser2?: ConversationCreateNestedManyWithoutUser2Input
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewLikes?: ReviewLikeCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackCreateNestedManyWithoutRespondedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutAdminInput
    providerStatusChanges?: ProviderStatusHistoryCreateNestedManyWithoutChangedByInput
    verifiedDocuments?: DocumentCreateNestedManyWithoutVerifiedByInput
  }

  export type UserUncheckedCreateWithoutProviderInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    suspendedById?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    suspendedUsers?: UserUncheckedCreateNestedManyWithoutSuspendedByInput
    verifiedProviders?: ProviderUncheckedCreateNestedManyWithoutVerifierInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    cancelledAppointments?: AppointmentUncheckedCreateNestedManyWithoutCancellerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conversationsAsUser1?: ConversationUncheckedCreateNestedManyWithoutUser1Input
    conversationsAsUser2?: ConversationUncheckedCreateNestedManyWithoutUser2Input
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewLikes?: ReviewLikeUncheckedCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackUncheckedCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackUncheckedCreateNestedManyWithoutRespondedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    verifiedDocuments?: DocumentUncheckedCreateNestedManyWithoutVerifiedByInput
  }

  export type UserCreateOrConnectWithoutProviderInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProviderInput, UserUncheckedCreateWithoutProviderInput>
  }

  export type CategoryCreateWithoutProvidersInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    color?: string
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUncheckedCreateWithoutProvidersInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    color?: string
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryCreateOrConnectWithoutProvidersInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProvidersInput, CategoryUncheckedCreateWithoutProvidersInput>
  }

  export type UserCreateWithoutVerifiedProvidersInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    suspendedBy?: UserCreateNestedOneWithoutSuspendedUsersInput
    suspendedUsers?: UserCreateNestedManyWithoutSuspendedByInput
    provider?: ProviderCreateNestedOneWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    cancelledAppointments?: AppointmentCreateNestedManyWithoutCancellerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    conversationsAsUser1?: ConversationCreateNestedManyWithoutUser1Input
    conversationsAsUser2?: ConversationCreateNestedManyWithoutUser2Input
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewLikes?: ReviewLikeCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackCreateNestedManyWithoutRespondedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutAdminInput
    providerStatusChanges?: ProviderStatusHistoryCreateNestedManyWithoutChangedByInput
    verifiedDocuments?: DocumentCreateNestedManyWithoutVerifiedByInput
  }

  export type UserUncheckedCreateWithoutVerifiedProvidersInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    suspendedById?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    suspendedUsers?: UserUncheckedCreateNestedManyWithoutSuspendedByInput
    provider?: ProviderUncheckedCreateNestedOneWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    cancelledAppointments?: AppointmentUncheckedCreateNestedManyWithoutCancellerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conversationsAsUser1?: ConversationUncheckedCreateNestedManyWithoutUser1Input
    conversationsAsUser2?: ConversationUncheckedCreateNestedManyWithoutUser2Input
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewLikes?: ReviewLikeUncheckedCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackUncheckedCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackUncheckedCreateNestedManyWithoutRespondedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    verifiedDocuments?: DocumentUncheckedCreateNestedManyWithoutVerifiedByInput
  }

  export type UserCreateOrConnectWithoutVerifiedProvidersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVerifiedProvidersInput, UserUncheckedCreateWithoutVerifiedProvidersInput>
  }

  export type ServiceCreateWithoutProviderInput = {
    id?: string
    name: string
    description?: string | null
    type?: $Enums.ServiceType
    pricingModel?: $Enums.PricingModel
    fixedPrice?: number
    priceMin?: number
    priceMax?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentServiceCreateNestedManyWithoutServiceInput
    includedServices?: ServicePackageCreateNestedManyWithoutParentPackageInput
    partOfPackages?: ServicePackageCreateNestedManyWithoutChildServiceInput
    acceptedInsurances?: ServiceInsuranceCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutProviderInput = {
    id?: string
    name: string
    description?: string | null
    type?: $Enums.ServiceType
    pricingModel?: $Enums.PricingModel
    fixedPrice?: number
    priceMin?: number
    priceMax?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentServiceUncheckedCreateNestedManyWithoutServiceInput
    includedServices?: ServicePackageUncheckedCreateNestedManyWithoutParentPackageInput
    partOfPackages?: ServicePackageUncheckedCreateNestedManyWithoutChildServiceInput
    acceptedInsurances?: ServiceInsuranceUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutProviderInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutProviderInput, ServiceUncheckedCreateWithoutProviderInput>
  }

  export type ServiceCreateManyProviderInputEnvelope = {
    data: ServiceCreateManyProviderInput | ServiceCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type OperatingHourCreateWithoutProviderInput = {
    id?: string
    dayOfWeek: number
    startTime?: string | null
    endTime?: string | null
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OperatingHourUncheckedCreateWithoutProviderInput = {
    id?: string
    dayOfWeek: number
    startTime?: string | null
    endTime?: string | null
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OperatingHourCreateOrConnectWithoutProviderInput = {
    where: OperatingHourWhereUniqueInput
    create: XOR<OperatingHourCreateWithoutProviderInput, OperatingHourUncheckedCreateWithoutProviderInput>
  }

  export type OperatingHourCreateManyProviderInputEnvelope = {
    data: OperatingHourCreateManyProviderInput | OperatingHourCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutProviderInput = {
    id?: string
    appointmentNumber: string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.AppointmentStatus
    notes?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    patientName: string
    patientEmail: string
    patientPhone?: string | null
    activityNotes?: string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAppointmentsInput
    canceller?: UserCreateNestedOneWithoutCancelledAppointmentsInput
    services?: AppointmentServiceCreateNestedManyWithoutAppointmentInput
    notifications?: NotificationCreateNestedManyWithoutAppointmentInput
    review?: ReviewCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutProviderInput = {
    id?: string
    appointmentNumber: string
    userId: string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.AppointmentStatus
    notes?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    patientName: string
    patientEmail: string
    patientPhone?: string | null
    activityNotes?: string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    cancelledBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: AppointmentServiceUncheckedCreateNestedManyWithoutAppointmentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutAppointmentInput
    review?: ReviewUncheckedCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutProviderInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutProviderInput, AppointmentUncheckedCreateWithoutProviderInput>
  }

  export type AppointmentCreateManyProviderInputEnvelope = {
    data: AppointmentCreateManyProviderInput | AppointmentCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutProviderInput = {
    id?: string
    documentType: string
    filePath: string
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    verificationStatus?: $Enums.DocumentVerificationStatus
    rejectionReason?: string | null
    verifiedBy?: UserCreateNestedOneWithoutVerifiedDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutProviderInput = {
    id?: string
    documentType: string
    filePath: string
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    verificationStatus?: $Enums.DocumentVerificationStatus
    verifiedById?: string | null
    rejectionReason?: string | null
  }

  export type DocumentCreateOrConnectWithoutProviderInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutProviderInput, DocumentUncheckedCreateWithoutProviderInput>
  }

  export type DocumentCreateManyProviderInputEnvelope = {
    data: DocumentCreateManyProviderInput | DocumentCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type BreakTimeCreateWithoutProviderInput = {
    id?: string
    name?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreakTimeUncheckedCreateWithoutProviderInput = {
    id?: string
    name?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BreakTimeCreateOrConnectWithoutProviderInput = {
    where: BreakTimeWhereUniqueInput
    create: XOR<BreakTimeCreateWithoutProviderInput, BreakTimeUncheckedCreateWithoutProviderInput>
  }

  export type BreakTimeCreateManyProviderInputEnvelope = {
    data: BreakTimeCreateManyProviderInput | BreakTimeCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutProviderInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
    appointment?: AppointmentCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutProviderInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    appointmentId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutProviderInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutProviderInput, NotificationUncheckedCreateWithoutProviderInput>
  }

  export type NotificationCreateManyProviderInputEnvelope = {
    data: NotificationCreateManyProviderInput | NotificationCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutProviderInput = {
    id?: string
    rating: number
    comment?: string | null
    isAnonymous?: boolean
    professionalismRating?: number | null
    cleanlinessRating?: number | null
    waitTimeRating?: number | null
    valueRating?: number | null
    providerResponse?: string | null
    respondedAt?: Date | string | null
    isEdited?: boolean
    editedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment: AppointmentCreateNestedOneWithoutReviewInput
    user: UserCreateNestedOneWithoutReviewsInput
    likes?: ReviewLikeCreateNestedManyWithoutReviewInput
  }

  export type ReviewUncheckedCreateWithoutProviderInput = {
    id?: string
    appointmentId: string
    userId: string
    rating: number
    comment?: string | null
    isAnonymous?: boolean
    professionalismRating?: number | null
    cleanlinessRating?: number | null
    waitTimeRating?: number | null
    valueRating?: number | null
    providerResponse?: string | null
    respondedAt?: Date | string | null
    isEdited?: boolean
    editedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: ReviewLikeUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewCreateOrConnectWithoutProviderInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutProviderInput, ReviewUncheckedCreateWithoutProviderInput>
  }

  export type ReviewCreateManyProviderInputEnvelope = {
    data: ReviewCreateManyProviderInput | ReviewCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type ProviderStatusHistoryCreateWithoutProviderInput = {
    id?: string
    fromStatus: $Enums.ProviderStatus
    toStatus: $Enums.ProviderStatus
    reason?: string | null
    createdAt?: Date | string
    changedBy: UserCreateNestedOneWithoutProviderStatusChangesInput
  }

  export type ProviderStatusHistoryUncheckedCreateWithoutProviderInput = {
    id?: string
    fromStatus: $Enums.ProviderStatus
    toStatus: $Enums.ProviderStatus
    reason?: string | null
    changedById: string
    createdAt?: Date | string
  }

  export type ProviderStatusHistoryCreateOrConnectWithoutProviderInput = {
    where: ProviderStatusHistoryWhereUniqueInput
    create: XOR<ProviderStatusHistoryCreateWithoutProviderInput, ProviderStatusHistoryUncheckedCreateWithoutProviderInput>
  }

  export type ProviderStatusHistoryCreateManyProviderInputEnvelope = {
    data: ProviderStatusHistoryCreateManyProviderInput | ProviderStatusHistoryCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutProviderInput = {
    update: XOR<UserUpdateWithoutProviderInput, UserUncheckedUpdateWithoutProviderInput>
    create: XOR<UserCreateWithoutProviderInput, UserUncheckedCreateWithoutProviderInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProviderInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProviderInput, UserUncheckedUpdateWithoutProviderInput>
  }

  export type UserUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    suspendedBy?: UserUpdateOneWithoutSuspendedUsersNestedInput
    suspendedUsers?: UserUpdateManyWithoutSuspendedByNestedInput
    verifiedProviders?: ProviderUpdateManyWithoutVerifierNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    cancelledAppointments?: AppointmentUpdateManyWithoutCancellerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    conversationsAsUser1?: ConversationUpdateManyWithoutUser1NestedInput
    conversationsAsUser2?: ConversationUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewLikes?: ReviewLikeUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUpdateManyWithoutRespondedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutAdminNestedInput
    providerStatusChanges?: ProviderStatusHistoryUpdateManyWithoutChangedByNestedInput
    verifiedDocuments?: DocumentUpdateManyWithoutVerifiedByNestedInput
  }

  export type UserUncheckedUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedById?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    suspendedUsers?: UserUncheckedUpdateManyWithoutSuspendedByNestedInput
    verifiedProviders?: ProviderUncheckedUpdateManyWithoutVerifierNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    cancelledAppointments?: AppointmentUncheckedUpdateManyWithoutCancellerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conversationsAsUser1?: ConversationUncheckedUpdateManyWithoutUser1NestedInput
    conversationsAsUser2?: ConversationUncheckedUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewLikes?: ReviewLikeUncheckedUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUncheckedUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUncheckedUpdateManyWithoutRespondedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminNestedInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    verifiedDocuments?: DocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
  }

  export type CategoryUpsertWithoutProvidersInput = {
    update: XOR<CategoryUpdateWithoutProvidersInput, CategoryUncheckedUpdateWithoutProvidersInput>
    create: XOR<CategoryCreateWithoutProvidersInput, CategoryUncheckedCreateWithoutProvidersInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutProvidersInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutProvidersInput, CategoryUncheckedUpdateWithoutProvidersInput>
  }

  export type CategoryUpdateWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutVerifiedProvidersInput = {
    update: XOR<UserUpdateWithoutVerifiedProvidersInput, UserUncheckedUpdateWithoutVerifiedProvidersInput>
    create: XOR<UserCreateWithoutVerifiedProvidersInput, UserUncheckedCreateWithoutVerifiedProvidersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVerifiedProvidersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVerifiedProvidersInput, UserUncheckedUpdateWithoutVerifiedProvidersInput>
  }

  export type UserUpdateWithoutVerifiedProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    suspendedBy?: UserUpdateOneWithoutSuspendedUsersNestedInput
    suspendedUsers?: UserUpdateManyWithoutSuspendedByNestedInput
    provider?: ProviderUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    cancelledAppointments?: AppointmentUpdateManyWithoutCancellerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    conversationsAsUser1?: ConversationUpdateManyWithoutUser1NestedInput
    conversationsAsUser2?: ConversationUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewLikes?: ReviewLikeUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUpdateManyWithoutRespondedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutAdminNestedInput
    providerStatusChanges?: ProviderStatusHistoryUpdateManyWithoutChangedByNestedInput
    verifiedDocuments?: DocumentUpdateManyWithoutVerifiedByNestedInput
  }

  export type UserUncheckedUpdateWithoutVerifiedProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedById?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    suspendedUsers?: UserUncheckedUpdateManyWithoutSuspendedByNestedInput
    provider?: ProviderUncheckedUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    cancelledAppointments?: AppointmentUncheckedUpdateManyWithoutCancellerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conversationsAsUser1?: ConversationUncheckedUpdateManyWithoutUser1NestedInput
    conversationsAsUser2?: ConversationUncheckedUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewLikes?: ReviewLikeUncheckedUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUncheckedUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUncheckedUpdateManyWithoutRespondedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminNestedInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    verifiedDocuments?: DocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
  }

  export type ServiceUpsertWithWhereUniqueWithoutProviderInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutProviderInput, ServiceUncheckedUpdateWithoutProviderInput>
    create: XOR<ServiceCreateWithoutProviderInput, ServiceUncheckedCreateWithoutProviderInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutProviderInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutProviderInput, ServiceUncheckedUpdateWithoutProviderInput>
  }

  export type ServiceUpdateManyWithWhereWithoutProviderInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutProviderInput>
  }

  export type ServiceScalarWhereInput = {
    AND?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    OR?: ServiceScalarWhereInput[]
    NOT?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    id?: StringFilter<"Service"> | string
    providerId?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    type?: EnumServiceTypeFilter<"Service"> | $Enums.ServiceType
    pricingModel?: EnumPricingModelFilter<"Service"> | $Enums.PricingModel
    fixedPrice?: IntFilter<"Service"> | number
    priceMin?: IntFilter<"Service"> | number
    priceMax?: IntFilter<"Service"> | number
    isActive?: BoolFilter<"Service"> | boolean
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
  }

  export type OperatingHourUpsertWithWhereUniqueWithoutProviderInput = {
    where: OperatingHourWhereUniqueInput
    update: XOR<OperatingHourUpdateWithoutProviderInput, OperatingHourUncheckedUpdateWithoutProviderInput>
    create: XOR<OperatingHourCreateWithoutProviderInput, OperatingHourUncheckedCreateWithoutProviderInput>
  }

  export type OperatingHourUpdateWithWhereUniqueWithoutProviderInput = {
    where: OperatingHourWhereUniqueInput
    data: XOR<OperatingHourUpdateWithoutProviderInput, OperatingHourUncheckedUpdateWithoutProviderInput>
  }

  export type OperatingHourUpdateManyWithWhereWithoutProviderInput = {
    where: OperatingHourScalarWhereInput
    data: XOR<OperatingHourUpdateManyMutationInput, OperatingHourUncheckedUpdateManyWithoutProviderInput>
  }

  export type OperatingHourScalarWhereInput = {
    AND?: OperatingHourScalarWhereInput | OperatingHourScalarWhereInput[]
    OR?: OperatingHourScalarWhereInput[]
    NOT?: OperatingHourScalarWhereInput | OperatingHourScalarWhereInput[]
    id?: StringFilter<"OperatingHour"> | string
    providerId?: StringFilter<"OperatingHour"> | string
    dayOfWeek?: IntFilter<"OperatingHour"> | number
    startTime?: StringNullableFilter<"OperatingHour"> | string | null
    endTime?: StringNullableFilter<"OperatingHour"> | string | null
    isClosed?: BoolFilter<"OperatingHour"> | boolean
    createdAt?: DateTimeFilter<"OperatingHour"> | Date | string
    updatedAt?: DateTimeFilter<"OperatingHour"> | Date | string
  }

  export type AppointmentUpsertWithWhereUniqueWithoutProviderInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutProviderInput, AppointmentUncheckedUpdateWithoutProviderInput>
    create: XOR<AppointmentCreateWithoutProviderInput, AppointmentUncheckedCreateWithoutProviderInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutProviderInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutProviderInput, AppointmentUncheckedUpdateWithoutProviderInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutProviderInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutProviderInput>
  }

  export type DocumentUpsertWithWhereUniqueWithoutProviderInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutProviderInput, DocumentUncheckedUpdateWithoutProviderInput>
    create: XOR<DocumentCreateWithoutProviderInput, DocumentUncheckedCreateWithoutProviderInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutProviderInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutProviderInput, DocumentUncheckedUpdateWithoutProviderInput>
  }

  export type DocumentUpdateManyWithWhereWithoutProviderInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutProviderInput>
  }

  export type BreakTimeUpsertWithWhereUniqueWithoutProviderInput = {
    where: BreakTimeWhereUniqueInput
    update: XOR<BreakTimeUpdateWithoutProviderInput, BreakTimeUncheckedUpdateWithoutProviderInput>
    create: XOR<BreakTimeCreateWithoutProviderInput, BreakTimeUncheckedCreateWithoutProviderInput>
  }

  export type BreakTimeUpdateWithWhereUniqueWithoutProviderInput = {
    where: BreakTimeWhereUniqueInput
    data: XOR<BreakTimeUpdateWithoutProviderInput, BreakTimeUncheckedUpdateWithoutProviderInput>
  }

  export type BreakTimeUpdateManyWithWhereWithoutProviderInput = {
    where: BreakTimeScalarWhereInput
    data: XOR<BreakTimeUpdateManyMutationInput, BreakTimeUncheckedUpdateManyWithoutProviderInput>
  }

  export type BreakTimeScalarWhereInput = {
    AND?: BreakTimeScalarWhereInput | BreakTimeScalarWhereInput[]
    OR?: BreakTimeScalarWhereInput[]
    NOT?: BreakTimeScalarWhereInput | BreakTimeScalarWhereInput[]
    id?: StringFilter<"BreakTime"> | string
    providerId?: StringFilter<"BreakTime"> | string
    name?: StringFilter<"BreakTime"> | string
    dayOfWeek?: IntFilter<"BreakTime"> | number
    startTime?: StringFilter<"BreakTime"> | string
    endTime?: StringFilter<"BreakTime"> | string
    createdAt?: DateTimeFilter<"BreakTime"> | Date | string
    updatedAt?: DateTimeFilter<"BreakTime"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutProviderInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutProviderInput, NotificationUncheckedUpdateWithoutProviderInput>
    create: XOR<NotificationCreateWithoutProviderInput, NotificationUncheckedCreateWithoutProviderInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutProviderInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutProviderInput, NotificationUncheckedUpdateWithoutProviderInput>
  }

  export type NotificationUpdateManyWithWhereWithoutProviderInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutProviderInput>
  }

  export type ReviewUpsertWithWhereUniqueWithoutProviderInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutProviderInput, ReviewUncheckedUpdateWithoutProviderInput>
    create: XOR<ReviewCreateWithoutProviderInput, ReviewUncheckedCreateWithoutProviderInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutProviderInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutProviderInput, ReviewUncheckedUpdateWithoutProviderInput>
  }

  export type ReviewUpdateManyWithWhereWithoutProviderInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutProviderInput>
  }

  export type ProviderStatusHistoryUpsertWithWhereUniqueWithoutProviderInput = {
    where: ProviderStatusHistoryWhereUniqueInput
    update: XOR<ProviderStatusHistoryUpdateWithoutProviderInput, ProviderStatusHistoryUncheckedUpdateWithoutProviderInput>
    create: XOR<ProviderStatusHistoryCreateWithoutProviderInput, ProviderStatusHistoryUncheckedCreateWithoutProviderInput>
  }

  export type ProviderStatusHistoryUpdateWithWhereUniqueWithoutProviderInput = {
    where: ProviderStatusHistoryWhereUniqueInput
    data: XOR<ProviderStatusHistoryUpdateWithoutProviderInput, ProviderStatusHistoryUncheckedUpdateWithoutProviderInput>
  }

  export type ProviderStatusHistoryUpdateManyWithWhereWithoutProviderInput = {
    where: ProviderStatusHistoryScalarWhereInput
    data: XOR<ProviderStatusHistoryUpdateManyMutationInput, ProviderStatusHistoryUncheckedUpdateManyWithoutProviderInput>
  }

  export type ProviderCreateWithoutServicesInput = {
    id?: string
    healthcareName: string
    description?: string | null
    phoneNumber?: string | null
    email?: string | null
    coverPhoto?: string | null
    status?: $Enums.ProviderStatus
    address: string
    city?: string
    province?: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    slotDuration?: number
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProviderInput
    category?: CategoryCreateNestedOneWithoutProvidersInput
    verifier?: UserCreateNestedOneWithoutVerifiedProvidersInput
    operatingHours?: OperatingHourCreateNestedManyWithoutProviderInput
    appointments?: AppointmentCreateNestedManyWithoutProviderInput
    documents?: DocumentCreateNestedManyWithoutProviderInput
    breakTimes?: BreakTimeCreateNestedManyWithoutProviderInput
    notifications?: NotificationCreateNestedManyWithoutProviderInput
    reviews?: ReviewCreateNestedManyWithoutProviderInput
    statusHistory?: ProviderStatusHistoryCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateWithoutServicesInput = {
    id?: string
    userId: string
    categoryId?: string | null
    verifiedBy?: string | null
    healthcareName: string
    description?: string | null
    phoneNumber?: string | null
    email?: string | null
    coverPhoto?: string | null
    status?: $Enums.ProviderStatus
    address: string
    city?: string
    province?: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    slotDuration?: number
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    operatingHours?: OperatingHourUncheckedCreateNestedManyWithoutProviderInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutProviderInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProviderInput
    breakTimes?: BreakTimeUncheckedCreateNestedManyWithoutProviderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutProviderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProviderInput
    statusHistory?: ProviderStatusHistoryUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderCreateOrConnectWithoutServicesInput = {
    where: ProviderWhereUniqueInput
    create: XOR<ProviderCreateWithoutServicesInput, ProviderUncheckedCreateWithoutServicesInput>
  }

  export type AppointmentServiceCreateWithoutServiceInput = {
    priceAtBooking: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment: AppointmentCreateNestedOneWithoutServicesInput
  }

  export type AppointmentServiceUncheckedCreateWithoutServiceInput = {
    appointmentId: string
    priceAtBooking: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentServiceCreateOrConnectWithoutServiceInput = {
    where: AppointmentServiceWhereUniqueInput
    create: XOR<AppointmentServiceCreateWithoutServiceInput, AppointmentServiceUncheckedCreateWithoutServiceInput>
  }

  export type AppointmentServiceCreateManyServiceInputEnvelope = {
    data: AppointmentServiceCreateManyServiceInput | AppointmentServiceCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ServicePackageCreateWithoutParentPackageInput = {
    createdAt?: Date | string
    childService: ServiceCreateNestedOneWithoutPartOfPackagesInput
  }

  export type ServicePackageUncheckedCreateWithoutParentPackageInput = {
    childServiceId: string
    createdAt?: Date | string
  }

  export type ServicePackageCreateOrConnectWithoutParentPackageInput = {
    where: ServicePackageWhereUniqueInput
    create: XOR<ServicePackageCreateWithoutParentPackageInput, ServicePackageUncheckedCreateWithoutParentPackageInput>
  }

  export type ServicePackageCreateManyParentPackageInputEnvelope = {
    data: ServicePackageCreateManyParentPackageInput | ServicePackageCreateManyParentPackageInput[]
    skipDuplicates?: boolean
  }

  export type ServicePackageCreateWithoutChildServiceInput = {
    createdAt?: Date | string
    parentPackage: ServiceCreateNestedOneWithoutIncludedServicesInput
  }

  export type ServicePackageUncheckedCreateWithoutChildServiceInput = {
    parentPackageId: string
    createdAt?: Date | string
  }

  export type ServicePackageCreateOrConnectWithoutChildServiceInput = {
    where: ServicePackageWhereUniqueInput
    create: XOR<ServicePackageCreateWithoutChildServiceInput, ServicePackageUncheckedCreateWithoutChildServiceInput>
  }

  export type ServicePackageCreateManyChildServiceInputEnvelope = {
    data: ServicePackageCreateManyChildServiceInput | ServicePackageCreateManyChildServiceInput[]
    skipDuplicates?: boolean
  }

  export type ServiceInsuranceCreateWithoutServiceInput = {
    insuranceProvider: InsuranceProviderCreateNestedOneWithoutServicesInput
  }

  export type ServiceInsuranceUncheckedCreateWithoutServiceInput = {
    insuranceProviderId: string
  }

  export type ServiceInsuranceCreateOrConnectWithoutServiceInput = {
    where: ServiceInsuranceWhereUniqueInput
    create: XOR<ServiceInsuranceCreateWithoutServiceInput, ServiceInsuranceUncheckedCreateWithoutServiceInput>
  }

  export type ServiceInsuranceCreateManyServiceInputEnvelope = {
    data: ServiceInsuranceCreateManyServiceInput | ServiceInsuranceCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ProviderUpsertWithoutServicesInput = {
    update: XOR<ProviderUpdateWithoutServicesInput, ProviderUncheckedUpdateWithoutServicesInput>
    create: XOR<ProviderCreateWithoutServicesInput, ProviderUncheckedCreateWithoutServicesInput>
    where?: ProviderWhereInput
  }

  export type ProviderUpdateToOneWithWhereWithoutServicesInput = {
    where?: ProviderWhereInput
    data: XOR<ProviderUpdateWithoutServicesInput, ProviderUncheckedUpdateWithoutServicesInput>
  }

  export type ProviderUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    healthcareName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    slotDuration?: IntFieldUpdateOperationsInput | number
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProviderNestedInput
    category?: CategoryUpdateOneWithoutProvidersNestedInput
    verifier?: UserUpdateOneWithoutVerifiedProvidersNestedInput
    operatingHours?: OperatingHourUpdateManyWithoutProviderNestedInput
    appointments?: AppointmentUpdateManyWithoutProviderNestedInput
    documents?: DocumentUpdateManyWithoutProviderNestedInput
    breakTimes?: BreakTimeUpdateManyWithoutProviderNestedInput
    notifications?: NotificationUpdateManyWithoutProviderNestedInput
    reviews?: ReviewUpdateManyWithoutProviderNestedInput
    statusHistory?: ProviderStatusHistoryUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    healthcareName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    slotDuration?: IntFieldUpdateOperationsInput | number
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operatingHours?: OperatingHourUncheckedUpdateManyWithoutProviderNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutProviderNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProviderNestedInput
    breakTimes?: BreakTimeUncheckedUpdateManyWithoutProviderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutProviderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProviderNestedInput
    statusHistory?: ProviderStatusHistoryUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type AppointmentServiceUpsertWithWhereUniqueWithoutServiceInput = {
    where: AppointmentServiceWhereUniqueInput
    update: XOR<AppointmentServiceUpdateWithoutServiceInput, AppointmentServiceUncheckedUpdateWithoutServiceInput>
    create: XOR<AppointmentServiceCreateWithoutServiceInput, AppointmentServiceUncheckedCreateWithoutServiceInput>
  }

  export type AppointmentServiceUpdateWithWhereUniqueWithoutServiceInput = {
    where: AppointmentServiceWhereUniqueInput
    data: XOR<AppointmentServiceUpdateWithoutServiceInput, AppointmentServiceUncheckedUpdateWithoutServiceInput>
  }

  export type AppointmentServiceUpdateManyWithWhereWithoutServiceInput = {
    where: AppointmentServiceScalarWhereInput
    data: XOR<AppointmentServiceUpdateManyMutationInput, AppointmentServiceUncheckedUpdateManyWithoutServiceInput>
  }

  export type AppointmentServiceScalarWhereInput = {
    AND?: AppointmentServiceScalarWhereInput | AppointmentServiceScalarWhereInput[]
    OR?: AppointmentServiceScalarWhereInput[]
    NOT?: AppointmentServiceScalarWhereInput | AppointmentServiceScalarWhereInput[]
    appointmentId?: StringFilter<"AppointmentService"> | string
    serviceId?: StringFilter<"AppointmentService"> | string
    priceAtBooking?: DecimalFilter<"AppointmentService"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"AppointmentService"> | Date | string
    updatedAt?: DateTimeFilter<"AppointmentService"> | Date | string
  }

  export type ServicePackageUpsertWithWhereUniqueWithoutParentPackageInput = {
    where: ServicePackageWhereUniqueInput
    update: XOR<ServicePackageUpdateWithoutParentPackageInput, ServicePackageUncheckedUpdateWithoutParentPackageInput>
    create: XOR<ServicePackageCreateWithoutParentPackageInput, ServicePackageUncheckedCreateWithoutParentPackageInput>
  }

  export type ServicePackageUpdateWithWhereUniqueWithoutParentPackageInput = {
    where: ServicePackageWhereUniqueInput
    data: XOR<ServicePackageUpdateWithoutParentPackageInput, ServicePackageUncheckedUpdateWithoutParentPackageInput>
  }

  export type ServicePackageUpdateManyWithWhereWithoutParentPackageInput = {
    where: ServicePackageScalarWhereInput
    data: XOR<ServicePackageUpdateManyMutationInput, ServicePackageUncheckedUpdateManyWithoutParentPackageInput>
  }

  export type ServicePackageScalarWhereInput = {
    AND?: ServicePackageScalarWhereInput | ServicePackageScalarWhereInput[]
    OR?: ServicePackageScalarWhereInput[]
    NOT?: ServicePackageScalarWhereInput | ServicePackageScalarWhereInput[]
    parentPackageId?: StringFilter<"ServicePackage"> | string
    childServiceId?: StringFilter<"ServicePackage"> | string
    createdAt?: DateTimeFilter<"ServicePackage"> | Date | string
  }

  export type ServicePackageUpsertWithWhereUniqueWithoutChildServiceInput = {
    where: ServicePackageWhereUniqueInput
    update: XOR<ServicePackageUpdateWithoutChildServiceInput, ServicePackageUncheckedUpdateWithoutChildServiceInput>
    create: XOR<ServicePackageCreateWithoutChildServiceInput, ServicePackageUncheckedCreateWithoutChildServiceInput>
  }

  export type ServicePackageUpdateWithWhereUniqueWithoutChildServiceInput = {
    where: ServicePackageWhereUniqueInput
    data: XOR<ServicePackageUpdateWithoutChildServiceInput, ServicePackageUncheckedUpdateWithoutChildServiceInput>
  }

  export type ServicePackageUpdateManyWithWhereWithoutChildServiceInput = {
    where: ServicePackageScalarWhereInput
    data: XOR<ServicePackageUpdateManyMutationInput, ServicePackageUncheckedUpdateManyWithoutChildServiceInput>
  }

  export type ServiceInsuranceUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceInsuranceWhereUniqueInput
    update: XOR<ServiceInsuranceUpdateWithoutServiceInput, ServiceInsuranceUncheckedUpdateWithoutServiceInput>
    create: XOR<ServiceInsuranceCreateWithoutServiceInput, ServiceInsuranceUncheckedCreateWithoutServiceInput>
  }

  export type ServiceInsuranceUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceInsuranceWhereUniqueInput
    data: XOR<ServiceInsuranceUpdateWithoutServiceInput, ServiceInsuranceUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceInsuranceUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceInsuranceScalarWhereInput
    data: XOR<ServiceInsuranceUpdateManyMutationInput, ServiceInsuranceUncheckedUpdateManyWithoutServiceInput>
  }

  export type ServiceInsuranceScalarWhereInput = {
    AND?: ServiceInsuranceScalarWhereInput | ServiceInsuranceScalarWhereInput[]
    OR?: ServiceInsuranceScalarWhereInput[]
    NOT?: ServiceInsuranceScalarWhereInput | ServiceInsuranceScalarWhereInput[]
    serviceId?: StringFilter<"ServiceInsurance"> | string
    insuranceProviderId?: StringFilter<"ServiceInsurance"> | string
  }

  export type ServiceCreateWithoutIncludedServicesInput = {
    id?: string
    name: string
    description?: string | null
    type?: $Enums.ServiceType
    pricingModel?: $Enums.PricingModel
    fixedPrice?: number
    priceMin?: number
    priceMax?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: ProviderCreateNestedOneWithoutServicesInput
    appointments?: AppointmentServiceCreateNestedManyWithoutServiceInput
    partOfPackages?: ServicePackageCreateNestedManyWithoutChildServiceInput
    acceptedInsurances?: ServiceInsuranceCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutIncludedServicesInput = {
    id?: string
    providerId: string
    name: string
    description?: string | null
    type?: $Enums.ServiceType
    pricingModel?: $Enums.PricingModel
    fixedPrice?: number
    priceMin?: number
    priceMax?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentServiceUncheckedCreateNestedManyWithoutServiceInput
    partOfPackages?: ServicePackageUncheckedCreateNestedManyWithoutChildServiceInput
    acceptedInsurances?: ServiceInsuranceUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutIncludedServicesInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutIncludedServicesInput, ServiceUncheckedCreateWithoutIncludedServicesInput>
  }

  export type ServiceCreateWithoutPartOfPackagesInput = {
    id?: string
    name: string
    description?: string | null
    type?: $Enums.ServiceType
    pricingModel?: $Enums.PricingModel
    fixedPrice?: number
    priceMin?: number
    priceMax?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: ProviderCreateNestedOneWithoutServicesInput
    appointments?: AppointmentServiceCreateNestedManyWithoutServiceInput
    includedServices?: ServicePackageCreateNestedManyWithoutParentPackageInput
    acceptedInsurances?: ServiceInsuranceCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutPartOfPackagesInput = {
    id?: string
    providerId: string
    name: string
    description?: string | null
    type?: $Enums.ServiceType
    pricingModel?: $Enums.PricingModel
    fixedPrice?: number
    priceMin?: number
    priceMax?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentServiceUncheckedCreateNestedManyWithoutServiceInput
    includedServices?: ServicePackageUncheckedCreateNestedManyWithoutParentPackageInput
    acceptedInsurances?: ServiceInsuranceUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutPartOfPackagesInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutPartOfPackagesInput, ServiceUncheckedCreateWithoutPartOfPackagesInput>
  }

  export type ServiceUpsertWithoutIncludedServicesInput = {
    update: XOR<ServiceUpdateWithoutIncludedServicesInput, ServiceUncheckedUpdateWithoutIncludedServicesInput>
    create: XOR<ServiceCreateWithoutIncludedServicesInput, ServiceUncheckedCreateWithoutIncludedServicesInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutIncludedServicesInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutIncludedServicesInput, ServiceUncheckedUpdateWithoutIncludedServicesInput>
  }

  export type ServiceUpdateWithoutIncludedServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    fixedPrice?: IntFieldUpdateOperationsInput | number
    priceMin?: IntFieldUpdateOperationsInput | number
    priceMax?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: ProviderUpdateOneRequiredWithoutServicesNestedInput
    appointments?: AppointmentServiceUpdateManyWithoutServiceNestedInput
    partOfPackages?: ServicePackageUpdateManyWithoutChildServiceNestedInput
    acceptedInsurances?: ServiceInsuranceUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutIncludedServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    fixedPrice?: IntFieldUpdateOperationsInput | number
    priceMin?: IntFieldUpdateOperationsInput | number
    priceMax?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentServiceUncheckedUpdateManyWithoutServiceNestedInput
    partOfPackages?: ServicePackageUncheckedUpdateManyWithoutChildServiceNestedInput
    acceptedInsurances?: ServiceInsuranceUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUpsertWithoutPartOfPackagesInput = {
    update: XOR<ServiceUpdateWithoutPartOfPackagesInput, ServiceUncheckedUpdateWithoutPartOfPackagesInput>
    create: XOR<ServiceCreateWithoutPartOfPackagesInput, ServiceUncheckedCreateWithoutPartOfPackagesInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutPartOfPackagesInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutPartOfPackagesInput, ServiceUncheckedUpdateWithoutPartOfPackagesInput>
  }

  export type ServiceUpdateWithoutPartOfPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    fixedPrice?: IntFieldUpdateOperationsInput | number
    priceMin?: IntFieldUpdateOperationsInput | number
    priceMax?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: ProviderUpdateOneRequiredWithoutServicesNestedInput
    appointments?: AppointmentServiceUpdateManyWithoutServiceNestedInput
    includedServices?: ServicePackageUpdateManyWithoutParentPackageNestedInput
    acceptedInsurances?: ServiceInsuranceUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutPartOfPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    fixedPrice?: IntFieldUpdateOperationsInput | number
    priceMin?: IntFieldUpdateOperationsInput | number
    priceMax?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentServiceUncheckedUpdateManyWithoutServiceNestedInput
    includedServices?: ServicePackageUncheckedUpdateManyWithoutParentPackageNestedInput
    acceptedInsurances?: ServiceInsuranceUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceInsuranceCreateWithoutInsuranceProviderInput = {
    service: ServiceCreateNestedOneWithoutAcceptedInsurancesInput
  }

  export type ServiceInsuranceUncheckedCreateWithoutInsuranceProviderInput = {
    serviceId: string
  }

  export type ServiceInsuranceCreateOrConnectWithoutInsuranceProviderInput = {
    where: ServiceInsuranceWhereUniqueInput
    create: XOR<ServiceInsuranceCreateWithoutInsuranceProviderInput, ServiceInsuranceUncheckedCreateWithoutInsuranceProviderInput>
  }

  export type ServiceInsuranceCreateManyInsuranceProviderInputEnvelope = {
    data: ServiceInsuranceCreateManyInsuranceProviderInput | ServiceInsuranceCreateManyInsuranceProviderInput[]
    skipDuplicates?: boolean
  }

  export type ServiceInsuranceUpsertWithWhereUniqueWithoutInsuranceProviderInput = {
    where: ServiceInsuranceWhereUniqueInput
    update: XOR<ServiceInsuranceUpdateWithoutInsuranceProviderInput, ServiceInsuranceUncheckedUpdateWithoutInsuranceProviderInput>
    create: XOR<ServiceInsuranceCreateWithoutInsuranceProviderInput, ServiceInsuranceUncheckedCreateWithoutInsuranceProviderInput>
  }

  export type ServiceInsuranceUpdateWithWhereUniqueWithoutInsuranceProviderInput = {
    where: ServiceInsuranceWhereUniqueInput
    data: XOR<ServiceInsuranceUpdateWithoutInsuranceProviderInput, ServiceInsuranceUncheckedUpdateWithoutInsuranceProviderInput>
  }

  export type ServiceInsuranceUpdateManyWithWhereWithoutInsuranceProviderInput = {
    where: ServiceInsuranceScalarWhereInput
    data: XOR<ServiceInsuranceUpdateManyMutationInput, ServiceInsuranceUncheckedUpdateManyWithoutInsuranceProviderInput>
  }

  export type ServiceCreateWithoutAcceptedInsurancesInput = {
    id?: string
    name: string
    description?: string | null
    type?: $Enums.ServiceType
    pricingModel?: $Enums.PricingModel
    fixedPrice?: number
    priceMin?: number
    priceMax?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: ProviderCreateNestedOneWithoutServicesInput
    appointments?: AppointmentServiceCreateNestedManyWithoutServiceInput
    includedServices?: ServicePackageCreateNestedManyWithoutParentPackageInput
    partOfPackages?: ServicePackageCreateNestedManyWithoutChildServiceInput
  }

  export type ServiceUncheckedCreateWithoutAcceptedInsurancesInput = {
    id?: string
    providerId: string
    name: string
    description?: string | null
    type?: $Enums.ServiceType
    pricingModel?: $Enums.PricingModel
    fixedPrice?: number
    priceMin?: number
    priceMax?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentServiceUncheckedCreateNestedManyWithoutServiceInput
    includedServices?: ServicePackageUncheckedCreateNestedManyWithoutParentPackageInput
    partOfPackages?: ServicePackageUncheckedCreateNestedManyWithoutChildServiceInput
  }

  export type ServiceCreateOrConnectWithoutAcceptedInsurancesInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutAcceptedInsurancesInput, ServiceUncheckedCreateWithoutAcceptedInsurancesInput>
  }

  export type InsuranceProviderCreateWithoutServicesInput = {
    id?: string
    name: string
    isActive?: boolean
  }

  export type InsuranceProviderUncheckedCreateWithoutServicesInput = {
    id?: string
    name: string
    isActive?: boolean
  }

  export type InsuranceProviderCreateOrConnectWithoutServicesInput = {
    where: InsuranceProviderWhereUniqueInput
    create: XOR<InsuranceProviderCreateWithoutServicesInput, InsuranceProviderUncheckedCreateWithoutServicesInput>
  }

  export type ServiceUpsertWithoutAcceptedInsurancesInput = {
    update: XOR<ServiceUpdateWithoutAcceptedInsurancesInput, ServiceUncheckedUpdateWithoutAcceptedInsurancesInput>
    create: XOR<ServiceCreateWithoutAcceptedInsurancesInput, ServiceUncheckedCreateWithoutAcceptedInsurancesInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutAcceptedInsurancesInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutAcceptedInsurancesInput, ServiceUncheckedUpdateWithoutAcceptedInsurancesInput>
  }

  export type ServiceUpdateWithoutAcceptedInsurancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    fixedPrice?: IntFieldUpdateOperationsInput | number
    priceMin?: IntFieldUpdateOperationsInput | number
    priceMax?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: ProviderUpdateOneRequiredWithoutServicesNestedInput
    appointments?: AppointmentServiceUpdateManyWithoutServiceNestedInput
    includedServices?: ServicePackageUpdateManyWithoutParentPackageNestedInput
    partOfPackages?: ServicePackageUpdateManyWithoutChildServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutAcceptedInsurancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    fixedPrice?: IntFieldUpdateOperationsInput | number
    priceMin?: IntFieldUpdateOperationsInput | number
    priceMax?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentServiceUncheckedUpdateManyWithoutServiceNestedInput
    includedServices?: ServicePackageUncheckedUpdateManyWithoutParentPackageNestedInput
    partOfPackages?: ServicePackageUncheckedUpdateManyWithoutChildServiceNestedInput
  }

  export type InsuranceProviderUpsertWithoutServicesInput = {
    update: XOR<InsuranceProviderUpdateWithoutServicesInput, InsuranceProviderUncheckedUpdateWithoutServicesInput>
    create: XOR<InsuranceProviderCreateWithoutServicesInput, InsuranceProviderUncheckedCreateWithoutServicesInput>
    where?: InsuranceProviderWhereInput
  }

  export type InsuranceProviderUpdateToOneWithWhereWithoutServicesInput = {
    where?: InsuranceProviderWhereInput
    data: XOR<InsuranceProviderUpdateWithoutServicesInput, InsuranceProviderUncheckedUpdateWithoutServicesInput>
  }

  export type InsuranceProviderUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InsuranceProviderUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProviderCreateWithoutOperatingHoursInput = {
    id?: string
    healthcareName: string
    description?: string | null
    phoneNumber?: string | null
    email?: string | null
    coverPhoto?: string | null
    status?: $Enums.ProviderStatus
    address: string
    city?: string
    province?: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    slotDuration?: number
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProviderInput
    category?: CategoryCreateNestedOneWithoutProvidersInput
    verifier?: UserCreateNestedOneWithoutVerifiedProvidersInput
    services?: ServiceCreateNestedManyWithoutProviderInput
    appointments?: AppointmentCreateNestedManyWithoutProviderInput
    documents?: DocumentCreateNestedManyWithoutProviderInput
    breakTimes?: BreakTimeCreateNestedManyWithoutProviderInput
    notifications?: NotificationCreateNestedManyWithoutProviderInput
    reviews?: ReviewCreateNestedManyWithoutProviderInput
    statusHistory?: ProviderStatusHistoryCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateWithoutOperatingHoursInput = {
    id?: string
    userId: string
    categoryId?: string | null
    verifiedBy?: string | null
    healthcareName: string
    description?: string | null
    phoneNumber?: string | null
    email?: string | null
    coverPhoto?: string | null
    status?: $Enums.ProviderStatus
    address: string
    city?: string
    province?: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    slotDuration?: number
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutProviderInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutProviderInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProviderInput
    breakTimes?: BreakTimeUncheckedCreateNestedManyWithoutProviderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutProviderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProviderInput
    statusHistory?: ProviderStatusHistoryUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderCreateOrConnectWithoutOperatingHoursInput = {
    where: ProviderWhereUniqueInput
    create: XOR<ProviderCreateWithoutOperatingHoursInput, ProviderUncheckedCreateWithoutOperatingHoursInput>
  }

  export type ProviderUpsertWithoutOperatingHoursInput = {
    update: XOR<ProviderUpdateWithoutOperatingHoursInput, ProviderUncheckedUpdateWithoutOperatingHoursInput>
    create: XOR<ProviderCreateWithoutOperatingHoursInput, ProviderUncheckedCreateWithoutOperatingHoursInput>
    where?: ProviderWhereInput
  }

  export type ProviderUpdateToOneWithWhereWithoutOperatingHoursInput = {
    where?: ProviderWhereInput
    data: XOR<ProviderUpdateWithoutOperatingHoursInput, ProviderUncheckedUpdateWithoutOperatingHoursInput>
  }

  export type ProviderUpdateWithoutOperatingHoursInput = {
    id?: StringFieldUpdateOperationsInput | string
    healthcareName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    slotDuration?: IntFieldUpdateOperationsInput | number
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProviderNestedInput
    category?: CategoryUpdateOneWithoutProvidersNestedInput
    verifier?: UserUpdateOneWithoutVerifiedProvidersNestedInput
    services?: ServiceUpdateManyWithoutProviderNestedInput
    appointments?: AppointmentUpdateManyWithoutProviderNestedInput
    documents?: DocumentUpdateManyWithoutProviderNestedInput
    breakTimes?: BreakTimeUpdateManyWithoutProviderNestedInput
    notifications?: NotificationUpdateManyWithoutProviderNestedInput
    reviews?: ReviewUpdateManyWithoutProviderNestedInput
    statusHistory?: ProviderStatusHistoryUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateWithoutOperatingHoursInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    healthcareName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    slotDuration?: IntFieldUpdateOperationsInput | number
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutProviderNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutProviderNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProviderNestedInput
    breakTimes?: BreakTimeUncheckedUpdateManyWithoutProviderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutProviderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProviderNestedInput
    statusHistory?: ProviderStatusHistoryUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type ProviderCreateWithoutBreakTimesInput = {
    id?: string
    healthcareName: string
    description?: string | null
    phoneNumber?: string | null
    email?: string | null
    coverPhoto?: string | null
    status?: $Enums.ProviderStatus
    address: string
    city?: string
    province?: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    slotDuration?: number
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProviderInput
    category?: CategoryCreateNestedOneWithoutProvidersInput
    verifier?: UserCreateNestedOneWithoutVerifiedProvidersInput
    services?: ServiceCreateNestedManyWithoutProviderInput
    operatingHours?: OperatingHourCreateNestedManyWithoutProviderInput
    appointments?: AppointmentCreateNestedManyWithoutProviderInput
    documents?: DocumentCreateNestedManyWithoutProviderInput
    notifications?: NotificationCreateNestedManyWithoutProviderInput
    reviews?: ReviewCreateNestedManyWithoutProviderInput
    statusHistory?: ProviderStatusHistoryCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateWithoutBreakTimesInput = {
    id?: string
    userId: string
    categoryId?: string | null
    verifiedBy?: string | null
    healthcareName: string
    description?: string | null
    phoneNumber?: string | null
    email?: string | null
    coverPhoto?: string | null
    status?: $Enums.ProviderStatus
    address: string
    city?: string
    province?: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    slotDuration?: number
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutProviderInput
    operatingHours?: OperatingHourUncheckedCreateNestedManyWithoutProviderInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutProviderInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProviderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutProviderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProviderInput
    statusHistory?: ProviderStatusHistoryUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderCreateOrConnectWithoutBreakTimesInput = {
    where: ProviderWhereUniqueInput
    create: XOR<ProviderCreateWithoutBreakTimesInput, ProviderUncheckedCreateWithoutBreakTimesInput>
  }

  export type ProviderUpsertWithoutBreakTimesInput = {
    update: XOR<ProviderUpdateWithoutBreakTimesInput, ProviderUncheckedUpdateWithoutBreakTimesInput>
    create: XOR<ProviderCreateWithoutBreakTimesInput, ProviderUncheckedCreateWithoutBreakTimesInput>
    where?: ProviderWhereInput
  }

  export type ProviderUpdateToOneWithWhereWithoutBreakTimesInput = {
    where?: ProviderWhereInput
    data: XOR<ProviderUpdateWithoutBreakTimesInput, ProviderUncheckedUpdateWithoutBreakTimesInput>
  }

  export type ProviderUpdateWithoutBreakTimesInput = {
    id?: StringFieldUpdateOperationsInput | string
    healthcareName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    slotDuration?: IntFieldUpdateOperationsInput | number
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProviderNestedInput
    category?: CategoryUpdateOneWithoutProvidersNestedInput
    verifier?: UserUpdateOneWithoutVerifiedProvidersNestedInput
    services?: ServiceUpdateManyWithoutProviderNestedInput
    operatingHours?: OperatingHourUpdateManyWithoutProviderNestedInput
    appointments?: AppointmentUpdateManyWithoutProviderNestedInput
    documents?: DocumentUpdateManyWithoutProviderNestedInput
    notifications?: NotificationUpdateManyWithoutProviderNestedInput
    reviews?: ReviewUpdateManyWithoutProviderNestedInput
    statusHistory?: ProviderStatusHistoryUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateWithoutBreakTimesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    healthcareName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    slotDuration?: IntFieldUpdateOperationsInput | number
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutProviderNestedInput
    operatingHours?: OperatingHourUncheckedUpdateManyWithoutProviderNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutProviderNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProviderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutProviderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProviderNestedInput
    statusHistory?: ProviderStatusHistoryUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type UserCreateWithoutAppointmentsInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    suspendedBy?: UserCreateNestedOneWithoutSuspendedUsersInput
    suspendedUsers?: UserCreateNestedManyWithoutSuspendedByInput
    provider?: ProviderCreateNestedOneWithoutUserInput
    verifiedProviders?: ProviderCreateNestedManyWithoutVerifierInput
    cancelledAppointments?: AppointmentCreateNestedManyWithoutCancellerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    conversationsAsUser1?: ConversationCreateNestedManyWithoutUser1Input
    conversationsAsUser2?: ConversationCreateNestedManyWithoutUser2Input
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewLikes?: ReviewLikeCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackCreateNestedManyWithoutRespondedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutAdminInput
    providerStatusChanges?: ProviderStatusHistoryCreateNestedManyWithoutChangedByInput
    verifiedDocuments?: DocumentCreateNestedManyWithoutVerifiedByInput
  }

  export type UserUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    suspendedById?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    suspendedUsers?: UserUncheckedCreateNestedManyWithoutSuspendedByInput
    provider?: ProviderUncheckedCreateNestedOneWithoutUserInput
    verifiedProviders?: ProviderUncheckedCreateNestedManyWithoutVerifierInput
    cancelledAppointments?: AppointmentUncheckedCreateNestedManyWithoutCancellerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conversationsAsUser1?: ConversationUncheckedCreateNestedManyWithoutUser1Input
    conversationsAsUser2?: ConversationUncheckedCreateNestedManyWithoutUser2Input
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewLikes?: ReviewLikeUncheckedCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackUncheckedCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackUncheckedCreateNestedManyWithoutRespondedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    verifiedDocuments?: DocumentUncheckedCreateNestedManyWithoutVerifiedByInput
  }

  export type UserCreateOrConnectWithoutAppointmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAppointmentsInput, UserUncheckedCreateWithoutAppointmentsInput>
  }

  export type ProviderCreateWithoutAppointmentsInput = {
    id?: string
    healthcareName: string
    description?: string | null
    phoneNumber?: string | null
    email?: string | null
    coverPhoto?: string | null
    status?: $Enums.ProviderStatus
    address: string
    city?: string
    province?: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    slotDuration?: number
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProviderInput
    category?: CategoryCreateNestedOneWithoutProvidersInput
    verifier?: UserCreateNestedOneWithoutVerifiedProvidersInput
    services?: ServiceCreateNestedManyWithoutProviderInput
    operatingHours?: OperatingHourCreateNestedManyWithoutProviderInput
    documents?: DocumentCreateNestedManyWithoutProviderInput
    breakTimes?: BreakTimeCreateNestedManyWithoutProviderInput
    notifications?: NotificationCreateNestedManyWithoutProviderInput
    reviews?: ReviewCreateNestedManyWithoutProviderInput
    statusHistory?: ProviderStatusHistoryCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    userId: string
    categoryId?: string | null
    verifiedBy?: string | null
    healthcareName: string
    description?: string | null
    phoneNumber?: string | null
    email?: string | null
    coverPhoto?: string | null
    status?: $Enums.ProviderStatus
    address: string
    city?: string
    province?: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    slotDuration?: number
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutProviderInput
    operatingHours?: OperatingHourUncheckedCreateNestedManyWithoutProviderInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProviderInput
    breakTimes?: BreakTimeUncheckedCreateNestedManyWithoutProviderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutProviderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProviderInput
    statusHistory?: ProviderStatusHistoryUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderCreateOrConnectWithoutAppointmentsInput = {
    where: ProviderWhereUniqueInput
    create: XOR<ProviderCreateWithoutAppointmentsInput, ProviderUncheckedCreateWithoutAppointmentsInput>
  }

  export type UserCreateWithoutCancelledAppointmentsInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    suspendedBy?: UserCreateNestedOneWithoutSuspendedUsersInput
    suspendedUsers?: UserCreateNestedManyWithoutSuspendedByInput
    provider?: ProviderCreateNestedOneWithoutUserInput
    verifiedProviders?: ProviderCreateNestedManyWithoutVerifierInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    conversationsAsUser1?: ConversationCreateNestedManyWithoutUser1Input
    conversationsAsUser2?: ConversationCreateNestedManyWithoutUser2Input
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewLikes?: ReviewLikeCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackCreateNestedManyWithoutRespondedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutAdminInput
    providerStatusChanges?: ProviderStatusHistoryCreateNestedManyWithoutChangedByInput
    verifiedDocuments?: DocumentCreateNestedManyWithoutVerifiedByInput
  }

  export type UserUncheckedCreateWithoutCancelledAppointmentsInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    suspendedById?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    suspendedUsers?: UserUncheckedCreateNestedManyWithoutSuspendedByInput
    provider?: ProviderUncheckedCreateNestedOneWithoutUserInput
    verifiedProviders?: ProviderUncheckedCreateNestedManyWithoutVerifierInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conversationsAsUser1?: ConversationUncheckedCreateNestedManyWithoutUser1Input
    conversationsAsUser2?: ConversationUncheckedCreateNestedManyWithoutUser2Input
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewLikes?: ReviewLikeUncheckedCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackUncheckedCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackUncheckedCreateNestedManyWithoutRespondedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    verifiedDocuments?: DocumentUncheckedCreateNestedManyWithoutVerifiedByInput
  }

  export type UserCreateOrConnectWithoutCancelledAppointmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCancelledAppointmentsInput, UserUncheckedCreateWithoutCancelledAppointmentsInput>
  }

  export type AppointmentServiceCreateWithoutAppointmentInput = {
    priceAtBooking: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    service: ServiceCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentServiceUncheckedCreateWithoutAppointmentInput = {
    serviceId: string
    priceAtBooking: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentServiceCreateOrConnectWithoutAppointmentInput = {
    where: AppointmentServiceWhereUniqueInput
    create: XOR<AppointmentServiceCreateWithoutAppointmentInput, AppointmentServiceUncheckedCreateWithoutAppointmentInput>
  }

  export type AppointmentServiceCreateManyAppointmentInputEnvelope = {
    data: AppointmentServiceCreateManyAppointmentInput | AppointmentServiceCreateManyAppointmentInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutAppointmentInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
    provider?: ProviderCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutAppointmentInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    providerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutAppointmentInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutAppointmentInput, NotificationUncheckedCreateWithoutAppointmentInput>
  }

  export type NotificationCreateManyAppointmentInputEnvelope = {
    data: NotificationCreateManyAppointmentInput | NotificationCreateManyAppointmentInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutAppointmentInput = {
    id?: string
    rating: number
    comment?: string | null
    isAnonymous?: boolean
    professionalismRating?: number | null
    cleanlinessRating?: number | null
    waitTimeRating?: number | null
    valueRating?: number | null
    providerResponse?: string | null
    respondedAt?: Date | string | null
    isEdited?: boolean
    editedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReviewsInput
    provider: ProviderCreateNestedOneWithoutReviewsInput
    likes?: ReviewLikeCreateNestedManyWithoutReviewInput
  }

  export type ReviewUncheckedCreateWithoutAppointmentInput = {
    id?: string
    userId: string
    providerId: string
    rating: number
    comment?: string | null
    isAnonymous?: boolean
    professionalismRating?: number | null
    cleanlinessRating?: number | null
    waitTimeRating?: number | null
    valueRating?: number | null
    providerResponse?: string | null
    respondedAt?: Date | string | null
    isEdited?: boolean
    editedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: ReviewLikeUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewCreateOrConnectWithoutAppointmentInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutAppointmentInput, ReviewUncheckedCreateWithoutAppointmentInput>
  }

  export type UserUpsertWithoutAppointmentsInput = {
    update: XOR<UserUpdateWithoutAppointmentsInput, UserUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<UserCreateWithoutAppointmentsInput, UserUncheckedCreateWithoutAppointmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAppointmentsInput, UserUncheckedUpdateWithoutAppointmentsInput>
  }

  export type UserUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    suspendedBy?: UserUpdateOneWithoutSuspendedUsersNestedInput
    suspendedUsers?: UserUpdateManyWithoutSuspendedByNestedInput
    provider?: ProviderUpdateOneWithoutUserNestedInput
    verifiedProviders?: ProviderUpdateManyWithoutVerifierNestedInput
    cancelledAppointments?: AppointmentUpdateManyWithoutCancellerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    conversationsAsUser1?: ConversationUpdateManyWithoutUser1NestedInput
    conversationsAsUser2?: ConversationUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewLikes?: ReviewLikeUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUpdateManyWithoutRespondedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutAdminNestedInput
    providerStatusChanges?: ProviderStatusHistoryUpdateManyWithoutChangedByNestedInput
    verifiedDocuments?: DocumentUpdateManyWithoutVerifiedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedById?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    suspendedUsers?: UserUncheckedUpdateManyWithoutSuspendedByNestedInput
    provider?: ProviderUncheckedUpdateOneWithoutUserNestedInput
    verifiedProviders?: ProviderUncheckedUpdateManyWithoutVerifierNestedInput
    cancelledAppointments?: AppointmentUncheckedUpdateManyWithoutCancellerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conversationsAsUser1?: ConversationUncheckedUpdateManyWithoutUser1NestedInput
    conversationsAsUser2?: ConversationUncheckedUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewLikes?: ReviewLikeUncheckedUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUncheckedUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUncheckedUpdateManyWithoutRespondedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminNestedInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    verifiedDocuments?: DocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
  }

  export type ProviderUpsertWithoutAppointmentsInput = {
    update: XOR<ProviderUpdateWithoutAppointmentsInput, ProviderUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<ProviderCreateWithoutAppointmentsInput, ProviderUncheckedCreateWithoutAppointmentsInput>
    where?: ProviderWhereInput
  }

  export type ProviderUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: ProviderWhereInput
    data: XOR<ProviderUpdateWithoutAppointmentsInput, ProviderUncheckedUpdateWithoutAppointmentsInput>
  }

  export type ProviderUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    healthcareName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    slotDuration?: IntFieldUpdateOperationsInput | number
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProviderNestedInput
    category?: CategoryUpdateOneWithoutProvidersNestedInput
    verifier?: UserUpdateOneWithoutVerifiedProvidersNestedInput
    services?: ServiceUpdateManyWithoutProviderNestedInput
    operatingHours?: OperatingHourUpdateManyWithoutProviderNestedInput
    documents?: DocumentUpdateManyWithoutProviderNestedInput
    breakTimes?: BreakTimeUpdateManyWithoutProviderNestedInput
    notifications?: NotificationUpdateManyWithoutProviderNestedInput
    reviews?: ReviewUpdateManyWithoutProviderNestedInput
    statusHistory?: ProviderStatusHistoryUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    healthcareName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    slotDuration?: IntFieldUpdateOperationsInput | number
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutProviderNestedInput
    operatingHours?: OperatingHourUncheckedUpdateManyWithoutProviderNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProviderNestedInput
    breakTimes?: BreakTimeUncheckedUpdateManyWithoutProviderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutProviderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProviderNestedInput
    statusHistory?: ProviderStatusHistoryUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type UserUpsertWithoutCancelledAppointmentsInput = {
    update: XOR<UserUpdateWithoutCancelledAppointmentsInput, UserUncheckedUpdateWithoutCancelledAppointmentsInput>
    create: XOR<UserCreateWithoutCancelledAppointmentsInput, UserUncheckedCreateWithoutCancelledAppointmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCancelledAppointmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCancelledAppointmentsInput, UserUncheckedUpdateWithoutCancelledAppointmentsInput>
  }

  export type UserUpdateWithoutCancelledAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    suspendedBy?: UserUpdateOneWithoutSuspendedUsersNestedInput
    suspendedUsers?: UserUpdateManyWithoutSuspendedByNestedInput
    provider?: ProviderUpdateOneWithoutUserNestedInput
    verifiedProviders?: ProviderUpdateManyWithoutVerifierNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    conversationsAsUser1?: ConversationUpdateManyWithoutUser1NestedInput
    conversationsAsUser2?: ConversationUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewLikes?: ReviewLikeUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUpdateManyWithoutRespondedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutAdminNestedInput
    providerStatusChanges?: ProviderStatusHistoryUpdateManyWithoutChangedByNestedInput
    verifiedDocuments?: DocumentUpdateManyWithoutVerifiedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCancelledAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedById?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    suspendedUsers?: UserUncheckedUpdateManyWithoutSuspendedByNestedInput
    provider?: ProviderUncheckedUpdateOneWithoutUserNestedInput
    verifiedProviders?: ProviderUncheckedUpdateManyWithoutVerifierNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conversationsAsUser1?: ConversationUncheckedUpdateManyWithoutUser1NestedInput
    conversationsAsUser2?: ConversationUncheckedUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewLikes?: ReviewLikeUncheckedUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUncheckedUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUncheckedUpdateManyWithoutRespondedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminNestedInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    verifiedDocuments?: DocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
  }

  export type AppointmentServiceUpsertWithWhereUniqueWithoutAppointmentInput = {
    where: AppointmentServiceWhereUniqueInput
    update: XOR<AppointmentServiceUpdateWithoutAppointmentInput, AppointmentServiceUncheckedUpdateWithoutAppointmentInput>
    create: XOR<AppointmentServiceCreateWithoutAppointmentInput, AppointmentServiceUncheckedCreateWithoutAppointmentInput>
  }

  export type AppointmentServiceUpdateWithWhereUniqueWithoutAppointmentInput = {
    where: AppointmentServiceWhereUniqueInput
    data: XOR<AppointmentServiceUpdateWithoutAppointmentInput, AppointmentServiceUncheckedUpdateWithoutAppointmentInput>
  }

  export type AppointmentServiceUpdateManyWithWhereWithoutAppointmentInput = {
    where: AppointmentServiceScalarWhereInput
    data: XOR<AppointmentServiceUpdateManyMutationInput, AppointmentServiceUncheckedUpdateManyWithoutAppointmentInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutAppointmentInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutAppointmentInput, NotificationUncheckedUpdateWithoutAppointmentInput>
    create: XOR<NotificationCreateWithoutAppointmentInput, NotificationUncheckedCreateWithoutAppointmentInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutAppointmentInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutAppointmentInput, NotificationUncheckedUpdateWithoutAppointmentInput>
  }

  export type NotificationUpdateManyWithWhereWithoutAppointmentInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutAppointmentInput>
  }

  export type ReviewUpsertWithoutAppointmentInput = {
    update: XOR<ReviewUpdateWithoutAppointmentInput, ReviewUncheckedUpdateWithoutAppointmentInput>
    create: XOR<ReviewCreateWithoutAppointmentInput, ReviewUncheckedCreateWithoutAppointmentInput>
    where?: ReviewWhereInput
  }

  export type ReviewUpdateToOneWithWhereWithoutAppointmentInput = {
    where?: ReviewWhereInput
    data: XOR<ReviewUpdateWithoutAppointmentInput, ReviewUncheckedUpdateWithoutAppointmentInput>
  }

  export type ReviewUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    professionalismRating?: NullableIntFieldUpdateOperationsInput | number | null
    cleanlinessRating?: NullableIntFieldUpdateOperationsInput | number | null
    waitTimeRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueRating?: NullableIntFieldUpdateOperationsInput | number | null
    providerResponse?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    provider?: ProviderUpdateOneRequiredWithoutReviewsNestedInput
    likes?: ReviewLikeUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    professionalismRating?: NullableIntFieldUpdateOperationsInput | number | null
    cleanlinessRating?: NullableIntFieldUpdateOperationsInput | number | null
    waitTimeRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueRating?: NullableIntFieldUpdateOperationsInput | number | null
    providerResponse?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: ReviewLikeUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type AppointmentCreateWithoutServicesInput = {
    id?: string
    appointmentNumber: string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.AppointmentStatus
    notes?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    patientName: string
    patientEmail: string
    patientPhone?: string | null
    activityNotes?: string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAppointmentsInput
    provider: ProviderCreateNestedOneWithoutAppointmentsInput
    canceller?: UserCreateNestedOneWithoutCancelledAppointmentsInput
    notifications?: NotificationCreateNestedManyWithoutAppointmentInput
    review?: ReviewCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutServicesInput = {
    id?: string
    appointmentNumber: string
    userId: string
    providerId: string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.AppointmentStatus
    notes?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    patientName: string
    patientEmail: string
    patientPhone?: string | null
    activityNotes?: string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    cancelledBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutAppointmentInput
    review?: ReviewUncheckedCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutServicesInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutServicesInput, AppointmentUncheckedCreateWithoutServicesInput>
  }

  export type ServiceCreateWithoutAppointmentsInput = {
    id?: string
    name: string
    description?: string | null
    type?: $Enums.ServiceType
    pricingModel?: $Enums.PricingModel
    fixedPrice?: number
    priceMin?: number
    priceMax?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: ProviderCreateNestedOneWithoutServicesInput
    includedServices?: ServicePackageCreateNestedManyWithoutParentPackageInput
    partOfPackages?: ServicePackageCreateNestedManyWithoutChildServiceInput
    acceptedInsurances?: ServiceInsuranceCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    providerId: string
    name: string
    description?: string | null
    type?: $Enums.ServiceType
    pricingModel?: $Enums.PricingModel
    fixedPrice?: number
    priceMin?: number
    priceMax?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    includedServices?: ServicePackageUncheckedCreateNestedManyWithoutParentPackageInput
    partOfPackages?: ServicePackageUncheckedCreateNestedManyWithoutChildServiceInput
    acceptedInsurances?: ServiceInsuranceUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutAppointmentsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutAppointmentsInput, ServiceUncheckedCreateWithoutAppointmentsInput>
  }

  export type AppointmentUpsertWithoutServicesInput = {
    update: XOR<AppointmentUpdateWithoutServicesInput, AppointmentUncheckedUpdateWithoutServicesInput>
    create: XOR<AppointmentCreateWithoutServicesInput, AppointmentUncheckedCreateWithoutServicesInput>
    where?: AppointmentWhereInput
  }

  export type AppointmentUpdateToOneWithWhereWithoutServicesInput = {
    where?: AppointmentWhereInput
    data: XOR<AppointmentUpdateWithoutServicesInput, AppointmentUncheckedUpdateWithoutServicesInput>
  }

  export type AppointmentUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentNumber?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patientName?: StringFieldUpdateOperationsInput | string
    patientEmail?: StringFieldUpdateOperationsInput | string
    patientPhone?: NullableStringFieldUpdateOperationsInput | string | null
    activityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAppointmentsNestedInput
    provider?: ProviderUpdateOneRequiredWithoutAppointmentsNestedInput
    canceller?: UserUpdateOneWithoutCancelledAppointmentsNestedInput
    notifications?: NotificationUpdateManyWithoutAppointmentNestedInput
    review?: ReviewUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentNumber?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patientName?: StringFieldUpdateOperationsInput | string
    patientEmail?: StringFieldUpdateOperationsInput | string
    patientPhone?: NullableStringFieldUpdateOperationsInput | string | null
    activityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutAppointmentNestedInput
    review?: ReviewUncheckedUpdateOneWithoutAppointmentNestedInput
  }

  export type ServiceUpsertWithoutAppointmentsInput = {
    update: XOR<ServiceUpdateWithoutAppointmentsInput, ServiceUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<ServiceCreateWithoutAppointmentsInput, ServiceUncheckedCreateWithoutAppointmentsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutAppointmentsInput, ServiceUncheckedUpdateWithoutAppointmentsInput>
  }

  export type ServiceUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    fixedPrice?: IntFieldUpdateOperationsInput | number
    priceMin?: IntFieldUpdateOperationsInput | number
    priceMax?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: ProviderUpdateOneRequiredWithoutServicesNestedInput
    includedServices?: ServicePackageUpdateManyWithoutParentPackageNestedInput
    partOfPackages?: ServicePackageUpdateManyWithoutChildServiceNestedInput
    acceptedInsurances?: ServiceInsuranceUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    fixedPrice?: IntFieldUpdateOperationsInput | number
    priceMin?: IntFieldUpdateOperationsInput | number
    priceMax?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    includedServices?: ServicePackageUncheckedUpdateManyWithoutParentPackageNestedInput
    partOfPackages?: ServicePackageUncheckedUpdateManyWithoutChildServiceNestedInput
    acceptedInsurances?: ServiceInsuranceUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type UserCreateWithoutVerifiedDocumentsInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    suspendedBy?: UserCreateNestedOneWithoutSuspendedUsersInput
    suspendedUsers?: UserCreateNestedManyWithoutSuspendedByInput
    provider?: ProviderCreateNestedOneWithoutUserInput
    verifiedProviders?: ProviderCreateNestedManyWithoutVerifierInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    cancelledAppointments?: AppointmentCreateNestedManyWithoutCancellerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    conversationsAsUser1?: ConversationCreateNestedManyWithoutUser1Input
    conversationsAsUser2?: ConversationCreateNestedManyWithoutUser2Input
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewLikes?: ReviewLikeCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackCreateNestedManyWithoutRespondedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutAdminInput
    providerStatusChanges?: ProviderStatusHistoryCreateNestedManyWithoutChangedByInput
  }

  export type UserUncheckedCreateWithoutVerifiedDocumentsInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    suspendedById?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    suspendedUsers?: UserUncheckedCreateNestedManyWithoutSuspendedByInput
    provider?: ProviderUncheckedCreateNestedOneWithoutUserInput
    verifiedProviders?: ProviderUncheckedCreateNestedManyWithoutVerifierInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    cancelledAppointments?: AppointmentUncheckedCreateNestedManyWithoutCancellerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conversationsAsUser1?: ConversationUncheckedCreateNestedManyWithoutUser1Input
    conversationsAsUser2?: ConversationUncheckedCreateNestedManyWithoutUser2Input
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewLikes?: ReviewLikeUncheckedCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackUncheckedCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackUncheckedCreateNestedManyWithoutRespondedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
  }

  export type UserCreateOrConnectWithoutVerifiedDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVerifiedDocumentsInput, UserUncheckedCreateWithoutVerifiedDocumentsInput>
  }

  export type ProviderCreateWithoutDocumentsInput = {
    id?: string
    healthcareName: string
    description?: string | null
    phoneNumber?: string | null
    email?: string | null
    coverPhoto?: string | null
    status?: $Enums.ProviderStatus
    address: string
    city?: string
    province?: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    slotDuration?: number
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProviderInput
    category?: CategoryCreateNestedOneWithoutProvidersInput
    verifier?: UserCreateNestedOneWithoutVerifiedProvidersInput
    services?: ServiceCreateNestedManyWithoutProviderInput
    operatingHours?: OperatingHourCreateNestedManyWithoutProviderInput
    appointments?: AppointmentCreateNestedManyWithoutProviderInput
    breakTimes?: BreakTimeCreateNestedManyWithoutProviderInput
    notifications?: NotificationCreateNestedManyWithoutProviderInput
    reviews?: ReviewCreateNestedManyWithoutProviderInput
    statusHistory?: ProviderStatusHistoryCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateWithoutDocumentsInput = {
    id?: string
    userId: string
    categoryId?: string | null
    verifiedBy?: string | null
    healthcareName: string
    description?: string | null
    phoneNumber?: string | null
    email?: string | null
    coverPhoto?: string | null
    status?: $Enums.ProviderStatus
    address: string
    city?: string
    province?: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    slotDuration?: number
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutProviderInput
    operatingHours?: OperatingHourUncheckedCreateNestedManyWithoutProviderInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutProviderInput
    breakTimes?: BreakTimeUncheckedCreateNestedManyWithoutProviderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutProviderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProviderInput
    statusHistory?: ProviderStatusHistoryUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderCreateOrConnectWithoutDocumentsInput = {
    where: ProviderWhereUniqueInput
    create: XOR<ProviderCreateWithoutDocumentsInput, ProviderUncheckedCreateWithoutDocumentsInput>
  }

  export type UserUpsertWithoutVerifiedDocumentsInput = {
    update: XOR<UserUpdateWithoutVerifiedDocumentsInput, UserUncheckedUpdateWithoutVerifiedDocumentsInput>
    create: XOR<UserCreateWithoutVerifiedDocumentsInput, UserUncheckedCreateWithoutVerifiedDocumentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVerifiedDocumentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVerifiedDocumentsInput, UserUncheckedUpdateWithoutVerifiedDocumentsInput>
  }

  export type UserUpdateWithoutVerifiedDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    suspendedBy?: UserUpdateOneWithoutSuspendedUsersNestedInput
    suspendedUsers?: UserUpdateManyWithoutSuspendedByNestedInput
    provider?: ProviderUpdateOneWithoutUserNestedInput
    verifiedProviders?: ProviderUpdateManyWithoutVerifierNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    cancelledAppointments?: AppointmentUpdateManyWithoutCancellerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    conversationsAsUser1?: ConversationUpdateManyWithoutUser1NestedInput
    conversationsAsUser2?: ConversationUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewLikes?: ReviewLikeUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUpdateManyWithoutRespondedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutAdminNestedInput
    providerStatusChanges?: ProviderStatusHistoryUpdateManyWithoutChangedByNestedInput
  }

  export type UserUncheckedUpdateWithoutVerifiedDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedById?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    suspendedUsers?: UserUncheckedUpdateManyWithoutSuspendedByNestedInput
    provider?: ProviderUncheckedUpdateOneWithoutUserNestedInput
    verifiedProviders?: ProviderUncheckedUpdateManyWithoutVerifierNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    cancelledAppointments?: AppointmentUncheckedUpdateManyWithoutCancellerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conversationsAsUser1?: ConversationUncheckedUpdateManyWithoutUser1NestedInput
    conversationsAsUser2?: ConversationUncheckedUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewLikes?: ReviewLikeUncheckedUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUncheckedUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUncheckedUpdateManyWithoutRespondedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminNestedInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
  }

  export type ProviderUpsertWithoutDocumentsInput = {
    update: XOR<ProviderUpdateWithoutDocumentsInput, ProviderUncheckedUpdateWithoutDocumentsInput>
    create: XOR<ProviderCreateWithoutDocumentsInput, ProviderUncheckedCreateWithoutDocumentsInput>
    where?: ProviderWhereInput
  }

  export type ProviderUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: ProviderWhereInput
    data: XOR<ProviderUpdateWithoutDocumentsInput, ProviderUncheckedUpdateWithoutDocumentsInput>
  }

  export type ProviderUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    healthcareName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    slotDuration?: IntFieldUpdateOperationsInput | number
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProviderNestedInput
    category?: CategoryUpdateOneWithoutProvidersNestedInput
    verifier?: UserUpdateOneWithoutVerifiedProvidersNestedInput
    services?: ServiceUpdateManyWithoutProviderNestedInput
    operatingHours?: OperatingHourUpdateManyWithoutProviderNestedInput
    appointments?: AppointmentUpdateManyWithoutProviderNestedInput
    breakTimes?: BreakTimeUpdateManyWithoutProviderNestedInput
    notifications?: NotificationUpdateManyWithoutProviderNestedInput
    reviews?: ReviewUpdateManyWithoutProviderNestedInput
    statusHistory?: ProviderStatusHistoryUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    healthcareName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    slotDuration?: IntFieldUpdateOperationsInput | number
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutProviderNestedInput
    operatingHours?: OperatingHourUncheckedUpdateManyWithoutProviderNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutProviderNestedInput
    breakTimes?: BreakTimeUncheckedUpdateManyWithoutProviderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutProviderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProviderNestedInput
    statusHistory?: ProviderStatusHistoryUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    suspendedBy?: UserCreateNestedOneWithoutSuspendedUsersInput
    suspendedUsers?: UserCreateNestedManyWithoutSuspendedByInput
    provider?: ProviderCreateNestedOneWithoutUserInput
    verifiedProviders?: ProviderCreateNestedManyWithoutVerifierInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    cancelledAppointments?: AppointmentCreateNestedManyWithoutCancellerInput
    conversationsAsUser1?: ConversationCreateNestedManyWithoutUser1Input
    conversationsAsUser2?: ConversationCreateNestedManyWithoutUser2Input
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewLikes?: ReviewLikeCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackCreateNestedManyWithoutRespondedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutAdminInput
    providerStatusChanges?: ProviderStatusHistoryCreateNestedManyWithoutChangedByInput
    verifiedDocuments?: DocumentCreateNestedManyWithoutVerifiedByInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    suspendedById?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    suspendedUsers?: UserUncheckedCreateNestedManyWithoutSuspendedByInput
    provider?: ProviderUncheckedCreateNestedOneWithoutUserInput
    verifiedProviders?: ProviderUncheckedCreateNestedManyWithoutVerifierInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    cancelledAppointments?: AppointmentUncheckedCreateNestedManyWithoutCancellerInput
    conversationsAsUser1?: ConversationUncheckedCreateNestedManyWithoutUser1Input
    conversationsAsUser2?: ConversationUncheckedCreateNestedManyWithoutUser2Input
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewLikes?: ReviewLikeUncheckedCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackUncheckedCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackUncheckedCreateNestedManyWithoutRespondedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    verifiedDocuments?: DocumentUncheckedCreateNestedManyWithoutVerifiedByInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type AppointmentCreateWithoutNotificationsInput = {
    id?: string
    appointmentNumber: string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.AppointmentStatus
    notes?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    patientName: string
    patientEmail: string
    patientPhone?: string | null
    activityNotes?: string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAppointmentsInput
    provider: ProviderCreateNestedOneWithoutAppointmentsInput
    canceller?: UserCreateNestedOneWithoutCancelledAppointmentsInput
    services?: AppointmentServiceCreateNestedManyWithoutAppointmentInput
    review?: ReviewCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutNotificationsInput = {
    id?: string
    appointmentNumber: string
    userId: string
    providerId: string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.AppointmentStatus
    notes?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    patientName: string
    patientEmail: string
    patientPhone?: string | null
    activityNotes?: string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    cancelledBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: AppointmentServiceUncheckedCreateNestedManyWithoutAppointmentInput
    review?: ReviewUncheckedCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutNotificationsInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutNotificationsInput, AppointmentUncheckedCreateWithoutNotificationsInput>
  }

  export type ProviderCreateWithoutNotificationsInput = {
    id?: string
    healthcareName: string
    description?: string | null
    phoneNumber?: string | null
    email?: string | null
    coverPhoto?: string | null
    status?: $Enums.ProviderStatus
    address: string
    city?: string
    province?: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    slotDuration?: number
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProviderInput
    category?: CategoryCreateNestedOneWithoutProvidersInput
    verifier?: UserCreateNestedOneWithoutVerifiedProvidersInput
    services?: ServiceCreateNestedManyWithoutProviderInput
    operatingHours?: OperatingHourCreateNestedManyWithoutProviderInput
    appointments?: AppointmentCreateNestedManyWithoutProviderInput
    documents?: DocumentCreateNestedManyWithoutProviderInput
    breakTimes?: BreakTimeCreateNestedManyWithoutProviderInput
    reviews?: ReviewCreateNestedManyWithoutProviderInput
    statusHistory?: ProviderStatusHistoryCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateWithoutNotificationsInput = {
    id?: string
    userId: string
    categoryId?: string | null
    verifiedBy?: string | null
    healthcareName: string
    description?: string | null
    phoneNumber?: string | null
    email?: string | null
    coverPhoto?: string | null
    status?: $Enums.ProviderStatus
    address: string
    city?: string
    province?: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    slotDuration?: number
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutProviderInput
    operatingHours?: OperatingHourUncheckedCreateNestedManyWithoutProviderInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutProviderInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProviderInput
    breakTimes?: BreakTimeUncheckedCreateNestedManyWithoutProviderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProviderInput
    statusHistory?: ProviderStatusHistoryUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderCreateOrConnectWithoutNotificationsInput = {
    where: ProviderWhereUniqueInput
    create: XOR<ProviderCreateWithoutNotificationsInput, ProviderUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    suspendedBy?: UserUpdateOneWithoutSuspendedUsersNestedInput
    suspendedUsers?: UserUpdateManyWithoutSuspendedByNestedInput
    provider?: ProviderUpdateOneWithoutUserNestedInput
    verifiedProviders?: ProviderUpdateManyWithoutVerifierNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    cancelledAppointments?: AppointmentUpdateManyWithoutCancellerNestedInput
    conversationsAsUser1?: ConversationUpdateManyWithoutUser1NestedInput
    conversationsAsUser2?: ConversationUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewLikes?: ReviewLikeUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUpdateManyWithoutRespondedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutAdminNestedInput
    providerStatusChanges?: ProviderStatusHistoryUpdateManyWithoutChangedByNestedInput
    verifiedDocuments?: DocumentUpdateManyWithoutVerifiedByNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedById?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    suspendedUsers?: UserUncheckedUpdateManyWithoutSuspendedByNestedInput
    provider?: ProviderUncheckedUpdateOneWithoutUserNestedInput
    verifiedProviders?: ProviderUncheckedUpdateManyWithoutVerifierNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    cancelledAppointments?: AppointmentUncheckedUpdateManyWithoutCancellerNestedInput
    conversationsAsUser1?: ConversationUncheckedUpdateManyWithoutUser1NestedInput
    conversationsAsUser2?: ConversationUncheckedUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewLikes?: ReviewLikeUncheckedUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUncheckedUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUncheckedUpdateManyWithoutRespondedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminNestedInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    verifiedDocuments?: DocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
  }

  export type AppointmentUpsertWithoutNotificationsInput = {
    update: XOR<AppointmentUpdateWithoutNotificationsInput, AppointmentUncheckedUpdateWithoutNotificationsInput>
    create: XOR<AppointmentCreateWithoutNotificationsInput, AppointmentUncheckedCreateWithoutNotificationsInput>
    where?: AppointmentWhereInput
  }

  export type AppointmentUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: AppointmentWhereInput
    data: XOR<AppointmentUpdateWithoutNotificationsInput, AppointmentUncheckedUpdateWithoutNotificationsInput>
  }

  export type AppointmentUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentNumber?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patientName?: StringFieldUpdateOperationsInput | string
    patientEmail?: StringFieldUpdateOperationsInput | string
    patientPhone?: NullableStringFieldUpdateOperationsInput | string | null
    activityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAppointmentsNestedInput
    provider?: ProviderUpdateOneRequiredWithoutAppointmentsNestedInput
    canceller?: UserUpdateOneWithoutCancelledAppointmentsNestedInput
    services?: AppointmentServiceUpdateManyWithoutAppointmentNestedInput
    review?: ReviewUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentNumber?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patientName?: StringFieldUpdateOperationsInput | string
    patientEmail?: StringFieldUpdateOperationsInput | string
    patientPhone?: NullableStringFieldUpdateOperationsInput | string | null
    activityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: AppointmentServiceUncheckedUpdateManyWithoutAppointmentNestedInput
    review?: ReviewUncheckedUpdateOneWithoutAppointmentNestedInput
  }

  export type ProviderUpsertWithoutNotificationsInput = {
    update: XOR<ProviderUpdateWithoutNotificationsInput, ProviderUncheckedUpdateWithoutNotificationsInput>
    create: XOR<ProviderCreateWithoutNotificationsInput, ProviderUncheckedCreateWithoutNotificationsInput>
    where?: ProviderWhereInput
  }

  export type ProviderUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: ProviderWhereInput
    data: XOR<ProviderUpdateWithoutNotificationsInput, ProviderUncheckedUpdateWithoutNotificationsInput>
  }

  export type ProviderUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    healthcareName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    slotDuration?: IntFieldUpdateOperationsInput | number
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProviderNestedInput
    category?: CategoryUpdateOneWithoutProvidersNestedInput
    verifier?: UserUpdateOneWithoutVerifiedProvidersNestedInput
    services?: ServiceUpdateManyWithoutProviderNestedInput
    operatingHours?: OperatingHourUpdateManyWithoutProviderNestedInput
    appointments?: AppointmentUpdateManyWithoutProviderNestedInput
    documents?: DocumentUpdateManyWithoutProviderNestedInput
    breakTimes?: BreakTimeUpdateManyWithoutProviderNestedInput
    reviews?: ReviewUpdateManyWithoutProviderNestedInput
    statusHistory?: ProviderStatusHistoryUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    healthcareName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    slotDuration?: IntFieldUpdateOperationsInput | number
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutProviderNestedInput
    operatingHours?: OperatingHourUncheckedUpdateManyWithoutProviderNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutProviderNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProviderNestedInput
    breakTimes?: BreakTimeUncheckedUpdateManyWithoutProviderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProviderNestedInput
    statusHistory?: ProviderStatusHistoryUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type UserCreateWithoutConversationsAsUser1Input = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    suspendedBy?: UserCreateNestedOneWithoutSuspendedUsersInput
    suspendedUsers?: UserCreateNestedManyWithoutSuspendedByInput
    provider?: ProviderCreateNestedOneWithoutUserInput
    verifiedProviders?: ProviderCreateNestedManyWithoutVerifierInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    cancelledAppointments?: AppointmentCreateNestedManyWithoutCancellerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    conversationsAsUser2?: ConversationCreateNestedManyWithoutUser2Input
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewLikes?: ReviewLikeCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackCreateNestedManyWithoutRespondedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutAdminInput
    providerStatusChanges?: ProviderStatusHistoryCreateNestedManyWithoutChangedByInput
    verifiedDocuments?: DocumentCreateNestedManyWithoutVerifiedByInput
  }

  export type UserUncheckedCreateWithoutConversationsAsUser1Input = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    suspendedById?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    suspendedUsers?: UserUncheckedCreateNestedManyWithoutSuspendedByInput
    provider?: ProviderUncheckedCreateNestedOneWithoutUserInput
    verifiedProviders?: ProviderUncheckedCreateNestedManyWithoutVerifierInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    cancelledAppointments?: AppointmentUncheckedCreateNestedManyWithoutCancellerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conversationsAsUser2?: ConversationUncheckedCreateNestedManyWithoutUser2Input
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewLikes?: ReviewLikeUncheckedCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackUncheckedCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackUncheckedCreateNestedManyWithoutRespondedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    verifiedDocuments?: DocumentUncheckedCreateNestedManyWithoutVerifiedByInput
  }

  export type UserCreateOrConnectWithoutConversationsAsUser1Input = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConversationsAsUser1Input, UserUncheckedCreateWithoutConversationsAsUser1Input>
  }

  export type UserCreateWithoutConversationsAsUser2Input = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    suspendedBy?: UserCreateNestedOneWithoutSuspendedUsersInput
    suspendedUsers?: UserCreateNestedManyWithoutSuspendedByInput
    provider?: ProviderCreateNestedOneWithoutUserInput
    verifiedProviders?: ProviderCreateNestedManyWithoutVerifierInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    cancelledAppointments?: AppointmentCreateNestedManyWithoutCancellerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    conversationsAsUser1?: ConversationCreateNestedManyWithoutUser1Input
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewLikes?: ReviewLikeCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackCreateNestedManyWithoutRespondedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutAdminInput
    providerStatusChanges?: ProviderStatusHistoryCreateNestedManyWithoutChangedByInput
    verifiedDocuments?: DocumentCreateNestedManyWithoutVerifiedByInput
  }

  export type UserUncheckedCreateWithoutConversationsAsUser2Input = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    suspendedById?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    suspendedUsers?: UserUncheckedCreateNestedManyWithoutSuspendedByInput
    provider?: ProviderUncheckedCreateNestedOneWithoutUserInput
    verifiedProviders?: ProviderUncheckedCreateNestedManyWithoutVerifierInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    cancelledAppointments?: AppointmentUncheckedCreateNestedManyWithoutCancellerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conversationsAsUser1?: ConversationUncheckedCreateNestedManyWithoutUser1Input
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewLikes?: ReviewLikeUncheckedCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackUncheckedCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackUncheckedCreateNestedManyWithoutRespondedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    verifiedDocuments?: DocumentUncheckedCreateNestedManyWithoutVerifiedByInput
  }

  export type UserCreateOrConnectWithoutConversationsAsUser2Input = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConversationsAsUser2Input, UserUncheckedCreateWithoutConversationsAsUser2Input>
  }

  export type MessageCreateWithoutConversationInput = {
    id?: string
    content: string
    status?: $Enums.MessageStatus
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type MessageUncheckedCreateWithoutConversationInput = {
    id?: string
    senderId: string
    content: string
    status?: $Enums.MessageStatus
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutConversationInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageCreateManyConversationInputEnvelope = {
    data: MessageCreateManyConversationInput | MessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutConversationsAsUser1Input = {
    update: XOR<UserUpdateWithoutConversationsAsUser1Input, UserUncheckedUpdateWithoutConversationsAsUser1Input>
    create: XOR<UserCreateWithoutConversationsAsUser1Input, UserUncheckedCreateWithoutConversationsAsUser1Input>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConversationsAsUser1Input = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConversationsAsUser1Input, UserUncheckedUpdateWithoutConversationsAsUser1Input>
  }

  export type UserUpdateWithoutConversationsAsUser1Input = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    suspendedBy?: UserUpdateOneWithoutSuspendedUsersNestedInput
    suspendedUsers?: UserUpdateManyWithoutSuspendedByNestedInput
    provider?: ProviderUpdateOneWithoutUserNestedInput
    verifiedProviders?: ProviderUpdateManyWithoutVerifierNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    cancelledAppointments?: AppointmentUpdateManyWithoutCancellerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    conversationsAsUser2?: ConversationUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewLikes?: ReviewLikeUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUpdateManyWithoutRespondedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutAdminNestedInput
    providerStatusChanges?: ProviderStatusHistoryUpdateManyWithoutChangedByNestedInput
    verifiedDocuments?: DocumentUpdateManyWithoutVerifiedByNestedInput
  }

  export type UserUncheckedUpdateWithoutConversationsAsUser1Input = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedById?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    suspendedUsers?: UserUncheckedUpdateManyWithoutSuspendedByNestedInput
    provider?: ProviderUncheckedUpdateOneWithoutUserNestedInput
    verifiedProviders?: ProviderUncheckedUpdateManyWithoutVerifierNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    cancelledAppointments?: AppointmentUncheckedUpdateManyWithoutCancellerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conversationsAsUser2?: ConversationUncheckedUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewLikes?: ReviewLikeUncheckedUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUncheckedUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUncheckedUpdateManyWithoutRespondedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminNestedInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    verifiedDocuments?: DocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
  }

  export type UserUpsertWithoutConversationsAsUser2Input = {
    update: XOR<UserUpdateWithoutConversationsAsUser2Input, UserUncheckedUpdateWithoutConversationsAsUser2Input>
    create: XOR<UserCreateWithoutConversationsAsUser2Input, UserUncheckedCreateWithoutConversationsAsUser2Input>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConversationsAsUser2Input = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConversationsAsUser2Input, UserUncheckedUpdateWithoutConversationsAsUser2Input>
  }

  export type UserUpdateWithoutConversationsAsUser2Input = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    suspendedBy?: UserUpdateOneWithoutSuspendedUsersNestedInput
    suspendedUsers?: UserUpdateManyWithoutSuspendedByNestedInput
    provider?: ProviderUpdateOneWithoutUserNestedInput
    verifiedProviders?: ProviderUpdateManyWithoutVerifierNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    cancelledAppointments?: AppointmentUpdateManyWithoutCancellerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    conversationsAsUser1?: ConversationUpdateManyWithoutUser1NestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewLikes?: ReviewLikeUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUpdateManyWithoutRespondedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutAdminNestedInput
    providerStatusChanges?: ProviderStatusHistoryUpdateManyWithoutChangedByNestedInput
    verifiedDocuments?: DocumentUpdateManyWithoutVerifiedByNestedInput
  }

  export type UserUncheckedUpdateWithoutConversationsAsUser2Input = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedById?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    suspendedUsers?: UserUncheckedUpdateManyWithoutSuspendedByNestedInput
    provider?: ProviderUncheckedUpdateOneWithoutUserNestedInput
    verifiedProviders?: ProviderUncheckedUpdateManyWithoutVerifierNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    cancelledAppointments?: AppointmentUncheckedUpdateManyWithoutCancellerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conversationsAsUser1?: ConversationUncheckedUpdateManyWithoutUser1NestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewLikes?: ReviewLikeUncheckedUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUncheckedUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUncheckedUpdateManyWithoutRespondedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminNestedInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    verifiedDocuments?: DocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
  }

  export type MessageUpdateManyWithWhereWithoutConversationInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type ConversationCreateWithoutMessagesInput = {
    id?: string
    lastMessageAt?: Date | string | null
    lastMessageContent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user1: UserCreateNestedOneWithoutConversationsAsUser1Input
    user2: UserCreateNestedOneWithoutConversationsAsUser2Input
  }

  export type ConversationUncheckedCreateWithoutMessagesInput = {
    id?: string
    user1Id: string
    user2Id: string
    lastMessageAt?: Date | string | null
    lastMessageContent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationCreateOrConnectWithoutMessagesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutSentMessagesInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    suspendedBy?: UserCreateNestedOneWithoutSuspendedUsersInput
    suspendedUsers?: UserCreateNestedManyWithoutSuspendedByInput
    provider?: ProviderCreateNestedOneWithoutUserInput
    verifiedProviders?: ProviderCreateNestedManyWithoutVerifierInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    cancelledAppointments?: AppointmentCreateNestedManyWithoutCancellerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    conversationsAsUser1?: ConversationCreateNestedManyWithoutUser1Input
    conversationsAsUser2?: ConversationCreateNestedManyWithoutUser2Input
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewLikes?: ReviewLikeCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackCreateNestedManyWithoutRespondedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutAdminInput
    providerStatusChanges?: ProviderStatusHistoryCreateNestedManyWithoutChangedByInput
    verifiedDocuments?: DocumentCreateNestedManyWithoutVerifiedByInput
  }

  export type UserUncheckedCreateWithoutSentMessagesInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    suspendedById?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    suspendedUsers?: UserUncheckedCreateNestedManyWithoutSuspendedByInput
    provider?: ProviderUncheckedCreateNestedOneWithoutUserInput
    verifiedProviders?: ProviderUncheckedCreateNestedManyWithoutVerifierInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    cancelledAppointments?: AppointmentUncheckedCreateNestedManyWithoutCancellerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conversationsAsUser1?: ConversationUncheckedCreateNestedManyWithoutUser1Input
    conversationsAsUser2?: ConversationUncheckedCreateNestedManyWithoutUser2Input
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewLikes?: ReviewLikeUncheckedCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackUncheckedCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackUncheckedCreateNestedManyWithoutRespondedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    verifiedDocuments?: DocumentUncheckedCreateNestedManyWithoutVerifiedByInput
  }

  export type UserCreateOrConnectWithoutSentMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type ConversationUpsertWithoutMessagesInput = {
    update: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ConversationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageContent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user1?: UserUpdateOneRequiredWithoutConversationsAsUser1NestedInput
    user2?: UserUpdateOneRequiredWithoutConversationsAsUser2NestedInput
  }

  export type ConversationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user1Id?: StringFieldUpdateOperationsInput | string
    user2Id?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageContent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutSentMessagesInput = {
    update: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    suspendedBy?: UserUpdateOneWithoutSuspendedUsersNestedInput
    suspendedUsers?: UserUpdateManyWithoutSuspendedByNestedInput
    provider?: ProviderUpdateOneWithoutUserNestedInput
    verifiedProviders?: ProviderUpdateManyWithoutVerifierNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    cancelledAppointments?: AppointmentUpdateManyWithoutCancellerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    conversationsAsUser1?: ConversationUpdateManyWithoutUser1NestedInput
    conversationsAsUser2?: ConversationUpdateManyWithoutUser2NestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewLikes?: ReviewLikeUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUpdateManyWithoutRespondedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutAdminNestedInput
    providerStatusChanges?: ProviderStatusHistoryUpdateManyWithoutChangedByNestedInput
    verifiedDocuments?: DocumentUpdateManyWithoutVerifiedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedById?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    suspendedUsers?: UserUncheckedUpdateManyWithoutSuspendedByNestedInput
    provider?: ProviderUncheckedUpdateOneWithoutUserNestedInput
    verifiedProviders?: ProviderUncheckedUpdateManyWithoutVerifierNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    cancelledAppointments?: AppointmentUncheckedUpdateManyWithoutCancellerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conversationsAsUser1?: ConversationUncheckedUpdateManyWithoutUser1NestedInput
    conversationsAsUser2?: ConversationUncheckedUpdateManyWithoutUser2NestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewLikes?: ReviewLikeUncheckedUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUncheckedUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUncheckedUpdateManyWithoutRespondedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminNestedInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    verifiedDocuments?: DocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
  }

  export type AppointmentCreateWithoutReviewInput = {
    id?: string
    appointmentNumber: string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.AppointmentStatus
    notes?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    patientName: string
    patientEmail: string
    patientPhone?: string | null
    activityNotes?: string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAppointmentsInput
    provider: ProviderCreateNestedOneWithoutAppointmentsInput
    canceller?: UserCreateNestedOneWithoutCancelledAppointmentsInput
    services?: AppointmentServiceCreateNestedManyWithoutAppointmentInput
    notifications?: NotificationCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutReviewInput = {
    id?: string
    appointmentNumber: string
    userId: string
    providerId: string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.AppointmentStatus
    notes?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    patientName: string
    patientEmail: string
    patientPhone?: string | null
    activityNotes?: string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    cancelledBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: AppointmentServiceUncheckedCreateNestedManyWithoutAppointmentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutReviewInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutReviewInput, AppointmentUncheckedCreateWithoutReviewInput>
  }

  export type UserCreateWithoutReviewsInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    suspendedBy?: UserCreateNestedOneWithoutSuspendedUsersInput
    suspendedUsers?: UserCreateNestedManyWithoutSuspendedByInput
    provider?: ProviderCreateNestedOneWithoutUserInput
    verifiedProviders?: ProviderCreateNestedManyWithoutVerifierInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    cancelledAppointments?: AppointmentCreateNestedManyWithoutCancellerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    conversationsAsUser1?: ConversationCreateNestedManyWithoutUser1Input
    conversationsAsUser2?: ConversationCreateNestedManyWithoutUser2Input
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviewLikes?: ReviewLikeCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackCreateNestedManyWithoutRespondedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutAdminInput
    providerStatusChanges?: ProviderStatusHistoryCreateNestedManyWithoutChangedByInput
    verifiedDocuments?: DocumentCreateNestedManyWithoutVerifiedByInput
  }

  export type UserUncheckedCreateWithoutReviewsInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    suspendedById?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    suspendedUsers?: UserUncheckedCreateNestedManyWithoutSuspendedByInput
    provider?: ProviderUncheckedCreateNestedOneWithoutUserInput
    verifiedProviders?: ProviderUncheckedCreateNestedManyWithoutVerifierInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    cancelledAppointments?: AppointmentUncheckedCreateNestedManyWithoutCancellerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conversationsAsUser1?: ConversationUncheckedCreateNestedManyWithoutUser1Input
    conversationsAsUser2?: ConversationUncheckedCreateNestedManyWithoutUser2Input
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviewLikes?: ReviewLikeUncheckedCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackUncheckedCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackUncheckedCreateNestedManyWithoutRespondedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    verifiedDocuments?: DocumentUncheckedCreateNestedManyWithoutVerifiedByInput
  }

  export type UserCreateOrConnectWithoutReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
  }

  export type ProviderCreateWithoutReviewsInput = {
    id?: string
    healthcareName: string
    description?: string | null
    phoneNumber?: string | null
    email?: string | null
    coverPhoto?: string | null
    status?: $Enums.ProviderStatus
    address: string
    city?: string
    province?: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    slotDuration?: number
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProviderInput
    category?: CategoryCreateNestedOneWithoutProvidersInput
    verifier?: UserCreateNestedOneWithoutVerifiedProvidersInput
    services?: ServiceCreateNestedManyWithoutProviderInput
    operatingHours?: OperatingHourCreateNestedManyWithoutProviderInput
    appointments?: AppointmentCreateNestedManyWithoutProviderInput
    documents?: DocumentCreateNestedManyWithoutProviderInput
    breakTimes?: BreakTimeCreateNestedManyWithoutProviderInput
    notifications?: NotificationCreateNestedManyWithoutProviderInput
    statusHistory?: ProviderStatusHistoryCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateWithoutReviewsInput = {
    id?: string
    userId: string
    categoryId?: string | null
    verifiedBy?: string | null
    healthcareName: string
    description?: string | null
    phoneNumber?: string | null
    email?: string | null
    coverPhoto?: string | null
    status?: $Enums.ProviderStatus
    address: string
    city?: string
    province?: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    slotDuration?: number
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutProviderInput
    operatingHours?: OperatingHourUncheckedCreateNestedManyWithoutProviderInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutProviderInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProviderInput
    breakTimes?: BreakTimeUncheckedCreateNestedManyWithoutProviderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutProviderInput
    statusHistory?: ProviderStatusHistoryUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderCreateOrConnectWithoutReviewsInput = {
    where: ProviderWhereUniqueInput
    create: XOR<ProviderCreateWithoutReviewsInput, ProviderUncheckedCreateWithoutReviewsInput>
  }

  export type ReviewLikeCreateWithoutReviewInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutReviewLikesInput
  }

  export type ReviewLikeUncheckedCreateWithoutReviewInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type ReviewLikeCreateOrConnectWithoutReviewInput = {
    where: ReviewLikeWhereUniqueInput
    create: XOR<ReviewLikeCreateWithoutReviewInput, ReviewLikeUncheckedCreateWithoutReviewInput>
  }

  export type ReviewLikeCreateManyReviewInputEnvelope = {
    data: ReviewLikeCreateManyReviewInput | ReviewLikeCreateManyReviewInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentUpsertWithoutReviewInput = {
    update: XOR<AppointmentUpdateWithoutReviewInput, AppointmentUncheckedUpdateWithoutReviewInput>
    create: XOR<AppointmentCreateWithoutReviewInput, AppointmentUncheckedCreateWithoutReviewInput>
    where?: AppointmentWhereInput
  }

  export type AppointmentUpdateToOneWithWhereWithoutReviewInput = {
    where?: AppointmentWhereInput
    data: XOR<AppointmentUpdateWithoutReviewInput, AppointmentUncheckedUpdateWithoutReviewInput>
  }

  export type AppointmentUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentNumber?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patientName?: StringFieldUpdateOperationsInput | string
    patientEmail?: StringFieldUpdateOperationsInput | string
    patientPhone?: NullableStringFieldUpdateOperationsInput | string | null
    activityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAppointmentsNestedInput
    provider?: ProviderUpdateOneRequiredWithoutAppointmentsNestedInput
    canceller?: UserUpdateOneWithoutCancelledAppointmentsNestedInput
    services?: AppointmentServiceUpdateManyWithoutAppointmentNestedInput
    notifications?: NotificationUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentNumber?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patientName?: StringFieldUpdateOperationsInput | string
    patientEmail?: StringFieldUpdateOperationsInput | string
    patientPhone?: NullableStringFieldUpdateOperationsInput | string | null
    activityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: AppointmentServiceUncheckedUpdateManyWithoutAppointmentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type UserUpsertWithoutReviewsInput = {
    update: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    suspendedBy?: UserUpdateOneWithoutSuspendedUsersNestedInput
    suspendedUsers?: UserUpdateManyWithoutSuspendedByNestedInput
    provider?: ProviderUpdateOneWithoutUserNestedInput
    verifiedProviders?: ProviderUpdateManyWithoutVerifierNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    cancelledAppointments?: AppointmentUpdateManyWithoutCancellerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    conversationsAsUser1?: ConversationUpdateManyWithoutUser1NestedInput
    conversationsAsUser2?: ConversationUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviewLikes?: ReviewLikeUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUpdateManyWithoutRespondedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutAdminNestedInput
    providerStatusChanges?: ProviderStatusHistoryUpdateManyWithoutChangedByNestedInput
    verifiedDocuments?: DocumentUpdateManyWithoutVerifiedByNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedById?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    suspendedUsers?: UserUncheckedUpdateManyWithoutSuspendedByNestedInput
    provider?: ProviderUncheckedUpdateOneWithoutUserNestedInput
    verifiedProviders?: ProviderUncheckedUpdateManyWithoutVerifierNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    cancelledAppointments?: AppointmentUncheckedUpdateManyWithoutCancellerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conversationsAsUser1?: ConversationUncheckedUpdateManyWithoutUser1NestedInput
    conversationsAsUser2?: ConversationUncheckedUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviewLikes?: ReviewLikeUncheckedUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUncheckedUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUncheckedUpdateManyWithoutRespondedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminNestedInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    verifiedDocuments?: DocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
  }

  export type ProviderUpsertWithoutReviewsInput = {
    update: XOR<ProviderUpdateWithoutReviewsInput, ProviderUncheckedUpdateWithoutReviewsInput>
    create: XOR<ProviderCreateWithoutReviewsInput, ProviderUncheckedCreateWithoutReviewsInput>
    where?: ProviderWhereInput
  }

  export type ProviderUpdateToOneWithWhereWithoutReviewsInput = {
    where?: ProviderWhereInput
    data: XOR<ProviderUpdateWithoutReviewsInput, ProviderUncheckedUpdateWithoutReviewsInput>
  }

  export type ProviderUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    healthcareName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    slotDuration?: IntFieldUpdateOperationsInput | number
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProviderNestedInput
    category?: CategoryUpdateOneWithoutProvidersNestedInput
    verifier?: UserUpdateOneWithoutVerifiedProvidersNestedInput
    services?: ServiceUpdateManyWithoutProviderNestedInput
    operatingHours?: OperatingHourUpdateManyWithoutProviderNestedInput
    appointments?: AppointmentUpdateManyWithoutProviderNestedInput
    documents?: DocumentUpdateManyWithoutProviderNestedInput
    breakTimes?: BreakTimeUpdateManyWithoutProviderNestedInput
    notifications?: NotificationUpdateManyWithoutProviderNestedInput
    statusHistory?: ProviderStatusHistoryUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    healthcareName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    slotDuration?: IntFieldUpdateOperationsInput | number
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutProviderNestedInput
    operatingHours?: OperatingHourUncheckedUpdateManyWithoutProviderNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutProviderNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProviderNestedInput
    breakTimes?: BreakTimeUncheckedUpdateManyWithoutProviderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutProviderNestedInput
    statusHistory?: ProviderStatusHistoryUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type ReviewLikeUpsertWithWhereUniqueWithoutReviewInput = {
    where: ReviewLikeWhereUniqueInput
    update: XOR<ReviewLikeUpdateWithoutReviewInput, ReviewLikeUncheckedUpdateWithoutReviewInput>
    create: XOR<ReviewLikeCreateWithoutReviewInput, ReviewLikeUncheckedCreateWithoutReviewInput>
  }

  export type ReviewLikeUpdateWithWhereUniqueWithoutReviewInput = {
    where: ReviewLikeWhereUniqueInput
    data: XOR<ReviewLikeUpdateWithoutReviewInput, ReviewLikeUncheckedUpdateWithoutReviewInput>
  }

  export type ReviewLikeUpdateManyWithWhereWithoutReviewInput = {
    where: ReviewLikeScalarWhereInput
    data: XOR<ReviewLikeUpdateManyMutationInput, ReviewLikeUncheckedUpdateManyWithoutReviewInput>
  }

  export type ReviewCreateWithoutLikesInput = {
    id?: string
    rating: number
    comment?: string | null
    isAnonymous?: boolean
    professionalismRating?: number | null
    cleanlinessRating?: number | null
    waitTimeRating?: number | null
    valueRating?: number | null
    providerResponse?: string | null
    respondedAt?: Date | string | null
    isEdited?: boolean
    editedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment: AppointmentCreateNestedOneWithoutReviewInput
    user: UserCreateNestedOneWithoutReviewsInput
    provider: ProviderCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutLikesInput = {
    id?: string
    appointmentId: string
    userId: string
    providerId: string
    rating: number
    comment?: string | null
    isAnonymous?: boolean
    professionalismRating?: number | null
    cleanlinessRating?: number | null
    waitTimeRating?: number | null
    valueRating?: number | null
    providerResponse?: string | null
    respondedAt?: Date | string | null
    isEdited?: boolean
    editedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutLikesInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutLikesInput, ReviewUncheckedCreateWithoutLikesInput>
  }

  export type UserCreateWithoutReviewLikesInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    suspendedBy?: UserCreateNestedOneWithoutSuspendedUsersInput
    suspendedUsers?: UserCreateNestedManyWithoutSuspendedByInput
    provider?: ProviderCreateNestedOneWithoutUserInput
    verifiedProviders?: ProviderCreateNestedManyWithoutVerifierInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    cancelledAppointments?: AppointmentCreateNestedManyWithoutCancellerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    conversationsAsUser1?: ConversationCreateNestedManyWithoutUser1Input
    conversationsAsUser2?: ConversationCreateNestedManyWithoutUser2Input
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackCreateNestedManyWithoutRespondedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutAdminInput
    providerStatusChanges?: ProviderStatusHistoryCreateNestedManyWithoutChangedByInput
    verifiedDocuments?: DocumentCreateNestedManyWithoutVerifiedByInput
  }

  export type UserUncheckedCreateWithoutReviewLikesInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    suspendedById?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    suspendedUsers?: UserUncheckedCreateNestedManyWithoutSuspendedByInput
    provider?: ProviderUncheckedCreateNestedOneWithoutUserInput
    verifiedProviders?: ProviderUncheckedCreateNestedManyWithoutVerifierInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    cancelledAppointments?: AppointmentUncheckedCreateNestedManyWithoutCancellerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conversationsAsUser1?: ConversationUncheckedCreateNestedManyWithoutUser1Input
    conversationsAsUser2?: ConversationUncheckedCreateNestedManyWithoutUser2Input
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackUncheckedCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackUncheckedCreateNestedManyWithoutRespondedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    verifiedDocuments?: DocumentUncheckedCreateNestedManyWithoutVerifiedByInput
  }

  export type UserCreateOrConnectWithoutReviewLikesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewLikesInput, UserUncheckedCreateWithoutReviewLikesInput>
  }

  export type ReviewUpsertWithoutLikesInput = {
    update: XOR<ReviewUpdateWithoutLikesInput, ReviewUncheckedUpdateWithoutLikesInput>
    create: XOR<ReviewCreateWithoutLikesInput, ReviewUncheckedCreateWithoutLikesInput>
    where?: ReviewWhereInput
  }

  export type ReviewUpdateToOneWithWhereWithoutLikesInput = {
    where?: ReviewWhereInput
    data: XOR<ReviewUpdateWithoutLikesInput, ReviewUncheckedUpdateWithoutLikesInput>
  }

  export type ReviewUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    professionalismRating?: NullableIntFieldUpdateOperationsInput | number | null
    cleanlinessRating?: NullableIntFieldUpdateOperationsInput | number | null
    waitTimeRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueRating?: NullableIntFieldUpdateOperationsInput | number | null
    providerResponse?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneRequiredWithoutReviewNestedInput
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    provider?: ProviderUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    professionalismRating?: NullableIntFieldUpdateOperationsInput | number | null
    cleanlinessRating?: NullableIntFieldUpdateOperationsInput | number | null
    waitTimeRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueRating?: NullableIntFieldUpdateOperationsInput | number | null
    providerResponse?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutReviewLikesInput = {
    update: XOR<UserUpdateWithoutReviewLikesInput, UserUncheckedUpdateWithoutReviewLikesInput>
    create: XOR<UserCreateWithoutReviewLikesInput, UserUncheckedCreateWithoutReviewLikesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewLikesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewLikesInput, UserUncheckedUpdateWithoutReviewLikesInput>
  }

  export type UserUpdateWithoutReviewLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    suspendedBy?: UserUpdateOneWithoutSuspendedUsersNestedInput
    suspendedUsers?: UserUpdateManyWithoutSuspendedByNestedInput
    provider?: ProviderUpdateOneWithoutUserNestedInput
    verifiedProviders?: ProviderUpdateManyWithoutVerifierNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    cancelledAppointments?: AppointmentUpdateManyWithoutCancellerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    conversationsAsUser1?: ConversationUpdateManyWithoutUser1NestedInput
    conversationsAsUser2?: ConversationUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUpdateManyWithoutRespondedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutAdminNestedInput
    providerStatusChanges?: ProviderStatusHistoryUpdateManyWithoutChangedByNestedInput
    verifiedDocuments?: DocumentUpdateManyWithoutVerifiedByNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedById?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    suspendedUsers?: UserUncheckedUpdateManyWithoutSuspendedByNestedInput
    provider?: ProviderUncheckedUpdateOneWithoutUserNestedInput
    verifiedProviders?: ProviderUncheckedUpdateManyWithoutVerifierNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    cancelledAppointments?: AppointmentUncheckedUpdateManyWithoutCancellerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conversationsAsUser1?: ConversationUncheckedUpdateManyWithoutUser1NestedInput
    conversationsAsUser2?: ConversationUncheckedUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUncheckedUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUncheckedUpdateManyWithoutRespondedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminNestedInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    verifiedDocuments?: DocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    suspendedBy?: UserCreateNestedOneWithoutSuspendedUsersInput
    suspendedUsers?: UserCreateNestedManyWithoutSuspendedByInput
    provider?: ProviderCreateNestedOneWithoutUserInput
    verifiedProviders?: ProviderCreateNestedManyWithoutVerifierInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    cancelledAppointments?: AppointmentCreateNestedManyWithoutCancellerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    conversationsAsUser1?: ConversationCreateNestedManyWithoutUser1Input
    conversationsAsUser2?: ConversationCreateNestedManyWithoutUser2Input
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewLikes?: ReviewLikeCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackCreateNestedManyWithoutRespondedByInput
    providerStatusChanges?: ProviderStatusHistoryCreateNestedManyWithoutChangedByInput
    verifiedDocuments?: DocumentCreateNestedManyWithoutVerifiedByInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    suspendedById?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    suspendedUsers?: UserUncheckedCreateNestedManyWithoutSuspendedByInput
    provider?: ProviderUncheckedCreateNestedOneWithoutUserInput
    verifiedProviders?: ProviderUncheckedCreateNestedManyWithoutVerifierInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    cancelledAppointments?: AppointmentUncheckedCreateNestedManyWithoutCancellerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conversationsAsUser1?: ConversationUncheckedCreateNestedManyWithoutUser1Input
    conversationsAsUser2?: ConversationUncheckedCreateNestedManyWithoutUser2Input
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewLikes?: ReviewLikeUncheckedCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackUncheckedCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackUncheckedCreateNestedManyWithoutRespondedByInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    verifiedDocuments?: DocumentUncheckedCreateNestedManyWithoutVerifiedByInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    suspendedBy?: UserUpdateOneWithoutSuspendedUsersNestedInput
    suspendedUsers?: UserUpdateManyWithoutSuspendedByNestedInput
    provider?: ProviderUpdateOneWithoutUserNestedInput
    verifiedProviders?: ProviderUpdateManyWithoutVerifierNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    cancelledAppointments?: AppointmentUpdateManyWithoutCancellerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    conversationsAsUser1?: ConversationUpdateManyWithoutUser1NestedInput
    conversationsAsUser2?: ConversationUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewLikes?: ReviewLikeUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUpdateManyWithoutRespondedByNestedInput
    providerStatusChanges?: ProviderStatusHistoryUpdateManyWithoutChangedByNestedInput
    verifiedDocuments?: DocumentUpdateManyWithoutVerifiedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedById?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    suspendedUsers?: UserUncheckedUpdateManyWithoutSuspendedByNestedInput
    provider?: ProviderUncheckedUpdateOneWithoutUserNestedInput
    verifiedProviders?: ProviderUncheckedUpdateManyWithoutVerifierNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    cancelledAppointments?: AppointmentUncheckedUpdateManyWithoutCancellerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conversationsAsUser1?: ConversationUncheckedUpdateManyWithoutUser1NestedInput
    conversationsAsUser2?: ConversationUncheckedUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewLikes?: ReviewLikeUncheckedUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUncheckedUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUncheckedUpdateManyWithoutRespondedByNestedInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    verifiedDocuments?: DocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
  }

  export type ProviderCreateWithoutStatusHistoryInput = {
    id?: string
    healthcareName: string
    description?: string | null
    phoneNumber?: string | null
    email?: string | null
    coverPhoto?: string | null
    status?: $Enums.ProviderStatus
    address: string
    city?: string
    province?: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    slotDuration?: number
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProviderInput
    category?: CategoryCreateNestedOneWithoutProvidersInput
    verifier?: UserCreateNestedOneWithoutVerifiedProvidersInput
    services?: ServiceCreateNestedManyWithoutProviderInput
    operatingHours?: OperatingHourCreateNestedManyWithoutProviderInput
    appointments?: AppointmentCreateNestedManyWithoutProviderInput
    documents?: DocumentCreateNestedManyWithoutProviderInput
    breakTimes?: BreakTimeCreateNestedManyWithoutProviderInput
    notifications?: NotificationCreateNestedManyWithoutProviderInput
    reviews?: ReviewCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateWithoutStatusHistoryInput = {
    id?: string
    userId: string
    categoryId?: string | null
    verifiedBy?: string | null
    healthcareName: string
    description?: string | null
    phoneNumber?: string | null
    email?: string | null
    coverPhoto?: string | null
    status?: $Enums.ProviderStatus
    address: string
    city?: string
    province?: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    slotDuration?: number
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutProviderInput
    operatingHours?: OperatingHourUncheckedCreateNestedManyWithoutProviderInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutProviderInput
    documents?: DocumentUncheckedCreateNestedManyWithoutProviderInput
    breakTimes?: BreakTimeUncheckedCreateNestedManyWithoutProviderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutProviderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderCreateOrConnectWithoutStatusHistoryInput = {
    where: ProviderWhereUniqueInput
    create: XOR<ProviderCreateWithoutStatusHistoryInput, ProviderUncheckedCreateWithoutStatusHistoryInput>
  }

  export type UserCreateWithoutProviderStatusChangesInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    suspendedBy?: UserCreateNestedOneWithoutSuspendedUsersInput
    suspendedUsers?: UserCreateNestedManyWithoutSuspendedByInput
    provider?: ProviderCreateNestedOneWithoutUserInput
    verifiedProviders?: ProviderCreateNestedManyWithoutVerifierInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    cancelledAppointments?: AppointmentCreateNestedManyWithoutCancellerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    conversationsAsUser1?: ConversationCreateNestedManyWithoutUser1Input
    conversationsAsUser2?: ConversationCreateNestedManyWithoutUser2Input
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewLikes?: ReviewLikeCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackCreateNestedManyWithoutRespondedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutAdminInput
    verifiedDocuments?: DocumentCreateNestedManyWithoutVerifiedByInput
  }

  export type UserUncheckedCreateWithoutProviderStatusChangesInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    suspendedById?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    suspendedUsers?: UserUncheckedCreateNestedManyWithoutSuspendedByInput
    provider?: ProviderUncheckedCreateNestedOneWithoutUserInput
    verifiedProviders?: ProviderUncheckedCreateNestedManyWithoutVerifierInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    cancelledAppointments?: AppointmentUncheckedCreateNestedManyWithoutCancellerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conversationsAsUser1?: ConversationUncheckedCreateNestedManyWithoutUser1Input
    conversationsAsUser2?: ConversationUncheckedCreateNestedManyWithoutUser2Input
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewLikes?: ReviewLikeUncheckedCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackUncheckedCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackUncheckedCreateNestedManyWithoutRespondedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminInput
    verifiedDocuments?: DocumentUncheckedCreateNestedManyWithoutVerifiedByInput
  }

  export type UserCreateOrConnectWithoutProviderStatusChangesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProviderStatusChangesInput, UserUncheckedCreateWithoutProviderStatusChangesInput>
  }

  export type ProviderUpsertWithoutStatusHistoryInput = {
    update: XOR<ProviderUpdateWithoutStatusHistoryInput, ProviderUncheckedUpdateWithoutStatusHistoryInput>
    create: XOR<ProviderCreateWithoutStatusHistoryInput, ProviderUncheckedCreateWithoutStatusHistoryInput>
    where?: ProviderWhereInput
  }

  export type ProviderUpdateToOneWithWhereWithoutStatusHistoryInput = {
    where?: ProviderWhereInput
    data: XOR<ProviderUpdateWithoutStatusHistoryInput, ProviderUncheckedUpdateWithoutStatusHistoryInput>
  }

  export type ProviderUpdateWithoutStatusHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    healthcareName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    slotDuration?: IntFieldUpdateOperationsInput | number
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProviderNestedInput
    category?: CategoryUpdateOneWithoutProvidersNestedInput
    verifier?: UserUpdateOneWithoutVerifiedProvidersNestedInput
    services?: ServiceUpdateManyWithoutProviderNestedInput
    operatingHours?: OperatingHourUpdateManyWithoutProviderNestedInput
    appointments?: AppointmentUpdateManyWithoutProviderNestedInput
    documents?: DocumentUpdateManyWithoutProviderNestedInput
    breakTimes?: BreakTimeUpdateManyWithoutProviderNestedInput
    notifications?: NotificationUpdateManyWithoutProviderNestedInput
    reviews?: ReviewUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateWithoutStatusHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    healthcareName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    slotDuration?: IntFieldUpdateOperationsInput | number
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutProviderNestedInput
    operatingHours?: OperatingHourUncheckedUpdateManyWithoutProviderNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutProviderNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProviderNestedInput
    breakTimes?: BreakTimeUncheckedUpdateManyWithoutProviderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutProviderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type UserUpsertWithoutProviderStatusChangesInput = {
    update: XOR<UserUpdateWithoutProviderStatusChangesInput, UserUncheckedUpdateWithoutProviderStatusChangesInput>
    create: XOR<UserCreateWithoutProviderStatusChangesInput, UserUncheckedCreateWithoutProviderStatusChangesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProviderStatusChangesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProviderStatusChangesInput, UserUncheckedUpdateWithoutProviderStatusChangesInput>
  }

  export type UserUpdateWithoutProviderStatusChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    suspendedBy?: UserUpdateOneWithoutSuspendedUsersNestedInput
    suspendedUsers?: UserUpdateManyWithoutSuspendedByNestedInput
    provider?: ProviderUpdateOneWithoutUserNestedInput
    verifiedProviders?: ProviderUpdateManyWithoutVerifierNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    cancelledAppointments?: AppointmentUpdateManyWithoutCancellerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    conversationsAsUser1?: ConversationUpdateManyWithoutUser1NestedInput
    conversationsAsUser2?: ConversationUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewLikes?: ReviewLikeUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUpdateManyWithoutRespondedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutAdminNestedInput
    verifiedDocuments?: DocumentUpdateManyWithoutVerifiedByNestedInput
  }

  export type UserUncheckedUpdateWithoutProviderStatusChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedById?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    suspendedUsers?: UserUncheckedUpdateManyWithoutSuspendedByNestedInput
    provider?: ProviderUncheckedUpdateOneWithoutUserNestedInput
    verifiedProviders?: ProviderUncheckedUpdateManyWithoutVerifierNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    cancelledAppointments?: AppointmentUncheckedUpdateManyWithoutCancellerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conversationsAsUser1?: ConversationUncheckedUpdateManyWithoutUser1NestedInput
    conversationsAsUser2?: ConversationUncheckedUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewLikes?: ReviewLikeUncheckedUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUncheckedUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUncheckedUpdateManyWithoutRespondedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminNestedInput
    verifiedDocuments?: DocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
  }

  export type UserCreateWithoutFeedbackSubmittedInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    suspendedBy?: UserCreateNestedOneWithoutSuspendedUsersInput
    suspendedUsers?: UserCreateNestedManyWithoutSuspendedByInput
    provider?: ProviderCreateNestedOneWithoutUserInput
    verifiedProviders?: ProviderCreateNestedManyWithoutVerifierInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    cancelledAppointments?: AppointmentCreateNestedManyWithoutCancellerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    conversationsAsUser1?: ConversationCreateNestedManyWithoutUser1Input
    conversationsAsUser2?: ConversationCreateNestedManyWithoutUser2Input
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewLikes?: ReviewLikeCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackCreateNestedManyWithoutRespondedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutAdminInput
    providerStatusChanges?: ProviderStatusHistoryCreateNestedManyWithoutChangedByInput
    verifiedDocuments?: DocumentCreateNestedManyWithoutVerifiedByInput
  }

  export type UserUncheckedCreateWithoutFeedbackSubmittedInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    suspendedById?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    suspendedUsers?: UserUncheckedCreateNestedManyWithoutSuspendedByInput
    provider?: ProviderUncheckedCreateNestedOneWithoutUserInput
    verifiedProviders?: ProviderUncheckedCreateNestedManyWithoutVerifierInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    cancelledAppointments?: AppointmentUncheckedCreateNestedManyWithoutCancellerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conversationsAsUser1?: ConversationUncheckedCreateNestedManyWithoutUser1Input
    conversationsAsUser2?: ConversationUncheckedCreateNestedManyWithoutUser2Input
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewLikes?: ReviewLikeUncheckedCreateNestedManyWithoutUserInput
    feedbackResponses?: SystemFeedbackUncheckedCreateNestedManyWithoutRespondedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    verifiedDocuments?: DocumentUncheckedCreateNestedManyWithoutVerifiedByInput
  }

  export type UserCreateOrConnectWithoutFeedbackSubmittedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFeedbackSubmittedInput, UserUncheckedCreateWithoutFeedbackSubmittedInput>
  }

  export type UserCreateWithoutFeedbackResponsesInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    suspendedBy?: UserCreateNestedOneWithoutSuspendedUsersInput
    suspendedUsers?: UserCreateNestedManyWithoutSuspendedByInput
    provider?: ProviderCreateNestedOneWithoutUserInput
    verifiedProviders?: ProviderCreateNestedManyWithoutVerifierInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    cancelledAppointments?: AppointmentCreateNestedManyWithoutCancellerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    conversationsAsUser1?: ConversationCreateNestedManyWithoutUser1Input
    conversationsAsUser2?: ConversationCreateNestedManyWithoutUser2Input
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewLikes?: ReviewLikeCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutAdminInput
    providerStatusChanges?: ProviderStatusHistoryCreateNestedManyWithoutChangedByInput
    verifiedDocuments?: DocumentCreateNestedManyWithoutVerifiedByInput
  }

  export type UserUncheckedCreateWithoutFeedbackResponsesInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
    suspendedById?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    suspendedUsers?: UserUncheckedCreateNestedManyWithoutSuspendedByInput
    provider?: ProviderUncheckedCreateNestedOneWithoutUserInput
    verifiedProviders?: ProviderUncheckedCreateNestedManyWithoutVerifierInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    cancelledAppointments?: AppointmentUncheckedCreateNestedManyWithoutCancellerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    conversationsAsUser1?: ConversationUncheckedCreateNestedManyWithoutUser1Input
    conversationsAsUser2?: ConversationUncheckedCreateNestedManyWithoutUser2Input
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewLikes?: ReviewLikeUncheckedCreateNestedManyWithoutUserInput
    feedbackSubmitted?: SystemFeedbackUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    verifiedDocuments?: DocumentUncheckedCreateNestedManyWithoutVerifiedByInput
  }

  export type UserCreateOrConnectWithoutFeedbackResponsesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFeedbackResponsesInput, UserUncheckedCreateWithoutFeedbackResponsesInput>
  }

  export type UserUpsertWithoutFeedbackSubmittedInput = {
    update: XOR<UserUpdateWithoutFeedbackSubmittedInput, UserUncheckedUpdateWithoutFeedbackSubmittedInput>
    create: XOR<UserCreateWithoutFeedbackSubmittedInput, UserUncheckedCreateWithoutFeedbackSubmittedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFeedbackSubmittedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFeedbackSubmittedInput, UserUncheckedUpdateWithoutFeedbackSubmittedInput>
  }

  export type UserUpdateWithoutFeedbackSubmittedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    suspendedBy?: UserUpdateOneWithoutSuspendedUsersNestedInput
    suspendedUsers?: UserUpdateManyWithoutSuspendedByNestedInput
    provider?: ProviderUpdateOneWithoutUserNestedInput
    verifiedProviders?: ProviderUpdateManyWithoutVerifierNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    cancelledAppointments?: AppointmentUpdateManyWithoutCancellerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    conversationsAsUser1?: ConversationUpdateManyWithoutUser1NestedInput
    conversationsAsUser2?: ConversationUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewLikes?: ReviewLikeUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUpdateManyWithoutRespondedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutAdminNestedInput
    providerStatusChanges?: ProviderStatusHistoryUpdateManyWithoutChangedByNestedInput
    verifiedDocuments?: DocumentUpdateManyWithoutVerifiedByNestedInput
  }

  export type UserUncheckedUpdateWithoutFeedbackSubmittedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedById?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    suspendedUsers?: UserUncheckedUpdateManyWithoutSuspendedByNestedInput
    provider?: ProviderUncheckedUpdateOneWithoutUserNestedInput
    verifiedProviders?: ProviderUncheckedUpdateManyWithoutVerifierNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    cancelledAppointments?: AppointmentUncheckedUpdateManyWithoutCancellerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conversationsAsUser1?: ConversationUncheckedUpdateManyWithoutUser1NestedInput
    conversationsAsUser2?: ConversationUncheckedUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewLikes?: ReviewLikeUncheckedUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUncheckedUpdateManyWithoutRespondedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminNestedInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    verifiedDocuments?: DocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
  }

  export type UserUpsertWithoutFeedbackResponsesInput = {
    update: XOR<UserUpdateWithoutFeedbackResponsesInput, UserUncheckedUpdateWithoutFeedbackResponsesInput>
    create: XOR<UserCreateWithoutFeedbackResponsesInput, UserUncheckedCreateWithoutFeedbackResponsesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFeedbackResponsesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFeedbackResponsesInput, UserUncheckedUpdateWithoutFeedbackResponsesInput>
  }

  export type UserUpdateWithoutFeedbackResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    suspendedBy?: UserUpdateOneWithoutSuspendedUsersNestedInput
    suspendedUsers?: UserUpdateManyWithoutSuspendedByNestedInput
    provider?: ProviderUpdateOneWithoutUserNestedInput
    verifiedProviders?: ProviderUpdateManyWithoutVerifierNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    cancelledAppointments?: AppointmentUpdateManyWithoutCancellerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    conversationsAsUser1?: ConversationUpdateManyWithoutUser1NestedInput
    conversationsAsUser2?: ConversationUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewLikes?: ReviewLikeUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutAdminNestedInput
    providerStatusChanges?: ProviderStatusHistoryUpdateManyWithoutChangedByNestedInput
    verifiedDocuments?: DocumentUpdateManyWithoutVerifiedByNestedInput
  }

  export type UserUncheckedUpdateWithoutFeedbackResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedById?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    suspendedUsers?: UserUncheckedUpdateManyWithoutSuspendedByNestedInput
    provider?: ProviderUncheckedUpdateOneWithoutUserNestedInput
    verifiedProviders?: ProviderUncheckedUpdateManyWithoutVerifierNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    cancelledAppointments?: AppointmentUncheckedUpdateManyWithoutCancellerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conversationsAsUser1?: ConversationUncheckedUpdateManyWithoutUser1NestedInput
    conversationsAsUser2?: ConversationUncheckedUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewLikes?: ReviewLikeUncheckedUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminNestedInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    verifiedDocuments?: DocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
  }

  export type SessionCreateManyUserInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type AccountCreateManyUserInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManySuspendedByInput = {
    id?: string
    name: string
    email: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    suspendedAt?: Date | string | null
    suspendReason?: string | null
  }

  export type ProviderCreateManyVerifierInput = {
    id?: string
    userId: string
    categoryId?: string | null
    healthcareName: string
    description?: string | null
    phoneNumber?: string | null
    email?: string | null
    coverPhoto?: string | null
    status?: $Enums.ProviderStatus
    address: string
    city?: string
    province?: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    slotDuration?: number
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentCreateManyUserInput = {
    id?: string
    appointmentNumber: string
    providerId: string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.AppointmentStatus
    notes?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    patientName: string
    patientEmail: string
    patientPhone?: string | null
    activityNotes?: string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    cancelledBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentCreateManyCancellerInput = {
    id?: string
    appointmentNumber: string
    userId: string
    providerId: string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.AppointmentStatus
    notes?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    patientName: string
    patientEmail: string
    patientPhone?: string | null
    activityNotes?: string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    appointmentId?: string | null
    providerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationCreateManyUser1Input = {
    id?: string
    user2Id: string
    lastMessageAt?: Date | string | null
    lastMessageContent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationCreateManyUser2Input = {
    id?: string
    user1Id: string
    lastMessageAt?: Date | string | null
    lastMessageContent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateManySenderInput = {
    id?: string
    conversationId: string
    content: string
    status?: $Enums.MessageStatus
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyUserInput = {
    id?: string
    appointmentId: string
    providerId: string
    rating: number
    comment?: string | null
    isAnonymous?: boolean
    professionalismRating?: number | null
    cleanlinessRating?: number | null
    waitTimeRating?: number | null
    valueRating?: number | null
    providerResponse?: string | null
    respondedAt?: Date | string | null
    isEdited?: boolean
    editedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewLikeCreateManyUserInput = {
    id?: string
    reviewId: string
    createdAt?: Date | string
  }

  export type SystemFeedbackCreateManyUserInput = {
    id?: string
    category: $Enums.FeedbackCategory
    priority?: $Enums.FeedbackPriority | null
    title: string
    message: string
    satisfactionRating?: number | null
    adminResponse?: string | null
    respondedAt?: Date | string | null
    respondedById?: string | null
    isRead?: boolean
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemFeedbackCreateManyRespondedByInput = {
    id?: string
    userId: string
    category: $Enums.FeedbackCategory
    priority?: $Enums.FeedbackPriority | null
    title: string
    message: string
    satisfactionRating?: number | null
    adminResponse?: string | null
    respondedAt?: Date | string | null
    isRead?: boolean
    isResolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyAdminInput = {
    id?: string
    action: string
    targetType: string
    targetId: string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type ProviderStatusHistoryCreateManyChangedByInput = {
    id?: string
    providerId: string
    fromStatus: $Enums.ProviderStatus
    toStatus: $Enums.ProviderStatus
    reason?: string | null
    createdAt?: Date | string
  }

  export type DocumentCreateManyVerifiedByInput = {
    id?: string
    providerId: string
    documentType: string
    filePath: string
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    verificationStatus?: $Enums.DocumentVerificationStatus
    rejectionReason?: string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutSuspendedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    suspendedUsers?: UserUpdateManyWithoutSuspendedByNestedInput
    provider?: ProviderUpdateOneWithoutUserNestedInput
    verifiedProviders?: ProviderUpdateManyWithoutVerifierNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    cancelledAppointments?: AppointmentUpdateManyWithoutCancellerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    conversationsAsUser1?: ConversationUpdateManyWithoutUser1NestedInput
    conversationsAsUser2?: ConversationUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewLikes?: ReviewLikeUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUpdateManyWithoutRespondedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutAdminNestedInput
    providerStatusChanges?: ProviderStatusHistoryUpdateManyWithoutChangedByNestedInput
    verifiedDocuments?: DocumentUpdateManyWithoutVerifiedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSuspendedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    suspendedUsers?: UserUncheckedUpdateManyWithoutSuspendedByNestedInput
    provider?: ProviderUncheckedUpdateOneWithoutUserNestedInput
    verifiedProviders?: ProviderUncheckedUpdateManyWithoutVerifierNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    cancelledAppointments?: AppointmentUncheckedUpdateManyWithoutCancellerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    conversationsAsUser1?: ConversationUncheckedUpdateManyWithoutUser1NestedInput
    conversationsAsUser2?: ConversationUncheckedUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewLikes?: ReviewLikeUncheckedUpdateManyWithoutUserNestedInput
    feedbackSubmitted?: SystemFeedbackUncheckedUpdateManyWithoutUserNestedInput
    feedbackResponses?: SystemFeedbackUncheckedUpdateManyWithoutRespondedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutAdminNestedInput
    providerStatusChanges?: ProviderStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    verifiedDocuments?: DocumentUncheckedUpdateManyWithoutVerifiedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutSuspendedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    suspendReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProviderUpdateWithoutVerifierInput = {
    id?: StringFieldUpdateOperationsInput | string
    healthcareName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    slotDuration?: IntFieldUpdateOperationsInput | number
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProviderNestedInput
    category?: CategoryUpdateOneWithoutProvidersNestedInput
    services?: ServiceUpdateManyWithoutProviderNestedInput
    operatingHours?: OperatingHourUpdateManyWithoutProviderNestedInput
    appointments?: AppointmentUpdateManyWithoutProviderNestedInput
    documents?: DocumentUpdateManyWithoutProviderNestedInput
    breakTimes?: BreakTimeUpdateManyWithoutProviderNestedInput
    notifications?: NotificationUpdateManyWithoutProviderNestedInput
    reviews?: ReviewUpdateManyWithoutProviderNestedInput
    statusHistory?: ProviderStatusHistoryUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateWithoutVerifierInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    healthcareName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    slotDuration?: IntFieldUpdateOperationsInput | number
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutProviderNestedInput
    operatingHours?: OperatingHourUncheckedUpdateManyWithoutProviderNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutProviderNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProviderNestedInput
    breakTimes?: BreakTimeUncheckedUpdateManyWithoutProviderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutProviderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProviderNestedInput
    statusHistory?: ProviderStatusHistoryUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateManyWithoutVerifierInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    healthcareName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    slotDuration?: IntFieldUpdateOperationsInput | number
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentNumber?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patientName?: StringFieldUpdateOperationsInput | string
    patientEmail?: StringFieldUpdateOperationsInput | string
    patientPhone?: NullableStringFieldUpdateOperationsInput | string | null
    activityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: ProviderUpdateOneRequiredWithoutAppointmentsNestedInput
    canceller?: UserUpdateOneWithoutCancelledAppointmentsNestedInput
    services?: AppointmentServiceUpdateManyWithoutAppointmentNestedInput
    notifications?: NotificationUpdateManyWithoutAppointmentNestedInput
    review?: ReviewUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentNumber?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patientName?: StringFieldUpdateOperationsInput | string
    patientEmail?: StringFieldUpdateOperationsInput | string
    patientPhone?: NullableStringFieldUpdateOperationsInput | string | null
    activityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: AppointmentServiceUncheckedUpdateManyWithoutAppointmentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutAppointmentNestedInput
    review?: ReviewUncheckedUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentNumber?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patientName?: StringFieldUpdateOperationsInput | string
    patientEmail?: StringFieldUpdateOperationsInput | string
    patientPhone?: NullableStringFieldUpdateOperationsInput | string | null
    activityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUpdateWithoutCancellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentNumber?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patientName?: StringFieldUpdateOperationsInput | string
    patientEmail?: StringFieldUpdateOperationsInput | string
    patientPhone?: NullableStringFieldUpdateOperationsInput | string | null
    activityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAppointmentsNestedInput
    provider?: ProviderUpdateOneRequiredWithoutAppointmentsNestedInput
    services?: AppointmentServiceUpdateManyWithoutAppointmentNestedInput
    notifications?: NotificationUpdateManyWithoutAppointmentNestedInput
    review?: ReviewUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutCancellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentNumber?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patientName?: StringFieldUpdateOperationsInput | string
    patientEmail?: StringFieldUpdateOperationsInput | string
    patientPhone?: NullableStringFieldUpdateOperationsInput | string | null
    activityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: AppointmentServiceUncheckedUpdateManyWithoutAppointmentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutAppointmentNestedInput
    review?: ReviewUncheckedUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutCancellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentNumber?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patientName?: StringFieldUpdateOperationsInput | string
    patientEmail?: StringFieldUpdateOperationsInput | string
    patientPhone?: NullableStringFieldUpdateOperationsInput | string | null
    activityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneWithoutNotificationsNestedInput
    provider?: ProviderUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUpdateWithoutUser1Input = {
    id?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageContent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user2?: UserUpdateOneRequiredWithoutConversationsAsUser2NestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutUser1Input = {
    id?: StringFieldUpdateOperationsInput | string
    user2Id?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageContent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutUser1Input = {
    id?: StringFieldUpdateOperationsInput | string
    user2Id?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageContent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUpdateWithoutUser2Input = {
    id?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageContent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user1?: UserUpdateOneRequiredWithoutConversationsAsUser1NestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutUser2Input = {
    id?: StringFieldUpdateOperationsInput | string
    user1Id?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageContent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutUser2Input = {
    id?: StringFieldUpdateOperationsInput | string
    user1Id?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageContent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    professionalismRating?: NullableIntFieldUpdateOperationsInput | number | null
    cleanlinessRating?: NullableIntFieldUpdateOperationsInput | number | null
    waitTimeRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueRating?: NullableIntFieldUpdateOperationsInput | number | null
    providerResponse?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneRequiredWithoutReviewNestedInput
    provider?: ProviderUpdateOneRequiredWithoutReviewsNestedInput
    likes?: ReviewLikeUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    professionalismRating?: NullableIntFieldUpdateOperationsInput | number | null
    cleanlinessRating?: NullableIntFieldUpdateOperationsInput | number | null
    waitTimeRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueRating?: NullableIntFieldUpdateOperationsInput | number | null
    providerResponse?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: ReviewLikeUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    professionalismRating?: NullableIntFieldUpdateOperationsInput | number | null
    cleanlinessRating?: NullableIntFieldUpdateOperationsInput | number | null
    waitTimeRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueRating?: NullableIntFieldUpdateOperationsInput | number | null
    providerResponse?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewLikeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: ReviewUpdateOneRequiredWithoutLikesNestedInput
  }

  export type ReviewLikeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewLikeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemFeedbackUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumFeedbackCategoryFieldUpdateOperationsInput | $Enums.FeedbackCategory
    priority?: NullableEnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    satisfactionRating?: NullableIntFieldUpdateOperationsInput | number | null
    adminResponse?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedBy?: UserUpdateOneWithoutFeedbackResponsesNestedInput
  }

  export type SystemFeedbackUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumFeedbackCategoryFieldUpdateOperationsInput | $Enums.FeedbackCategory
    priority?: NullableEnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    satisfactionRating?: NullableIntFieldUpdateOperationsInput | number | null
    adminResponse?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedById?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemFeedbackUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumFeedbackCategoryFieldUpdateOperationsInput | $Enums.FeedbackCategory
    priority?: NullableEnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    satisfactionRating?: NullableIntFieldUpdateOperationsInput | number | null
    adminResponse?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedById?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemFeedbackUpdateWithoutRespondedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumFeedbackCategoryFieldUpdateOperationsInput | $Enums.FeedbackCategory
    priority?: NullableEnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    satisfactionRating?: NullableIntFieldUpdateOperationsInput | number | null
    adminResponse?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFeedbackSubmittedNestedInput
  }

  export type SystemFeedbackUncheckedUpdateWithoutRespondedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    category?: EnumFeedbackCategoryFieldUpdateOperationsInput | $Enums.FeedbackCategory
    priority?: NullableEnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    satisfactionRating?: NullableIntFieldUpdateOperationsInput | number | null
    adminResponse?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemFeedbackUncheckedUpdateManyWithoutRespondedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    category?: EnumFeedbackCategoryFieldUpdateOperationsInput | $Enums.FeedbackCategory
    priority?: NullableEnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    satisfactionRating?: NullableIntFieldUpdateOperationsInput | number | null
    adminResponse?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProviderStatusHistoryUpdateWithoutChangedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromStatus?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    toStatus?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: ProviderUpdateOneRequiredWithoutStatusHistoryNestedInput
  }

  export type ProviderStatusHistoryUncheckedUpdateWithoutChangedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    fromStatus?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    toStatus?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProviderStatusHistoryUncheckedUpdateManyWithoutChangedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    fromStatus?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    toStatus?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutVerifiedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationStatus?: EnumDocumentVerificationStatusFieldUpdateOperationsInput | $Enums.DocumentVerificationStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: ProviderUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutVerifiedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationStatus?: EnumDocumentVerificationStatusFieldUpdateOperationsInput | $Enums.DocumentVerificationStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUncheckedUpdateManyWithoutVerifiedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationStatus?: EnumDocumentVerificationStatusFieldUpdateOperationsInput | $Enums.DocumentVerificationStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProviderCreateManyCategoryInput = {
    id?: string
    userId: string
    verifiedBy?: string | null
    healthcareName: string
    description?: string | null
    phoneNumber?: string | null
    email?: string | null
    coverPhoto?: string | null
    status?: $Enums.ProviderStatus
    address: string
    city?: string
    province?: string
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    slotDuration?: number
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProviderUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    healthcareName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    slotDuration?: IntFieldUpdateOperationsInput | number
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProviderNestedInput
    verifier?: UserUpdateOneWithoutVerifiedProvidersNestedInput
    services?: ServiceUpdateManyWithoutProviderNestedInput
    operatingHours?: OperatingHourUpdateManyWithoutProviderNestedInput
    appointments?: AppointmentUpdateManyWithoutProviderNestedInput
    documents?: DocumentUpdateManyWithoutProviderNestedInput
    breakTimes?: BreakTimeUpdateManyWithoutProviderNestedInput
    notifications?: NotificationUpdateManyWithoutProviderNestedInput
    reviews?: ReviewUpdateManyWithoutProviderNestedInput
    statusHistory?: ProviderStatusHistoryUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    healthcareName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    slotDuration?: IntFieldUpdateOperationsInput | number
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutProviderNestedInput
    operatingHours?: OperatingHourUncheckedUpdateManyWithoutProviderNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutProviderNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutProviderNestedInput
    breakTimes?: BreakTimeUncheckedUpdateManyWithoutProviderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutProviderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProviderNestedInput
    statusHistory?: ProviderStatusHistoryUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    healthcareName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    slotDuration?: IntFieldUpdateOperationsInput | number
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateManyProviderInput = {
    id?: string
    name: string
    description?: string | null
    type?: $Enums.ServiceType
    pricingModel?: $Enums.PricingModel
    fixedPrice?: number
    priceMin?: number
    priceMax?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OperatingHourCreateManyProviderInput = {
    id?: string
    dayOfWeek: number
    startTime?: string | null
    endTime?: string | null
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentCreateManyProviderInput = {
    id?: string
    appointmentNumber: string
    userId: string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.AppointmentStatus
    notes?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    patientName: string
    patientEmail: string
    patientPhone?: string | null
    activityNotes?: string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    cancelledBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyProviderInput = {
    id?: string
    documentType: string
    filePath: string
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    verificationStatus?: $Enums.DocumentVerificationStatus
    verifiedById?: string | null
    rejectionReason?: string | null
  }

  export type BreakTimeCreateManyProviderInput = {
    id?: string
    name?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyProviderInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    appointmentId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyProviderInput = {
    id?: string
    appointmentId: string
    userId: string
    rating: number
    comment?: string | null
    isAnonymous?: boolean
    professionalismRating?: number | null
    cleanlinessRating?: number | null
    waitTimeRating?: number | null
    valueRating?: number | null
    providerResponse?: string | null
    respondedAt?: Date | string | null
    isEdited?: boolean
    editedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProviderStatusHistoryCreateManyProviderInput = {
    id?: string
    fromStatus: $Enums.ProviderStatus
    toStatus: $Enums.ProviderStatus
    reason?: string | null
    changedById: string
    createdAt?: Date | string
  }

  export type ServiceUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    fixedPrice?: IntFieldUpdateOperationsInput | number
    priceMin?: IntFieldUpdateOperationsInput | number
    priceMax?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentServiceUpdateManyWithoutServiceNestedInput
    includedServices?: ServicePackageUpdateManyWithoutParentPackageNestedInput
    partOfPackages?: ServicePackageUpdateManyWithoutChildServiceNestedInput
    acceptedInsurances?: ServiceInsuranceUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    fixedPrice?: IntFieldUpdateOperationsInput | number
    priceMin?: IntFieldUpdateOperationsInput | number
    priceMax?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentServiceUncheckedUpdateManyWithoutServiceNestedInput
    includedServices?: ServicePackageUncheckedUpdateManyWithoutParentPackageNestedInput
    partOfPackages?: ServicePackageUncheckedUpdateManyWithoutChildServiceNestedInput
    acceptedInsurances?: ServiceInsuranceUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    pricingModel?: EnumPricingModelFieldUpdateOperationsInput | $Enums.PricingModel
    fixedPrice?: IntFieldUpdateOperationsInput | number
    priceMin?: IntFieldUpdateOperationsInput | number
    priceMax?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperatingHourUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperatingHourUncheckedUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperatingHourUncheckedUpdateManyWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentNumber?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patientName?: StringFieldUpdateOperationsInput | string
    patientEmail?: StringFieldUpdateOperationsInput | string
    patientPhone?: NullableStringFieldUpdateOperationsInput | string | null
    activityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAppointmentsNestedInput
    canceller?: UserUpdateOneWithoutCancelledAppointmentsNestedInput
    services?: AppointmentServiceUpdateManyWithoutAppointmentNestedInput
    notifications?: NotificationUpdateManyWithoutAppointmentNestedInput
    review?: ReviewUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentNumber?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patientName?: StringFieldUpdateOperationsInput | string
    patientEmail?: StringFieldUpdateOperationsInput | string
    patientPhone?: NullableStringFieldUpdateOperationsInput | string | null
    activityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: AppointmentServiceUncheckedUpdateManyWithoutAppointmentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutAppointmentNestedInput
    review?: ReviewUncheckedUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentNumber?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patientName?: StringFieldUpdateOperationsInput | string
    patientEmail?: StringFieldUpdateOperationsInput | string
    patientPhone?: NullableStringFieldUpdateOperationsInput | string | null
    activityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationStatus?: EnumDocumentVerificationStatusFieldUpdateOperationsInput | $Enums.DocumentVerificationStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: UserUpdateOneWithoutVerifiedDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationStatus?: EnumDocumentVerificationStatusFieldUpdateOperationsInput | $Enums.DocumentVerificationStatus
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUncheckedUpdateManyWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationStatus?: EnumDocumentVerificationStatusFieldUpdateOperationsInput | $Enums.DocumentVerificationStatus
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BreakTimeUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreakTimeUncheckedUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BreakTimeUncheckedUpdateManyWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
    appointment?: AppointmentUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    professionalismRating?: NullableIntFieldUpdateOperationsInput | number | null
    cleanlinessRating?: NullableIntFieldUpdateOperationsInput | number | null
    waitTimeRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueRating?: NullableIntFieldUpdateOperationsInput | number | null
    providerResponse?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneRequiredWithoutReviewNestedInput
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    likes?: ReviewLikeUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    professionalismRating?: NullableIntFieldUpdateOperationsInput | number | null
    cleanlinessRating?: NullableIntFieldUpdateOperationsInput | number | null
    waitTimeRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueRating?: NullableIntFieldUpdateOperationsInput | number | null
    providerResponse?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: ReviewLikeUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateManyWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    professionalismRating?: NullableIntFieldUpdateOperationsInput | number | null
    cleanlinessRating?: NullableIntFieldUpdateOperationsInput | number | null
    waitTimeRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueRating?: NullableIntFieldUpdateOperationsInput | number | null
    providerResponse?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProviderStatusHistoryUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromStatus?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    toStatus?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changedBy?: UserUpdateOneRequiredWithoutProviderStatusChangesNestedInput
  }

  export type ProviderStatusHistoryUncheckedUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromStatus?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    toStatus?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    changedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProviderStatusHistoryUncheckedUpdateManyWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromStatus?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    toStatus?: EnumProviderStatusFieldUpdateOperationsInput | $Enums.ProviderStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    changedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentServiceCreateManyServiceInput = {
    appointmentId: string
    priceAtBooking: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicePackageCreateManyParentPackageInput = {
    childServiceId: string
    createdAt?: Date | string
  }

  export type ServicePackageCreateManyChildServiceInput = {
    parentPackageId: string
    createdAt?: Date | string
  }

  export type ServiceInsuranceCreateManyServiceInput = {
    insuranceProviderId: string
  }

  export type AppointmentServiceUpdateWithoutServiceInput = {
    priceAtBooking?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneRequiredWithoutServicesNestedInput
  }

  export type AppointmentServiceUncheckedUpdateWithoutServiceInput = {
    appointmentId?: StringFieldUpdateOperationsInput | string
    priceAtBooking?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentServiceUncheckedUpdateManyWithoutServiceInput = {
    appointmentId?: StringFieldUpdateOperationsInput | string
    priceAtBooking?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePackageUpdateWithoutParentPackageInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childService?: ServiceUpdateOneRequiredWithoutPartOfPackagesNestedInput
  }

  export type ServicePackageUncheckedUpdateWithoutParentPackageInput = {
    childServiceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePackageUncheckedUpdateManyWithoutParentPackageInput = {
    childServiceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePackageUpdateWithoutChildServiceInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentPackage?: ServiceUpdateOneRequiredWithoutIncludedServicesNestedInput
  }

  export type ServicePackageUncheckedUpdateWithoutChildServiceInput = {
    parentPackageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePackageUncheckedUpdateManyWithoutChildServiceInput = {
    parentPackageId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceInsuranceUpdateWithoutServiceInput = {
    insuranceProvider?: InsuranceProviderUpdateOneRequiredWithoutServicesNestedInput
  }

  export type ServiceInsuranceUncheckedUpdateWithoutServiceInput = {
    insuranceProviderId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceInsuranceUncheckedUpdateManyWithoutServiceInput = {
    insuranceProviderId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceInsuranceCreateManyInsuranceProviderInput = {
    serviceId: string
  }

  export type ServiceInsuranceUpdateWithoutInsuranceProviderInput = {
    service?: ServiceUpdateOneRequiredWithoutAcceptedInsurancesNestedInput
  }

  export type ServiceInsuranceUncheckedUpdateWithoutInsuranceProviderInput = {
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceInsuranceUncheckedUpdateManyWithoutInsuranceProviderInput = {
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type AppointmentServiceCreateManyAppointmentInput = {
    serviceId: string
    priceAtBooking: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyAppointmentInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    providerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentServiceUpdateWithoutAppointmentInput = {
    priceAtBooking?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutAppointmentsNestedInput
  }

  export type AppointmentServiceUncheckedUpdateWithoutAppointmentInput = {
    serviceId?: StringFieldUpdateOperationsInput | string
    priceAtBooking?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentServiceUncheckedUpdateManyWithoutAppointmentInput = {
    serviceId?: StringFieldUpdateOperationsInput | string
    priceAtBooking?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
    provider?: ProviderUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyConversationInput = {
    id?: string
    senderId: string
    content: string
    status?: $Enums.MessageStatus
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewLikeCreateManyReviewInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type ReviewLikeUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewLikesNestedInput
  }

  export type ReviewLikeUncheckedUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewLikeUncheckedUpdateManyWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}